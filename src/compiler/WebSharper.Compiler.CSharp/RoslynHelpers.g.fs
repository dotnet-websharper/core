// Generated by genHelpers.fsx. Do not modify.

module WebSharper.Compiler.CSharp.RoslynHelpers

open Microsoft.CodeAnalysis
open Microsoft.CodeAnalysis.CSharp
open Microsoft.CodeAnalysis.CSharp.Syntax

let optionalToken (t: SyntaxToken) =
    match t.Kind() with
    | SyntaxKind.None -> None
    | _ -> Some t

type [<RequireQualifiedAccess>] TypeParameterVarianceKeyword =
    | InKeyword 
    | OutKeyword
with
    static member FromToken(t: SyntaxToken) =
        match t.Kind() with
        | SyntaxKind.InKeyword -> InKeyword
        | SyntaxKind.OutKeyword -> OutKeyword
        | k -> failwithf "Unexpected TypeParameterVarianceKeyword kind: %O" k

type [<RequireQualifiedAccess>] IdentifierNameIdentifier =
    | IdentifierToken of string
    | GlobalKeyword  
with
    static member FromToken(t: SyntaxToken) =
        match t.Kind() with
        | SyntaxKind.IdentifierToken -> IdentifierToken t.Text
        | SyntaxKind.GlobalKeyword -> GlobalKeyword
        | k -> failwithf "Unexpected IdentifierNameIdentifier kind: %O" k

type [<RequireQualifiedAccess>] PredefinedTypeKeyword =
    | BoolKeyword   
    | ByteKeyword   
    | SByteKeyword  
    | IntKeyword    
    | UIntKeyword   
    | ShortKeyword  
    | UShortKeyword 
    | LongKeyword   
    | ULongKeyword  
    | FloatKeyword  
    | DoubleKeyword 
    | DecimalKeyword
    | StringKeyword 
    | CharKeyword   
    | ObjectKeyword 
    | VoidKeyword   
with
    static member FromToken(t: SyntaxToken) =
        match t.Kind() with
        | SyntaxKind.BoolKeyword -> BoolKeyword
        | SyntaxKind.ByteKeyword -> ByteKeyword
        | SyntaxKind.SByteKeyword -> SByteKeyword
        | SyntaxKind.IntKeyword -> IntKeyword
        | SyntaxKind.UIntKeyword -> UIntKeyword
        | SyntaxKind.ShortKeyword -> ShortKeyword
        | SyntaxKind.UShortKeyword -> UShortKeyword
        | SyntaxKind.LongKeyword -> LongKeyword
        | SyntaxKind.ULongKeyword -> ULongKeyword
        | SyntaxKind.FloatKeyword -> FloatKeyword
        | SyntaxKind.DoubleKeyword -> DoubleKeyword
        | SyntaxKind.DecimalKeyword -> DecimalKeyword
        | SyntaxKind.StringKeyword -> StringKeyword
        | SyntaxKind.CharKeyword -> CharKeyword
        | SyntaxKind.ObjectKeyword -> ObjectKeyword
        | SyntaxKind.VoidKeyword -> VoidKeyword
        | k -> failwithf "Unexpected PredefinedTypeKeyword kind: %O" k

type [<RequireQualifiedAccess>] ParameterIdentifier =
    | IdentifierToken of string
    | ArgListKeyword 
with
    static member FromToken(t: SyntaxToken) =
        match t.Kind() with
        | SyntaxKind.IdentifierToken -> IdentifierToken t.Text
        | SyntaxKind.ArgListKeyword -> ArgListKeyword
        | k -> failwithf "Unexpected ParameterIdentifier kind: %O" k

type [<RequireQualifiedAccess>] ArgumentRefKindKeyword =
    | RefKeyword
    | OutKeyword
    | InKeyword 
with
    static member FromToken(t: SyntaxToken) =
        match t.Kind() with
        | SyntaxKind.RefKeyword -> RefKeyword
        | SyntaxKind.OutKeyword -> OutKeyword
        | SyntaxKind.InKeyword -> InKeyword
        | k -> failwithf "Unexpected ArgumentRefKindKeyword kind: %O" k

type [<RequireQualifiedAccess>] GotoStatementKind =
    | GotoStatement       
    | GotoCaseStatement   
    | GotoDefaultStatement
with
    static member FromKind(k: SyntaxKind) =
        match k with
        | SyntaxKind.GotoStatement -> GotoStatement
        | SyntaxKind.GotoCaseStatement -> GotoCaseStatement
        | SyntaxKind.GotoDefaultStatement -> GotoDefaultStatement
        | _ -> failwithf "Unexpected GotoStatementKind kind: %O" k

type [<RequireQualifiedAccess>] GotoStatementCaseOrDefaultKeyword =
    | CaseKeyword   
    | DefaultKeyword
with
    static member FromToken(t: SyntaxToken) =
        match t.Kind() with
        | SyntaxKind.CaseKeyword -> CaseKeyword
        | SyntaxKind.DefaultKeyword -> DefaultKeyword
        | k -> failwithf "Unexpected GotoStatementCaseOrDefaultKeyword kind: %O" k

type [<RequireQualifiedAccess>] YieldStatementKind =
    | YieldReturnStatement
    | YieldBreakStatement 
with
    static member FromKind(k: SyntaxKind) =
        match k with
        | SyntaxKind.YieldReturnStatement -> YieldReturnStatement
        | SyntaxKind.YieldBreakStatement -> YieldBreakStatement
        | _ -> failwithf "Unexpected YieldStatementKind kind: %O" k

type [<RequireQualifiedAccess>] YieldStatementReturnOrBreakKeyword =
    | ReturnKeyword
    | BreakKeyword 
with
    static member FromToken(t: SyntaxToken) =
        match t.Kind() with
        | SyntaxKind.ReturnKeyword -> ReturnKeyword
        | SyntaxKind.BreakKeyword -> BreakKeyword
        | k -> failwithf "Unexpected YieldStatementReturnOrBreakKeyword kind: %O" k

type [<RequireQualifiedAccess>] CheckedStatementKind =
    | CheckedStatement  
    | UncheckedStatement
with
    static member FromKind(k: SyntaxKind) =
        match k with
        | SyntaxKind.CheckedStatement -> CheckedStatement
        | SyntaxKind.UncheckedStatement -> UncheckedStatement
        | _ -> failwithf "Unexpected CheckedStatementKind kind: %O" k

type [<RequireQualifiedAccess>] CheckedStatementKeyword =
    | CheckedKeyword  
    | UncheckedKeyword
with
    static member FromToken(t: SyntaxToken) =
        match t.Kind() with
        | SyntaxKind.CheckedKeyword -> CheckedKeyword
        | SyntaxKind.UncheckedKeyword -> UncheckedKeyword
        | k -> failwithf "Unexpected CheckedStatementKeyword kind: %O" k

type [<RequireQualifiedAccess>] PrefixUnaryExpressionKind =
    | UnaryPlusExpression         
    | UnaryMinusExpression        
    | BitwiseNotExpression        
    | LogicalNotExpression        
    | PreIncrementExpression      
    | PreDecrementExpression      
    | AddressOfExpression         
    | PointerIndirectionExpression
    | IndexExpression             
with
    static member FromKind(k: SyntaxKind) =
        match k with
        | SyntaxKind.UnaryPlusExpression -> UnaryPlusExpression
        | SyntaxKind.UnaryMinusExpression -> UnaryMinusExpression
        | SyntaxKind.BitwiseNotExpression -> BitwiseNotExpression
        | SyntaxKind.LogicalNotExpression -> LogicalNotExpression
        | SyntaxKind.PreIncrementExpression -> PreIncrementExpression
        | SyntaxKind.PreDecrementExpression -> PreDecrementExpression
        | SyntaxKind.AddressOfExpression -> AddressOfExpression
        | SyntaxKind.PointerIndirectionExpression -> PointerIndirectionExpression
        | SyntaxKind.IndexExpression -> IndexExpression
        | _ -> failwithf "Unexpected PrefixUnaryExpressionKind kind: %O" k

type [<RequireQualifiedAccess>] PrefixUnaryExpressionOperatorToken =
    | PlusToken       
    | MinusToken      
    | TildeToken      
    | ExclamationToken
    | PlusPlusToken   
    | MinusMinusToken 
    | AmpersandToken  
    | AsteriskToken   
    | CaretToken      
with
    static member FromToken(t: SyntaxToken) =
        match t.Kind() with
        | SyntaxKind.PlusToken -> PlusToken
        | SyntaxKind.MinusToken -> MinusToken
        | SyntaxKind.TildeToken -> TildeToken
        | SyntaxKind.ExclamationToken -> ExclamationToken
        | SyntaxKind.PlusPlusToken -> PlusPlusToken
        | SyntaxKind.MinusMinusToken -> MinusMinusToken
        | SyntaxKind.AmpersandToken -> AmpersandToken
        | SyntaxKind.AsteriskToken -> AsteriskToken
        | SyntaxKind.CaretToken -> CaretToken
        | k -> failwithf "Unexpected PrefixUnaryExpressionOperatorToken kind: %O" k

type [<RequireQualifiedAccess>] PostfixUnaryExpressionKind =
    | PostIncrementExpression          
    | PostDecrementExpression          
    | SuppressNullableWarningExpression
with
    static member FromKind(k: SyntaxKind) =
        match k with
        | SyntaxKind.PostIncrementExpression -> PostIncrementExpression
        | SyntaxKind.PostDecrementExpression -> PostDecrementExpression
        | SyntaxKind.SuppressNullableWarningExpression -> SuppressNullableWarningExpression
        | _ -> failwithf "Unexpected PostfixUnaryExpressionKind kind: %O" k

type [<RequireQualifiedAccess>] PostfixUnaryExpressionOperatorToken =
    | PlusPlusToken   
    | MinusMinusToken 
    | ExclamationToken
with
    static member FromToken(t: SyntaxToken) =
        match t.Kind() with
        | SyntaxKind.PlusPlusToken -> PlusPlusToken
        | SyntaxKind.MinusMinusToken -> MinusMinusToken
        | SyntaxKind.ExclamationToken -> ExclamationToken
        | k -> failwithf "Unexpected PostfixUnaryExpressionOperatorToken kind: %O" k

type [<RequireQualifiedAccess>] MemberAccessExpressionKind =
    | SimpleMemberAccessExpression 
    | PointerMemberAccessExpression
with
    static member FromKind(k: SyntaxKind) =
        match k with
        | SyntaxKind.SimpleMemberAccessExpression -> SimpleMemberAccessExpression
        | SyntaxKind.PointerMemberAccessExpression -> PointerMemberAccessExpression
        | _ -> failwithf "Unexpected MemberAccessExpressionKind kind: %O" k

type [<RequireQualifiedAccess>] MemberAccessExpressionOperatorToken =
    | DotToken             
    | MinusGreaterThanToken
with
    static member FromToken(t: SyntaxToken) =
        match t.Kind() with
        | SyntaxKind.DotToken -> DotToken
        | SyntaxKind.MinusGreaterThanToken -> MinusGreaterThanToken
        | k -> failwithf "Unexpected MemberAccessExpressionOperatorToken kind: %O" k

type [<RequireQualifiedAccess>] BinaryExpressionKind =
    | AddExpression               
    | SubtractExpression          
    | MultiplyExpression          
    | DivideExpression            
    | ModuloExpression            
    | LeftShiftExpression         
    | RightShiftExpression        
    | LogicalOrExpression         
    | LogicalAndExpression        
    | BitwiseOrExpression         
    | BitwiseAndExpression        
    | ExclusiveOrExpression       
    | EqualsExpression            
    | NotEqualsExpression         
    | LessThanExpression          
    | LessThanOrEqualExpression   
    | GreaterThanExpression       
    | GreaterThanOrEqualExpression
    | IsExpression                
    | AsExpression                
    | CoalesceExpression          
with
    static member FromKind(k: SyntaxKind) =
        match k with
        | SyntaxKind.AddExpression -> AddExpression
        | SyntaxKind.SubtractExpression -> SubtractExpression
        | SyntaxKind.MultiplyExpression -> MultiplyExpression
        | SyntaxKind.DivideExpression -> DivideExpression
        | SyntaxKind.ModuloExpression -> ModuloExpression
        | SyntaxKind.LeftShiftExpression -> LeftShiftExpression
        | SyntaxKind.RightShiftExpression -> RightShiftExpression
        | SyntaxKind.LogicalOrExpression -> LogicalOrExpression
        | SyntaxKind.LogicalAndExpression -> LogicalAndExpression
        | SyntaxKind.BitwiseOrExpression -> BitwiseOrExpression
        | SyntaxKind.BitwiseAndExpression -> BitwiseAndExpression
        | SyntaxKind.ExclusiveOrExpression -> ExclusiveOrExpression
        | SyntaxKind.EqualsExpression -> EqualsExpression
        | SyntaxKind.NotEqualsExpression -> NotEqualsExpression
        | SyntaxKind.LessThanExpression -> LessThanExpression
        | SyntaxKind.LessThanOrEqualExpression -> LessThanOrEqualExpression
        | SyntaxKind.GreaterThanExpression -> GreaterThanExpression
        | SyntaxKind.GreaterThanOrEqualExpression -> GreaterThanOrEqualExpression
        | SyntaxKind.IsExpression -> IsExpression
        | SyntaxKind.AsExpression -> AsExpression
        | SyntaxKind.CoalesceExpression -> CoalesceExpression
        | _ -> failwithf "Unexpected BinaryExpressionKind kind: %O" k

type [<RequireQualifiedAccess>] BinaryExpressionOperatorToken =
    | PlusToken                  
    | MinusToken                 
    | AsteriskToken              
    | SlashToken                 
    | PercentToken               
    | LessThanLessThanToken      
    | GreaterThanGreaterThanToken
    | BarBarToken                
    | AmpersandAmpersandToken    
    | BarToken                   
    | AmpersandToken             
    | CaretToken                 
    | EqualsEqualsToken          
    | ExclamationEqualsToken     
    | LessThanToken              
    | LessThanEqualsToken        
    | GreaterThanToken           
    | GreaterThanEqualsToken     
    | IsKeyword                  
    | AsKeyword                  
    | QuestionQuestionToken      
with
    static member FromToken(t: SyntaxToken) =
        match t.Kind() with
        | SyntaxKind.PlusToken -> PlusToken
        | SyntaxKind.MinusToken -> MinusToken
        | SyntaxKind.AsteriskToken -> AsteriskToken
        | SyntaxKind.SlashToken -> SlashToken
        | SyntaxKind.PercentToken -> PercentToken
        | SyntaxKind.LessThanLessThanToken -> LessThanLessThanToken
        | SyntaxKind.GreaterThanGreaterThanToken -> GreaterThanGreaterThanToken
        | SyntaxKind.BarBarToken -> BarBarToken
        | SyntaxKind.AmpersandAmpersandToken -> AmpersandAmpersandToken
        | SyntaxKind.BarToken -> BarToken
        | SyntaxKind.AmpersandToken -> AmpersandToken
        | SyntaxKind.CaretToken -> CaretToken
        | SyntaxKind.EqualsEqualsToken -> EqualsEqualsToken
        | SyntaxKind.ExclamationEqualsToken -> ExclamationEqualsToken
        | SyntaxKind.LessThanToken -> LessThanToken
        | SyntaxKind.LessThanEqualsToken -> LessThanEqualsToken
        | SyntaxKind.GreaterThanToken -> GreaterThanToken
        | SyntaxKind.GreaterThanEqualsToken -> GreaterThanEqualsToken
        | SyntaxKind.IsKeyword -> IsKeyword
        | SyntaxKind.AsKeyword -> AsKeyword
        | SyntaxKind.QuestionQuestionToken -> QuestionQuestionToken
        | k -> failwithf "Unexpected BinaryExpressionOperatorToken kind: %O" k

type [<RequireQualifiedAccess>] AssignmentExpressionKind =
    | SimpleAssignmentExpression     
    | AddAssignmentExpression        
    | SubtractAssignmentExpression   
    | MultiplyAssignmentExpression   
    | DivideAssignmentExpression     
    | ModuloAssignmentExpression     
    | AndAssignmentExpression        
    | ExclusiveOrAssignmentExpression
    | OrAssignmentExpression         
    | LeftShiftAssignmentExpression  
    | RightShiftAssignmentExpression 
    | CoalesceAssignmentExpression   
with
    static member FromKind(k: SyntaxKind) =
        match k with
        | SyntaxKind.SimpleAssignmentExpression -> SimpleAssignmentExpression
        | SyntaxKind.AddAssignmentExpression -> AddAssignmentExpression
        | SyntaxKind.SubtractAssignmentExpression -> SubtractAssignmentExpression
        | SyntaxKind.MultiplyAssignmentExpression -> MultiplyAssignmentExpression
        | SyntaxKind.DivideAssignmentExpression -> DivideAssignmentExpression
        | SyntaxKind.ModuloAssignmentExpression -> ModuloAssignmentExpression
        | SyntaxKind.AndAssignmentExpression -> AndAssignmentExpression
        | SyntaxKind.ExclusiveOrAssignmentExpression -> ExclusiveOrAssignmentExpression
        | SyntaxKind.OrAssignmentExpression -> OrAssignmentExpression
        | SyntaxKind.LeftShiftAssignmentExpression -> LeftShiftAssignmentExpression
        | SyntaxKind.RightShiftAssignmentExpression -> RightShiftAssignmentExpression
        | SyntaxKind.CoalesceAssignmentExpression -> CoalesceAssignmentExpression
        | _ -> failwithf "Unexpected AssignmentExpressionKind kind: %O" k

type [<RequireQualifiedAccess>] AssignmentExpressionOperatorToken =
    | EqualsToken                      
    | PlusEqualsToken                  
    | MinusEqualsToken                 
    | AsteriskEqualsToken              
    | SlashEqualsToken                 
    | PercentEqualsToken               
    | AmpersandEqualsToken             
    | CaretEqualsToken                 
    | BarEqualsToken                   
    | LessThanLessThanEqualsToken      
    | GreaterThanGreaterThanEqualsToken
    | QuestionQuestionEqualsToken      
with
    static member FromToken(t: SyntaxToken) =
        match t.Kind() with
        | SyntaxKind.EqualsToken -> EqualsToken
        | SyntaxKind.PlusEqualsToken -> PlusEqualsToken
        | SyntaxKind.MinusEqualsToken -> MinusEqualsToken
        | SyntaxKind.AsteriskEqualsToken -> AsteriskEqualsToken
        | SyntaxKind.SlashEqualsToken -> SlashEqualsToken
        | SyntaxKind.PercentEqualsToken -> PercentEqualsToken
        | SyntaxKind.AmpersandEqualsToken -> AmpersandEqualsToken
        | SyntaxKind.CaretEqualsToken -> CaretEqualsToken
        | SyntaxKind.BarEqualsToken -> BarEqualsToken
        | SyntaxKind.LessThanLessThanEqualsToken -> LessThanLessThanEqualsToken
        | SyntaxKind.GreaterThanGreaterThanEqualsToken -> GreaterThanGreaterThanEqualsToken
        | SyntaxKind.QuestionQuestionEqualsToken -> QuestionQuestionEqualsToken
        | k -> failwithf "Unexpected AssignmentExpressionOperatorToken kind: %O" k

type [<RequireQualifiedAccess>] LiteralExpressionKind =
    | ArgListExpression         
    | NumericLiteralExpression  
    | StringLiteralExpression   
    | CharacterLiteralExpression
    | TrueLiteralExpression     
    | FalseLiteralExpression    
    | NullLiteralExpression     
    | DefaultLiteralExpression  
with
    static member FromKind(k: SyntaxKind) =
        match k with
        | SyntaxKind.ArgListExpression -> ArgListExpression
        | SyntaxKind.NumericLiteralExpression -> NumericLiteralExpression
        | SyntaxKind.StringLiteralExpression -> StringLiteralExpression
        | SyntaxKind.CharacterLiteralExpression -> CharacterLiteralExpression
        | SyntaxKind.TrueLiteralExpression -> TrueLiteralExpression
        | SyntaxKind.FalseLiteralExpression -> FalseLiteralExpression
        | SyntaxKind.NullLiteralExpression -> NullLiteralExpression
        | SyntaxKind.DefaultLiteralExpression -> DefaultLiteralExpression
        | _ -> failwithf "Unexpected LiteralExpressionKind kind: %O" k

type [<RequireQualifiedAccess>] LiteralExpressionToken =
    | ArgListKeyword       
    | NumericLiteralToken   of string
    | StringLiteralToken    of string
    | CharacterLiteralToken of string
    | TrueKeyword          
    | FalseKeyword         
    | NullKeyword          
    | DefaultKeyword       
with
    static member FromToken(t: SyntaxToken) =
        match t.Kind() with
        | SyntaxKind.ArgListKeyword -> ArgListKeyword
        | SyntaxKind.NumericLiteralToken -> NumericLiteralToken t.Text
        | SyntaxKind.StringLiteralToken -> StringLiteralToken t.Text
        | SyntaxKind.CharacterLiteralToken -> CharacterLiteralToken t.Text
        | SyntaxKind.TrueKeyword -> TrueKeyword
        | SyntaxKind.FalseKeyword -> FalseKeyword
        | SyntaxKind.NullKeyword -> NullKeyword
        | SyntaxKind.DefaultKeyword -> DefaultKeyword
        | k -> failwithf "Unexpected LiteralExpressionToken kind: %O" k

type [<RequireQualifiedAccess>] CheckedExpressionKind =
    | CheckedExpression  
    | UncheckedExpression
with
    static member FromKind(k: SyntaxKind) =
        match k with
        | SyntaxKind.CheckedExpression -> CheckedExpression
        | SyntaxKind.UncheckedExpression -> UncheckedExpression
        | _ -> failwithf "Unexpected CheckedExpressionKind kind: %O" k

type [<RequireQualifiedAccess>] CheckedExpressionKeyword =
    | CheckedKeyword  
    | UncheckedKeyword
with
    static member FromToken(t: SyntaxToken) =
        match t.Kind() with
        | SyntaxKind.CheckedKeyword -> CheckedKeyword
        | SyntaxKind.UncheckedKeyword -> UncheckedKeyword
        | k -> failwithf "Unexpected CheckedExpressionKeyword kind: %O" k

type [<RequireQualifiedAccess>] InitializerExpressionKind =
    | ObjectInitializerExpression        
    | CollectionInitializerExpression    
    | ArrayInitializerExpression         
    | ComplexElementInitializerExpression
with
    static member FromKind(k: SyntaxKind) =
        match k with
        | SyntaxKind.ObjectInitializerExpression -> ObjectInitializerExpression
        | SyntaxKind.CollectionInitializerExpression -> CollectionInitializerExpression
        | SyntaxKind.ArrayInitializerExpression -> ArrayInitializerExpression
        | SyntaxKind.ComplexElementInitializerExpression -> ComplexElementInitializerExpression
        | _ -> failwithf "Unexpected InitializerExpressionKind kind: %O" k

type [<RequireQualifiedAccess>] OrderingKind =
    | AscendingOrdering 
    | DescendingOrdering
with
    static member FromKind(k: SyntaxKind) =
        match k with
        | SyntaxKind.AscendingOrdering -> AscendingOrdering
        | SyntaxKind.DescendingOrdering -> DescendingOrdering
        | _ -> failwithf "Unexpected OrderingKind kind: %O" k

type [<RequireQualifiedAccess>] OrderingAscendingOrDescendingKeyword =
    | AscendingKeyword 
    | DescendingKeyword
with
    static member FromToken(t: SyntaxToken) =
        match t.Kind() with
        | SyntaxKind.AscendingKeyword -> AscendingKeyword
        | SyntaxKind.DescendingKeyword -> DescendingKeyword
        | k -> failwithf "Unexpected OrderingAscendingOrDescendingKeyword kind: %O" k

type [<RequireQualifiedAccess>] InterpolatedStringExpressionStringStartToken =
    | InterpolatedStringStartToken        
    | InterpolatedVerbatimStringStartToken
with
    static member FromToken(t: SyntaxToken) =
        match t.Kind() with
        | SyntaxKind.InterpolatedStringStartToken -> InterpolatedStringStartToken
        | SyntaxKind.InterpolatedVerbatimStringStartToken -> InterpolatedVerbatimStringStartToken
        | k -> failwithf "Unexpected InterpolatedStringExpressionStringStartToken kind: %O" k

type [<RequireQualifiedAccess>] OperatorDeclarationOperatorToken =
    | PlusToken                  
    | MinusToken                 
    | ExclamationToken           
    | TildeToken                 
    | PlusPlusToken              
    | MinusMinusToken            
    | AsteriskToken              
    | SlashToken                 
    | PercentToken               
    | LessThanLessThanToken      
    | GreaterThanGreaterThanToken
    | BarToken                   
    | AmpersandToken             
    | CaretToken                 
    | EqualsEqualsToken          
    | ExclamationEqualsToken     
    | LessThanToken              
    | LessThanEqualsToken        
    | GreaterThanToken           
    | GreaterThanEqualsToken     
    | FalseKeyword               
    | TrueKeyword                
    | IsKeyword                  
with
    static member FromToken(t: SyntaxToken) =
        match t.Kind() with
        | SyntaxKind.PlusToken -> PlusToken
        | SyntaxKind.MinusToken -> MinusToken
        | SyntaxKind.ExclamationToken -> ExclamationToken
        | SyntaxKind.TildeToken -> TildeToken
        | SyntaxKind.PlusPlusToken -> PlusPlusToken
        | SyntaxKind.MinusMinusToken -> MinusMinusToken
        | SyntaxKind.AsteriskToken -> AsteriskToken
        | SyntaxKind.SlashToken -> SlashToken
        | SyntaxKind.PercentToken -> PercentToken
        | SyntaxKind.LessThanLessThanToken -> LessThanLessThanToken
        | SyntaxKind.GreaterThanGreaterThanToken -> GreaterThanGreaterThanToken
        | SyntaxKind.BarToken -> BarToken
        | SyntaxKind.AmpersandToken -> AmpersandToken
        | SyntaxKind.CaretToken -> CaretToken
        | SyntaxKind.EqualsEqualsToken -> EqualsEqualsToken
        | SyntaxKind.ExclamationEqualsToken -> ExclamationEqualsToken
        | SyntaxKind.LessThanToken -> LessThanToken
        | SyntaxKind.LessThanEqualsToken -> LessThanEqualsToken
        | SyntaxKind.GreaterThanToken -> GreaterThanToken
        | SyntaxKind.GreaterThanEqualsToken -> GreaterThanEqualsToken
        | SyntaxKind.FalseKeyword -> FalseKeyword
        | SyntaxKind.TrueKeyword -> TrueKeyword
        | SyntaxKind.IsKeyword -> IsKeyword
        | k -> failwithf "Unexpected OperatorDeclarationOperatorToken kind: %O" k

type [<RequireQualifiedAccess>] ConversionOperatorDeclarationImplicitOrExplicitKeyword =
    | ImplicitKeyword
    | ExplicitKeyword
with
    static member FromToken(t: SyntaxToken) =
        match t.Kind() with
        | SyntaxKind.ImplicitKeyword -> ImplicitKeyword
        | SyntaxKind.ExplicitKeyword -> ExplicitKeyword
        | k -> failwithf "Unexpected ConversionOperatorDeclarationImplicitOrExplicitKeyword kind: %O" k

type [<RequireQualifiedAccess>] ConstructorInitializerKind =
    | BaseConstructorInitializer
    | ThisConstructorInitializer
with
    static member FromKind(k: SyntaxKind) =
        match k with
        | SyntaxKind.BaseConstructorInitializer -> BaseConstructorInitializer
        | SyntaxKind.ThisConstructorInitializer -> ThisConstructorInitializer
        | _ -> failwithf "Unexpected ConstructorInitializerKind kind: %O" k

type [<RequireQualifiedAccess>] ConstructorInitializerThisOrBaseKeyword =
    | BaseKeyword
    | ThisKeyword
with
    static member FromToken(t: SyntaxToken) =
        match t.Kind() with
        | SyntaxKind.BaseKeyword -> BaseKeyword
        | SyntaxKind.ThisKeyword -> ThisKeyword
        | k -> failwithf "Unexpected ConstructorInitializerThisOrBaseKeyword kind: %O" k

type TypeParameterData(node: TypeParameterSyntax) =
    member this.Node = node
    member this.VarianceKeyword = node.VarianceKeyword |> optionalToken |> Option.map TypeParameterVarianceKeyword.FromToken
    member this.Identifier = node.Identifier
    static member FromNode(n: TypeParameterSyntax) = TypeParameterData(n)

and TypeParameterListData(node: TypeParameterListSyntax) =
    member this.Node = node
    member this.Parameters = node.Parameters |> Seq.map TypeParameterData.FromNode
    static member FromNode(n: TypeParameterListSyntax) = TypeParameterListData(n)

and IdentifierNameData(node: IdentifierNameSyntax) =
    member this.Node = node
    member this.Identifier = node.Identifier |> IdentifierNameIdentifier.FromToken
    static member FromNode(n: IdentifierNameSyntax) = IdentifierNameData(n)

and TypeArgumentListData(node: TypeArgumentListSyntax) =
    member this.Node = node
    member this.Arguments = node.Arguments |> Seq.map TypeData.FromNode
    static member FromNode(n: TypeArgumentListSyntax) = TypeArgumentListData(n)

and GenericNameData(node: GenericNameSyntax) =
    member this.Node = node
    member this.Identifier = node.Identifier
    member this.TypeArgumentList = node.TypeArgumentList |> TypeArgumentListData.FromNode
    static member FromNode(n: GenericNameSyntax) = GenericNameData(n)

and [<RequireQualifiedAccess>] SimpleNameData =
    | IdentifierName of IdentifierNameData
    | GenericName    of GenericNameData
with
    static member FromNode(n: SimpleNameSyntax) =
        match n with
        | :? IdentifierNameSyntax as d -> IdentifierName (IdentifierNameData.FromNode(d))
        | :? GenericNameSyntax as d -> GenericName (GenericNameData.FromNode(d))
        | _ -> failwithf "Unexpected descendant class of SimpleNameSyntax"
    member this.Node =
        match this with
        | IdentifierName d -> d.Node :> SimpleNameSyntax
        | GenericName d -> d.Node :> SimpleNameSyntax

and QualifiedNameData(node: QualifiedNameSyntax) =
    member this.Node = node
    member this.Left = node.Left |> NameData.FromNode
    member this.Right = node.Right |> SimpleNameData.FromNode
    static member FromNode(n: QualifiedNameSyntax) = QualifiedNameData(n)

and AliasQualifiedNameData(node: AliasQualifiedNameSyntax) =
    member this.Node = node
    member this.Alias = node.Alias |> IdentifierNameData.FromNode
    member this.Name = node.Name |> SimpleNameData.FromNode
    static member FromNode(n: AliasQualifiedNameSyntax) = AliasQualifiedNameData(n)

and [<RequireQualifiedAccess>] NameData =
    | SimpleName         of SimpleNameData
    | QualifiedName      of QualifiedNameData
    | AliasQualifiedName of AliasQualifiedNameData
with
    static member FromNode(n: NameSyntax) =
        match n with
        | :? SimpleNameSyntax as d -> SimpleName (SimpleNameData.FromNode(d))
        | :? QualifiedNameSyntax as d -> QualifiedName (QualifiedNameData.FromNode(d))
        | :? AliasQualifiedNameSyntax as d -> AliasQualifiedName (AliasQualifiedNameData.FromNode(d))
        | _ -> failwithf "Unexpected descendant class of NameSyntax"
    member this.Node =
        match this with
        | SimpleName d -> d.Node :> NameSyntax
        | QualifiedName d -> d.Node :> NameSyntax
        | AliasQualifiedName d -> d.Node :> NameSyntax

and PredefinedTypeData(node: PredefinedTypeSyntax) =
    member this.Node = node
    member this.Keyword = node.Keyword |> PredefinedTypeKeyword.FromToken
    static member FromNode(n: PredefinedTypeSyntax) = PredefinedTypeData(n)

and ThisExpressionData(node: ThisExpressionSyntax) =
    member this.Node = node
    static member FromNode(n: ThisExpressionSyntax) = ThisExpressionData(n)

and BaseExpressionData(node: BaseExpressionSyntax) =
    member this.Node = node
    static member FromNode(n: BaseExpressionSyntax) = BaseExpressionData(n)

and [<RequireQualifiedAccess>] InstanceExpressionData =
    | ThisExpression of ThisExpressionData
    | BaseExpression of BaseExpressionData
with
    static member FromNode(n: InstanceExpressionSyntax) =
        match n with
        | :? ThisExpressionSyntax as d -> ThisExpression (ThisExpressionData.FromNode(d))
        | :? BaseExpressionSyntax as d -> BaseExpression (BaseExpressionData.FromNode(d))
        | _ -> failwithf "Unexpected descendant class of InstanceExpressionSyntax"
    member this.Node =
        match this with
        | ThisExpression d -> d.Node :> InstanceExpressionSyntax
        | BaseExpression d -> d.Node :> InstanceExpressionSyntax

and EqualsValueClauseData(node: EqualsValueClauseSyntax) =
    member this.Node = node
    member this.Value = node.Value |> ExpressionData.FromNode
    static member FromNode(n: EqualsValueClauseSyntax) = EqualsValueClauseData(n)

and ParameterData(node: ParameterSyntax) =
    member this.Node = node
    member this.Type = node.Type |> Option.ofObj |> Option.map TypeData.FromNode
    member this.Identifier = node.Identifier |> ParameterIdentifier.FromToken
    member this.Default = node.Default |> Option.ofObj |> Option.map EqualsValueClauseData.FromNode
    static member FromNode(n: ParameterSyntax) = ParameterData(n)

and SimpleLambdaExpressionData(node: SimpleLambdaExpressionSyntax) =
    member this.Node = node
    member this.Parameter = node.Parameter |> ParameterData.FromNode
    static member FromNode(n: SimpleLambdaExpressionSyntax) = SimpleLambdaExpressionData(n)

and ParameterListData(node: ParameterListSyntax) =
    member this.Node = node
    member this.Parameters = node.Parameters |> Seq.map ParameterData.FromNode
    static member FromNode(n: ParameterListSyntax) = ParameterListData(n)

and ParenthesizedLambdaExpressionData(node: ParenthesizedLambdaExpressionSyntax) =
    member this.Node = node
    member this.ParameterList = node.ParameterList |> ParameterListData.FromNode
    static member FromNode(n: ParenthesizedLambdaExpressionSyntax) = ParenthesizedLambdaExpressionData(n)

and [<RequireQualifiedAccess>] LambdaExpressionData =
    | SimpleLambdaExpression        of SimpleLambdaExpressionData
    | ParenthesizedLambdaExpression of ParenthesizedLambdaExpressionData
with
    static member FromNode(n: LambdaExpressionSyntax) =
        match n with
        | :? SimpleLambdaExpressionSyntax as d -> SimpleLambdaExpression (SimpleLambdaExpressionData.FromNode(d))
        | :? ParenthesizedLambdaExpressionSyntax as d -> ParenthesizedLambdaExpression (ParenthesizedLambdaExpressionData.FromNode(d))
        | _ -> failwithf "Unexpected descendant class of LambdaExpressionSyntax"
    member this.Node =
        match this with
        | SimpleLambdaExpression d -> d.Node :> LambdaExpressionSyntax
        | ParenthesizedLambdaExpression d -> d.Node :> LambdaExpressionSyntax

and ForEachStatementData(node: ForEachStatementSyntax) =
    member this.Node = node
    member this.Type = node.Type |> TypeData.FromNode
    member this.Identifier = node.Identifier
    member this.Expression = node.Expression |> ExpressionData.FromNode
    member this.Statement = node.Statement |> StatementData.FromNode
    static member FromNode(n: ForEachStatementSyntax) = ForEachStatementData(n)

and ForEachVariableStatementData(node: ForEachVariableStatementSyntax) =
    member this.Node = node
    member this.Variable = node.Variable |> ExpressionData.FromNode
    member this.Expression = node.Expression |> ExpressionData.FromNode
    member this.Statement = node.Statement |> StatementData.FromNode
    static member FromNode(n: ForEachVariableStatementSyntax) = ForEachVariableStatementData(n)

and [<RequireQualifiedAccess>] CommonForEachStatementData =
    | ForEachStatement         of ForEachStatementData
    | ForEachVariableStatement of ForEachVariableStatementData
with
    static member FromNode(n: CommonForEachStatementSyntax) =
        match n with
        | :? ForEachStatementSyntax as d -> ForEachStatement (ForEachStatementData.FromNode(d))
        | :? ForEachVariableStatementSyntax as d -> ForEachVariableStatement (ForEachVariableStatementData.FromNode(d))
        | _ -> failwithf "Unexpected descendant class of CommonForEachStatementSyntax"
    member this.Node =
        match this with
        | ForEachStatement d -> d.Node :> CommonForEachStatementSyntax
        | ForEachVariableStatement d -> d.Node :> CommonForEachStatementSyntax

and LocalFunctionStatementData(node: LocalFunctionStatementSyntax) =
    member this.Node = node
    member this.ReturnType = node.ReturnType |> TypeData.FromNode
    member this.Identifier = node.Identifier
    member this.TypeParameterList = node.TypeParameterList |> Option.ofObj |> Option.map TypeParameterListData.FromNode
    member this.ParameterList = node.ParameterList |> ParameterListData.FromNode
    static member FromNode(n: LocalFunctionStatementSyntax) = LocalFunctionStatementData(n)

and NameColonData(node: NameColonSyntax) =
    member this.Node = node
    member this.Name = node.Name |> IdentifierNameData.FromNode
    static member FromNode(n: NameColonSyntax) = NameColonData(n)

and ArgumentData(node: ArgumentSyntax) =
    member this.Node = node
    member this.NameColon = node.NameColon |> Option.ofObj |> Option.map NameColonData.FromNode
    member this.RefKindKeyword = node.RefKindKeyword |> optionalToken |> Option.map ArgumentRefKindKeyword.FromToken
    member this.Expression = node.Expression |> ExpressionData.FromNode
    static member FromNode(n: ArgumentSyntax) = ArgumentData(n)

and BracketedArgumentListData(node: BracketedArgumentListSyntax) =
    member this.Node = node
    member this.Arguments = node.Arguments |> Seq.map ArgumentData.FromNode
    static member FromNode(n: BracketedArgumentListSyntax) = BracketedArgumentListData(n)

and VariableDeclaratorData(node: VariableDeclaratorSyntax) =
    member this.Node = node
    member this.Identifier = node.Identifier
    member this.ArgumentList = node.ArgumentList |> Option.ofObj |> Option.map BracketedArgumentListData.FromNode
    member this.Initializer = node.Initializer |> Option.ofObj |> Option.map EqualsValueClauseData.FromNode
    static member FromNode(n: VariableDeclaratorSyntax) = VariableDeclaratorData(n)

and VariableDeclarationData(node: VariableDeclarationSyntax) =
    member this.Node = node
    member this.Type = node.Type |> TypeData.FromNode
    member this.Variables = node.Variables |> Seq.map VariableDeclaratorData.FromNode
    static member FromNode(n: VariableDeclarationSyntax) = VariableDeclarationData(n)

and LocalDeclarationStatementData(node: LocalDeclarationStatementSyntax) =
    member this.Node = node
    member this.Declaration = node.Declaration |> VariableDeclarationData.FromNode
    static member FromNode(n: LocalDeclarationStatementSyntax) = LocalDeclarationStatementData(n)

and ExpressionStatementData(node: ExpressionStatementSyntax) =
    member this.Node = node
    member this.Expression = node.Expression |> ExpressionData.FromNode
    static member FromNode(n: ExpressionStatementSyntax) = ExpressionStatementData(n)

and EmptyStatementData(node: EmptyStatementSyntax) =
    member this.Node = node
    static member FromNode(n: EmptyStatementSyntax) = EmptyStatementData(n)

and LabeledStatementData(node: LabeledStatementSyntax) =
    member this.Node = node
    member this.Identifier = node.Identifier
    member this.Statement = node.Statement |> StatementData.FromNode
    static member FromNode(n: LabeledStatementSyntax) = LabeledStatementData(n)

and GotoStatementData(node: GotoStatementSyntax) =
    member this.Node = node
    member this.Kind = GotoStatementKind.FromKind(node.Kind())
    member this.CaseOrDefaultKeyword = node.CaseOrDefaultKeyword |> optionalToken |> Option.map GotoStatementCaseOrDefaultKeyword.FromToken
    member this.Expression = node.Expression |> Option.ofObj |> Option.map ExpressionData.FromNode
    static member FromNode(n: GotoStatementSyntax) = GotoStatementData(n)

and BreakStatementData(node: BreakStatementSyntax) =
    member this.Node = node
    static member FromNode(n: BreakStatementSyntax) = BreakStatementData(n)

and ContinueStatementData(node: ContinueStatementSyntax) =
    member this.Node = node
    static member FromNode(n: ContinueStatementSyntax) = ContinueStatementData(n)

and ReturnStatementData(node: ReturnStatementSyntax) =
    member this.Node = node
    member this.Expression = node.Expression |> Option.ofObj |> Option.map ExpressionData.FromNode
    static member FromNode(n: ReturnStatementSyntax) = ReturnStatementData(n)

and ThrowStatementData(node: ThrowStatementSyntax) =
    member this.Node = node
    member this.Expression = node.Expression |> Option.ofObj |> Option.map ExpressionData.FromNode
    static member FromNode(n: ThrowStatementSyntax) = ThrowStatementData(n)

and YieldStatementData(node: YieldStatementSyntax) =
    member this.Node = node
    member this.Kind = YieldStatementKind.FromKind(node.Kind())
    member this.ReturnOrBreakKeyword = node.ReturnOrBreakKeyword |> YieldStatementReturnOrBreakKeyword.FromToken
    member this.Expression = node.Expression |> Option.ofObj |> Option.map ExpressionData.FromNode
    static member FromNode(n: YieldStatementSyntax) = YieldStatementData(n)

and WhileStatementData(node: WhileStatementSyntax) =
    member this.Node = node
    member this.Condition = node.Condition |> ExpressionData.FromNode
    member this.Statement = node.Statement |> StatementData.FromNode
    static member FromNode(n: WhileStatementSyntax) = WhileStatementData(n)

and DoStatementData(node: DoStatementSyntax) =
    member this.Node = node
    member this.Statement = node.Statement |> StatementData.FromNode
    member this.Condition = node.Condition |> ExpressionData.FromNode
    static member FromNode(n: DoStatementSyntax) = DoStatementData(n)

and ForStatementData(node: ForStatementSyntax) =
    member this.Node = node
    member this.Condition = node.Condition |> Option.ofObj |> Option.map ExpressionData.FromNode
    member this.Incrementors = node.Incrementors |> Seq.map ExpressionData.FromNode
    member this.Statement = node.Statement |> StatementData.FromNode
    static member FromNode(n: ForStatementSyntax) = ForStatementData(n)

and UsingStatementData(node: UsingStatementSyntax) =
    member this.Node = node
    member this.Statement = node.Statement |> StatementData.FromNode
    static member FromNode(n: UsingStatementSyntax) = UsingStatementData(n)

and FixedStatementData(node: FixedStatementSyntax) =
    member this.Node = node
    member this.Declaration = node.Declaration |> VariableDeclarationData.FromNode
    member this.Statement = node.Statement |> StatementData.FromNode
    static member FromNode(n: FixedStatementSyntax) = FixedStatementData(n)

and CheckedStatementData(node: CheckedStatementSyntax) =
    member this.Node = node
    member this.Kind = CheckedStatementKind.FromKind(node.Kind())
    member this.Keyword = node.Keyword |> CheckedStatementKeyword.FromToken
    member this.Block = node.Block |> BlockData.FromNode
    static member FromNode(n: CheckedStatementSyntax) = CheckedStatementData(n)

and UnsafeStatementData(node: UnsafeStatementSyntax) =
    member this.Node = node
    member this.Block = node.Block |> BlockData.FromNode
    static member FromNode(n: UnsafeStatementSyntax) = UnsafeStatementData(n)

and LockStatementData(node: LockStatementSyntax) =
    member this.Node = node
    member this.Expression = node.Expression |> ExpressionData.FromNode
    member this.Statement = node.Statement |> StatementData.FromNode
    static member FromNode(n: LockStatementSyntax) = LockStatementData(n)

and ElseClauseData(node: ElseClauseSyntax) =
    member this.Node = node
    member this.Statement = node.Statement |> StatementData.FromNode
    static member FromNode(n: ElseClauseSyntax) = ElseClauseData(n)

and IfStatementData(node: IfStatementSyntax) =
    member this.Node = node
    member this.Condition = node.Condition |> ExpressionData.FromNode
    member this.Statement = node.Statement |> StatementData.FromNode
    member this.Else = node.Else |> Option.ofObj |> Option.map ElseClauseData.FromNode
    static member FromNode(n: IfStatementSyntax) = IfStatementData(n)

and DiscardPatternData(node: DiscardPatternSyntax) =
    member this.Node = node
    static member FromNode(n: DiscardPatternSyntax) = DiscardPatternData(n)

and SingleVariableDesignationData(node: SingleVariableDesignationSyntax) =
    member this.Node = node
    member this.Identifier = node.Identifier
    static member FromNode(n: SingleVariableDesignationSyntax) = SingleVariableDesignationData(n)

and DiscardDesignationData(node: DiscardDesignationSyntax) =
    member this.Node = node
    static member FromNode(n: DiscardDesignationSyntax) = DiscardDesignationData(n)

and ParenthesizedVariableDesignationData(node: ParenthesizedVariableDesignationSyntax) =
    member this.Node = node
    member this.Variables = node.Variables |> Seq.map VariableDesignationData.FromNode
    static member FromNode(n: ParenthesizedVariableDesignationSyntax) = ParenthesizedVariableDesignationData(n)

and [<RequireQualifiedAccess>] VariableDesignationData =
    | SingleVariableDesignation        of SingleVariableDesignationData
    | DiscardDesignation               of DiscardDesignationData
    | ParenthesizedVariableDesignation of ParenthesizedVariableDesignationData
with
    static member FromNode(n: VariableDesignationSyntax) =
        match n with
        | :? SingleVariableDesignationSyntax as d -> SingleVariableDesignation (SingleVariableDesignationData.FromNode(d))
        | :? DiscardDesignationSyntax as d -> DiscardDesignation (DiscardDesignationData.FromNode(d))
        | :? ParenthesizedVariableDesignationSyntax as d -> ParenthesizedVariableDesignation (ParenthesizedVariableDesignationData.FromNode(d))
        | _ -> failwithf "Unexpected descendant class of VariableDesignationSyntax"
    member this.Node =
        match this with
        | SingleVariableDesignation d -> d.Node :> VariableDesignationSyntax
        | DiscardDesignation d -> d.Node :> VariableDesignationSyntax
        | ParenthesizedVariableDesignation d -> d.Node :> VariableDesignationSyntax

and DeclarationPatternData(node: DeclarationPatternSyntax) =
    member this.Node = node
    member this.Type = node.Type |> TypeData.FromNode
    member this.Designation = node.Designation |> VariableDesignationData.FromNode
    static member FromNode(n: DeclarationPatternSyntax) = DeclarationPatternData(n)

and VarPatternData(node: VarPatternSyntax) =
    member this.Node = node
    member this.Designation = node.Designation |> VariableDesignationData.FromNode
    static member FromNode(n: VarPatternSyntax) = VarPatternData(n)

and SubpatternData(node: SubpatternSyntax) =
    member this.Node = node
    member this.NameColon = node.NameColon |> Option.ofObj |> Option.map NameColonData.FromNode
    member this.Pattern = node.Pattern |> PatternData.FromNode
    static member FromNode(n: SubpatternSyntax) = SubpatternData(n)

and PositionalPatternClauseData(node: PositionalPatternClauseSyntax) =
    member this.Node = node
    member this.Subpatterns = node.Subpatterns |> Seq.map SubpatternData.FromNode
    static member FromNode(n: PositionalPatternClauseSyntax) = PositionalPatternClauseData(n)

and PropertyPatternClauseData(node: PropertyPatternClauseSyntax) =
    member this.Node = node
    member this.Subpatterns = node.Subpatterns |> Seq.map SubpatternData.FromNode
    static member FromNode(n: PropertyPatternClauseSyntax) = PropertyPatternClauseData(n)

and RecursivePatternData(node: RecursivePatternSyntax) =
    member this.Node = node
    member this.Type = node.Type |> Option.ofObj |> Option.map TypeData.FromNode
    member this.PositionalPatternClause = node.PositionalPatternClause |> Option.ofObj |> Option.map PositionalPatternClauseData.FromNode
    member this.PropertyPatternClause = node.PropertyPatternClause |> Option.ofObj |> Option.map PropertyPatternClauseData.FromNode
    member this.Designation = node.Designation |> Option.ofObj |> Option.map VariableDesignationData.FromNode
    static member FromNode(n: RecursivePatternSyntax) = RecursivePatternData(n)

and ConstantPatternData(node: ConstantPatternSyntax) =
    member this.Node = node
    member this.Expression = node.Expression |> ExpressionData.FromNode
    static member FromNode(n: ConstantPatternSyntax) = ConstantPatternData(n)

and [<RequireQualifiedAccess>] PatternData =
    | DiscardPattern     of DiscardPatternData
    | DeclarationPattern of DeclarationPatternData
    | VarPattern         of VarPatternData
    | RecursivePattern   of RecursivePatternData
    | ConstantPattern    of ConstantPatternData
with
    static member FromNode(n: PatternSyntax) =
        match n with
        | :? DiscardPatternSyntax as d -> DiscardPattern (DiscardPatternData.FromNode(d))
        | :? DeclarationPatternSyntax as d -> DeclarationPattern (DeclarationPatternData.FromNode(d))
        | :? VarPatternSyntax as d -> VarPattern (VarPatternData.FromNode(d))
        | :? RecursivePatternSyntax as d -> RecursivePattern (RecursivePatternData.FromNode(d))
        | :? ConstantPatternSyntax as d -> ConstantPattern (ConstantPatternData.FromNode(d))
        | _ -> failwithf "Unexpected descendant class of PatternSyntax"
    member this.Node =
        match this with
        | DiscardPattern d -> d.Node :> PatternSyntax
        | DeclarationPattern d -> d.Node :> PatternSyntax
        | VarPattern d -> d.Node :> PatternSyntax
        | RecursivePattern d -> d.Node :> PatternSyntax
        | ConstantPattern d -> d.Node :> PatternSyntax

and WhenClauseData(node: WhenClauseSyntax) =
    member this.Node = node
    member this.Condition = node.Condition |> ExpressionData.FromNode
    static member FromNode(n: WhenClauseSyntax) = WhenClauseData(n)

and CasePatternSwitchLabelData(node: CasePatternSwitchLabelSyntax) =
    member this.Node = node
    member this.Pattern = node.Pattern |> PatternData.FromNode
    member this.WhenClause = node.WhenClause |> Option.ofObj |> Option.map WhenClauseData.FromNode
    static member FromNode(n: CasePatternSwitchLabelSyntax) = CasePatternSwitchLabelData(n)

and CaseSwitchLabelData(node: CaseSwitchLabelSyntax) =
    member this.Node = node
    member this.Value = node.Value |> ExpressionData.FromNode
    static member FromNode(n: CaseSwitchLabelSyntax) = CaseSwitchLabelData(n)

and DefaultSwitchLabelData(node: DefaultSwitchLabelSyntax) =
    member this.Node = node
    static member FromNode(n: DefaultSwitchLabelSyntax) = DefaultSwitchLabelData(n)

and [<RequireQualifiedAccess>] SwitchLabelData =
    | CasePatternSwitchLabel of CasePatternSwitchLabelData
    | CaseSwitchLabel        of CaseSwitchLabelData
    | DefaultSwitchLabel     of DefaultSwitchLabelData
with
    static member FromNode(n: SwitchLabelSyntax) =
        match n with
        | :? CasePatternSwitchLabelSyntax as d -> CasePatternSwitchLabel (CasePatternSwitchLabelData.FromNode(d))
        | :? CaseSwitchLabelSyntax as d -> CaseSwitchLabel (CaseSwitchLabelData.FromNode(d))
        | :? DefaultSwitchLabelSyntax as d -> DefaultSwitchLabel (DefaultSwitchLabelData.FromNode(d))
        | _ -> failwithf "Unexpected descendant class of SwitchLabelSyntax"
    member this.Node =
        match this with
        | CasePatternSwitchLabel d -> d.Node :> SwitchLabelSyntax
        | CaseSwitchLabel d -> d.Node :> SwitchLabelSyntax
        | DefaultSwitchLabel d -> d.Node :> SwitchLabelSyntax

and SwitchSectionData(node: SwitchSectionSyntax) =
    member this.Node = node
    member this.Labels = node.Labels |> Seq.map SwitchLabelData.FromNode
    member this.Statements = node.Statements |> Seq.map StatementData.FromNode
    static member FromNode(n: SwitchSectionSyntax) = SwitchSectionData(n)

and SwitchStatementData(node: SwitchStatementSyntax) =
    member this.Node = node
    member this.Expression = node.Expression |> ExpressionData.FromNode
    member this.Sections = node.Sections |> Seq.map SwitchSectionData.FromNode
    static member FromNode(n: SwitchStatementSyntax) = SwitchStatementData(n)

and CatchDeclarationData(node: CatchDeclarationSyntax) =
    member this.Node = node
    member this.Type = node.Type |> TypeData.FromNode
    member this.Identifier = node.Identifier
    static member FromNode(n: CatchDeclarationSyntax) = CatchDeclarationData(n)

and CatchFilterClauseData(node: CatchFilterClauseSyntax) =
    member this.Node = node
    member this.FilterExpression = node.FilterExpression |> ExpressionData.FromNode
    static member FromNode(n: CatchFilterClauseSyntax) = CatchFilterClauseData(n)

and CatchClauseData(node: CatchClauseSyntax) =
    member this.Node = node
    member this.Declaration = node.Declaration |> Option.ofObj |> Option.map CatchDeclarationData.FromNode
    member this.Filter = node.Filter |> Option.ofObj |> Option.map CatchFilterClauseData.FromNode
    member this.Block = node.Block |> BlockData.FromNode
    static member FromNode(n: CatchClauseSyntax) = CatchClauseData(n)

and FinallyClauseData(node: FinallyClauseSyntax) =
    member this.Node = node
    member this.Block = node.Block |> BlockData.FromNode
    static member FromNode(n: FinallyClauseSyntax) = FinallyClauseData(n)

and TryStatementData(node: TryStatementSyntax) =
    member this.Node = node
    member this.Block = node.Block |> BlockData.FromNode
    member this.Catches = node.Catches |> Seq.map CatchClauseData.FromNode
    member this.Finally = node.Finally |> Option.ofObj |> Option.map FinallyClauseData.FromNode
    static member FromNode(n: TryStatementSyntax) = TryStatementData(n)

and [<RequireQualifiedAccess>] StatementData =
    | CommonForEachStatement    of CommonForEachStatementData
    | Block                     of BlockData
    | LocalFunctionStatement    of LocalFunctionStatementData
    | LocalDeclarationStatement of LocalDeclarationStatementData
    | ExpressionStatement       of ExpressionStatementData
    | EmptyStatement            of EmptyStatementData
    | LabeledStatement          of LabeledStatementData
    | GotoStatement             of GotoStatementData
    | BreakStatement            of BreakStatementData
    | ContinueStatement         of ContinueStatementData
    | ReturnStatement           of ReturnStatementData
    | ThrowStatement            of ThrowStatementData
    | YieldStatement            of YieldStatementData
    | WhileStatement            of WhileStatementData
    | DoStatement               of DoStatementData
    | ForStatement              of ForStatementData
    | UsingStatement            of UsingStatementData
    | FixedStatement            of FixedStatementData
    | CheckedStatement          of CheckedStatementData
    | UnsafeStatement           of UnsafeStatementData
    | LockStatement             of LockStatementData
    | IfStatement               of IfStatementData
    | SwitchStatement           of SwitchStatementData
    | TryStatement              of TryStatementData
with
    static member FromNode(n: StatementSyntax) =
        match n with
        | :? CommonForEachStatementSyntax as d -> CommonForEachStatement (CommonForEachStatementData.FromNode(d))
        | :? BlockSyntax as d -> Block (BlockData.FromNode(d))
        | :? LocalFunctionStatementSyntax as d -> LocalFunctionStatement (LocalFunctionStatementData.FromNode(d))
        | :? LocalDeclarationStatementSyntax as d -> LocalDeclarationStatement (LocalDeclarationStatementData.FromNode(d))
        | :? ExpressionStatementSyntax as d -> ExpressionStatement (ExpressionStatementData.FromNode(d))
        | :? EmptyStatementSyntax as d -> EmptyStatement (EmptyStatementData.FromNode(d))
        | :? LabeledStatementSyntax as d -> LabeledStatement (LabeledStatementData.FromNode(d))
        | :? GotoStatementSyntax as d -> GotoStatement (GotoStatementData.FromNode(d))
        | :? BreakStatementSyntax as d -> BreakStatement (BreakStatementData.FromNode(d))
        | :? ContinueStatementSyntax as d -> ContinueStatement (ContinueStatementData.FromNode(d))
        | :? ReturnStatementSyntax as d -> ReturnStatement (ReturnStatementData.FromNode(d))
        | :? ThrowStatementSyntax as d -> ThrowStatement (ThrowStatementData.FromNode(d))
        | :? YieldStatementSyntax as d -> YieldStatement (YieldStatementData.FromNode(d))
        | :? WhileStatementSyntax as d -> WhileStatement (WhileStatementData.FromNode(d))
        | :? DoStatementSyntax as d -> DoStatement (DoStatementData.FromNode(d))
        | :? ForStatementSyntax as d -> ForStatement (ForStatementData.FromNode(d))
        | :? UsingStatementSyntax as d -> UsingStatement (UsingStatementData.FromNode(d))
        | :? FixedStatementSyntax as d -> FixedStatement (FixedStatementData.FromNode(d))
        | :? CheckedStatementSyntax as d -> CheckedStatement (CheckedStatementData.FromNode(d))
        | :? UnsafeStatementSyntax as d -> UnsafeStatement (UnsafeStatementData.FromNode(d))
        | :? LockStatementSyntax as d -> LockStatement (LockStatementData.FromNode(d))
        | :? IfStatementSyntax as d -> IfStatement (IfStatementData.FromNode(d))
        | :? SwitchStatementSyntax as d -> SwitchStatement (SwitchStatementData.FromNode(d))
        | :? TryStatementSyntax as d -> TryStatement (TryStatementData.FromNode(d))
        | _ -> failwithf "Unexpected descendant class of StatementSyntax"
    member this.Node =
        match this with
        | CommonForEachStatement d -> d.Node :> StatementSyntax
        | Block d -> d.Node :> StatementSyntax
        | LocalFunctionStatement d -> d.Node :> StatementSyntax
        | LocalDeclarationStatement d -> d.Node :> StatementSyntax
        | ExpressionStatement d -> d.Node :> StatementSyntax
        | EmptyStatement d -> d.Node :> StatementSyntax
        | LabeledStatement d -> d.Node :> StatementSyntax
        | GotoStatement d -> d.Node :> StatementSyntax
        | BreakStatement d -> d.Node :> StatementSyntax
        | ContinueStatement d -> d.Node :> StatementSyntax
        | ReturnStatement d -> d.Node :> StatementSyntax
        | ThrowStatement d -> d.Node :> StatementSyntax
        | YieldStatement d -> d.Node :> StatementSyntax
        | WhileStatement d -> d.Node :> StatementSyntax
        | DoStatement d -> d.Node :> StatementSyntax
        | ForStatement d -> d.Node :> StatementSyntax
        | UsingStatement d -> d.Node :> StatementSyntax
        | FixedStatement d -> d.Node :> StatementSyntax
        | CheckedStatement d -> d.Node :> StatementSyntax
        | UnsafeStatement d -> d.Node :> StatementSyntax
        | LockStatement d -> d.Node :> StatementSyntax
        | IfStatement d -> d.Node :> StatementSyntax
        | SwitchStatement d -> d.Node :> StatementSyntax
        | TryStatement d -> d.Node :> StatementSyntax

and BlockData(node: BlockSyntax) =
    member this.Node = node
    member this.Statements = node.Statements |> Seq.map StatementData.FromNode
    static member FromNode(n: BlockSyntax) = BlockData(n)

and AnonymousMethodExpressionData(node: AnonymousMethodExpressionSyntax) =
    member this.Node = node
    member this.ParameterList = node.ParameterList |> Option.ofObj |> Option.map ParameterListData.FromNode
    member this.Block = node.Block |> BlockData.FromNode
    member this.ExpressionBody = node.ExpressionBody |> Option.ofObj |> Option.map ExpressionData.FromNode
    static member FromNode(n: AnonymousMethodExpressionSyntax) = AnonymousMethodExpressionData(n)

and [<RequireQualifiedAccess>] AnonymousFunctionExpressionData =
    | LambdaExpression          of LambdaExpressionData
    | AnonymousMethodExpression of AnonymousMethodExpressionData
with
    static member FromNode(n: AnonymousFunctionExpressionSyntax) =
        match n with
        | :? LambdaExpressionSyntax as d -> LambdaExpression (LambdaExpressionData.FromNode(d))
        | :? AnonymousMethodExpressionSyntax as d -> AnonymousMethodExpression (AnonymousMethodExpressionData.FromNode(d))
        | _ -> failwithf "Unexpected descendant class of AnonymousFunctionExpressionSyntax"
    member this.Node =
        match this with
        | LambdaExpression d -> d.Node :> AnonymousFunctionExpressionSyntax
        | AnonymousMethodExpression d -> d.Node :> AnonymousFunctionExpressionSyntax

and ParenthesizedExpressionData(node: ParenthesizedExpressionSyntax) =
    member this.Node = node
    member this.Expression = node.Expression |> ExpressionData.FromNode
    static member FromNode(n: ParenthesizedExpressionSyntax) = ParenthesizedExpressionData(n)

and TupleExpressionData(node: TupleExpressionSyntax) =
    member this.Node = node
    member this.Arguments = node.Arguments |> Seq.map ArgumentData.FromNode
    static member FromNode(n: TupleExpressionSyntax) = TupleExpressionData(n)

and PrefixUnaryExpressionData(node: PrefixUnaryExpressionSyntax) =
    member this.Node = node
    member this.Kind = PrefixUnaryExpressionKind.FromKind(node.Kind())
    member this.OperatorToken = node.OperatorToken |> PrefixUnaryExpressionOperatorToken.FromToken
    member this.Operand = node.Operand |> ExpressionData.FromNode
    static member FromNode(n: PrefixUnaryExpressionSyntax) = PrefixUnaryExpressionData(n)

and AwaitExpressionData(node: AwaitExpressionSyntax) =
    member this.Node = node
    member this.Expression = node.Expression |> ExpressionData.FromNode
    static member FromNode(n: AwaitExpressionSyntax) = AwaitExpressionData(n)

and PostfixUnaryExpressionData(node: PostfixUnaryExpressionSyntax) =
    member this.Node = node
    member this.Kind = PostfixUnaryExpressionKind.FromKind(node.Kind())
    member this.Operand = node.Operand |> ExpressionData.FromNode
    member this.OperatorToken = node.OperatorToken |> PostfixUnaryExpressionOperatorToken.FromToken
    static member FromNode(n: PostfixUnaryExpressionSyntax) = PostfixUnaryExpressionData(n)

and MemberAccessExpressionData(node: MemberAccessExpressionSyntax) =
    member this.Node = node
    member this.Kind = MemberAccessExpressionKind.FromKind(node.Kind())
    member this.Expression = node.Expression |> ExpressionData.FromNode
    member this.OperatorToken = node.OperatorToken |> MemberAccessExpressionOperatorToken.FromToken
    member this.Name = node.Name |> SimpleNameData.FromNode
    static member FromNode(n: MemberAccessExpressionSyntax) = MemberAccessExpressionData(n)

and ConditionalAccessExpressionData(node: ConditionalAccessExpressionSyntax) =
    member this.Node = node
    member this.Expression = node.Expression |> ExpressionData.FromNode
    member this.WhenNotNull = node.WhenNotNull |> ExpressionData.FromNode
    static member FromNode(n: ConditionalAccessExpressionSyntax) = ConditionalAccessExpressionData(n)

and MemberBindingExpressionData(node: MemberBindingExpressionSyntax) =
    member this.Node = node
    member this.Name = node.Name |> SimpleNameData.FromNode
    static member FromNode(n: MemberBindingExpressionSyntax) = MemberBindingExpressionData(n)

and ElementBindingExpressionData(node: ElementBindingExpressionSyntax) =
    member this.Node = node
    member this.ArgumentList = node.ArgumentList |> BracketedArgumentListData.FromNode
    static member FromNode(n: ElementBindingExpressionSyntax) = ElementBindingExpressionData(n)

and RangeExpressionData(node: RangeExpressionSyntax) =
    member this.Node = node
    member this.LeftOperand = node.LeftOperand |> Option.ofObj |> Option.map ExpressionData.FromNode
    member this.RightOperand = node.RightOperand |> Option.ofObj |> Option.map ExpressionData.FromNode
    static member FromNode(n: RangeExpressionSyntax) = RangeExpressionData(n)

and ImplicitElementAccessData(node: ImplicitElementAccessSyntax) =
    member this.Node = node
    member this.ArgumentList = node.ArgumentList |> BracketedArgumentListData.FromNode
    static member FromNode(n: ImplicitElementAccessSyntax) = ImplicitElementAccessData(n)

and BinaryExpressionData(node: BinaryExpressionSyntax) =
    member this.Node = node
    member this.Kind = BinaryExpressionKind.FromKind(node.Kind())
    member this.Left = node.Left |> ExpressionData.FromNode
    member this.OperatorToken = node.OperatorToken |> BinaryExpressionOperatorToken.FromToken
    member this.Right = node.Right |> ExpressionData.FromNode
    static member FromNode(n: BinaryExpressionSyntax) = BinaryExpressionData(n)

and AssignmentExpressionData(node: AssignmentExpressionSyntax) =
    member this.Node = node
    member this.Kind = AssignmentExpressionKind.FromKind(node.Kind())
    member this.Left = node.Left |> ExpressionData.FromNode
    member this.OperatorToken = node.OperatorToken |> AssignmentExpressionOperatorToken.FromToken
    member this.Right = node.Right |> ExpressionData.FromNode
    static member FromNode(n: AssignmentExpressionSyntax) = AssignmentExpressionData(n)

and ConditionalExpressionData(node: ConditionalExpressionSyntax) =
    member this.Node = node
    member this.Condition = node.Condition |> ExpressionData.FromNode
    member this.WhenTrue = node.WhenTrue |> ExpressionData.FromNode
    member this.WhenFalse = node.WhenFalse |> ExpressionData.FromNode
    static member FromNode(n: ConditionalExpressionSyntax) = ConditionalExpressionData(n)

and LiteralExpressionData(node: LiteralExpressionSyntax) =
    member this.Node = node
    member this.Kind = LiteralExpressionKind.FromKind(node.Kind())
    member this.Token = node.Token |> LiteralExpressionToken.FromToken
    static member FromNode(n: LiteralExpressionSyntax) = LiteralExpressionData(n)

and MakeRefExpressionData(node: MakeRefExpressionSyntax) =
    member this.Node = node
    member this.Expression = node.Expression |> ExpressionData.FromNode
    static member FromNode(n: MakeRefExpressionSyntax) = MakeRefExpressionData(n)

and RefTypeExpressionData(node: RefTypeExpressionSyntax) =
    member this.Node = node
    member this.Expression = node.Expression |> ExpressionData.FromNode
    static member FromNode(n: RefTypeExpressionSyntax) = RefTypeExpressionData(n)

and RefValueExpressionData(node: RefValueExpressionSyntax) =
    member this.Node = node
    member this.Expression = node.Expression |> ExpressionData.FromNode
    member this.Type = node.Type |> TypeData.FromNode
    static member FromNode(n: RefValueExpressionSyntax) = RefValueExpressionData(n)

and CheckedExpressionData(node: CheckedExpressionSyntax) =
    member this.Node = node
    member this.Kind = CheckedExpressionKind.FromKind(node.Kind())
    member this.Keyword = node.Keyword |> CheckedExpressionKeyword.FromToken
    member this.Expression = node.Expression |> ExpressionData.FromNode
    static member FromNode(n: CheckedExpressionSyntax) = CheckedExpressionData(n)

and DefaultExpressionData(node: DefaultExpressionSyntax) =
    member this.Node = node
    member this.Type = node.Type |> TypeData.FromNode
    static member FromNode(n: DefaultExpressionSyntax) = DefaultExpressionData(n)

and TypeOfExpressionData(node: TypeOfExpressionSyntax) =
    member this.Node = node
    member this.Type = node.Type |> TypeData.FromNode
    static member FromNode(n: TypeOfExpressionSyntax) = TypeOfExpressionData(n)

and SizeOfExpressionData(node: SizeOfExpressionSyntax) =
    member this.Node = node
    member this.Type = node.Type |> TypeData.FromNode
    static member FromNode(n: SizeOfExpressionSyntax) = SizeOfExpressionData(n)

and ArgumentListData(node: ArgumentListSyntax) =
    member this.Node = node
    member this.Arguments = node.Arguments |> Seq.map ArgumentData.FromNode
    static member FromNode(n: ArgumentListSyntax) = ArgumentListData(n)

and InvocationExpressionData(node: InvocationExpressionSyntax) =
    member this.Node = node
    member this.Expression = node.Expression |> ExpressionData.FromNode
    member this.ArgumentList = node.ArgumentList |> ArgumentListData.FromNode
    static member FromNode(n: InvocationExpressionSyntax) = InvocationExpressionData(n)

and ElementAccessExpressionData(node: ElementAccessExpressionSyntax) =
    member this.Node = node
    member this.Expression = node.Expression |> ExpressionData.FromNode
    member this.ArgumentList = node.ArgumentList |> BracketedArgumentListData.FromNode
    static member FromNode(n: ElementAccessExpressionSyntax) = ElementAccessExpressionData(n)

and DeclarationExpressionData(node: DeclarationExpressionSyntax) =
    member this.Node = node
    member this.Type = node.Type |> TypeData.FromNode
    member this.Designation = node.Designation |> VariableDesignationData.FromNode
    static member FromNode(n: DeclarationExpressionSyntax) = DeclarationExpressionData(n)

and CastExpressionData(node: CastExpressionSyntax) =
    member this.Node = node
    member this.Type = node.Type |> TypeData.FromNode
    member this.Expression = node.Expression |> ExpressionData.FromNode
    static member FromNode(n: CastExpressionSyntax) = CastExpressionData(n)

and RefExpressionData(node: RefExpressionSyntax) =
    member this.Node = node
    member this.Expression = node.Expression |> ExpressionData.FromNode
    static member FromNode(n: RefExpressionSyntax) = RefExpressionData(n)

and InitializerExpressionData(node: InitializerExpressionSyntax) =
    member this.Node = node
    member this.Kind = InitializerExpressionKind.FromKind(node.Kind())
    member this.Expressions = node.Expressions |> Seq.map ExpressionData.FromNode
    static member FromNode(n: InitializerExpressionSyntax) = InitializerExpressionData(n)

and ObjectCreationExpressionData(node: ObjectCreationExpressionSyntax) =
    member this.Node = node
    member this.Type = node.Type |> TypeData.FromNode
    member this.ArgumentList = node.ArgumentList |> Option.ofObj |> Option.map ArgumentListData.FromNode
    member this.Initializer = node.Initializer |> Option.ofObj |> Option.map InitializerExpressionData.FromNode
    static member FromNode(n: ObjectCreationExpressionSyntax) = ObjectCreationExpressionData(n)

and NameEqualsData(node: NameEqualsSyntax) =
    member this.Node = node
    member this.Name = node.Name |> IdentifierNameData.FromNode
    static member FromNode(n: NameEqualsSyntax) = NameEqualsData(n)

and AnonymousObjectMemberDeclaratorData(node: AnonymousObjectMemberDeclaratorSyntax) =
    member this.Node = node
    member this.NameEquals = node.NameEquals |> Option.ofObj |> Option.map NameEqualsData.FromNode
    member this.Expression = node.Expression |> ExpressionData.FromNode
    static member FromNode(n: AnonymousObjectMemberDeclaratorSyntax) = AnonymousObjectMemberDeclaratorData(n)

and AnonymousObjectCreationExpressionData(node: AnonymousObjectCreationExpressionSyntax) =
    member this.Node = node
    member this.Initializers = node.Initializers |> Seq.map AnonymousObjectMemberDeclaratorData.FromNode
    static member FromNode(n: AnonymousObjectCreationExpressionSyntax) = AnonymousObjectCreationExpressionData(n)

and ArrayCreationExpressionData(node: ArrayCreationExpressionSyntax) =
    member this.Node = node
    member this.Type = node.Type |> ArrayTypeData.FromNode
    member this.Initializer = node.Initializer |> Option.ofObj |> Option.map InitializerExpressionData.FromNode
    static member FromNode(n: ArrayCreationExpressionSyntax) = ArrayCreationExpressionData(n)

and ImplicitArrayCreationExpressionData(node: ImplicitArrayCreationExpressionSyntax) =
    member this.Node = node
    member this.Initializer = node.Initializer |> InitializerExpressionData.FromNode
    static member FromNode(n: ImplicitArrayCreationExpressionSyntax) = ImplicitArrayCreationExpressionData(n)

and StackAllocArrayCreationExpressionData(node: StackAllocArrayCreationExpressionSyntax) =
    member this.Node = node
    member this.Type = node.Type |> TypeData.FromNode
    member this.Initializer = node.Initializer |> Option.ofObj |> Option.map InitializerExpressionData.FromNode
    static member FromNode(n: StackAllocArrayCreationExpressionSyntax) = StackAllocArrayCreationExpressionData(n)

and ImplicitStackAllocArrayCreationExpressionData(node: ImplicitStackAllocArrayCreationExpressionSyntax) =
    member this.Node = node
    member this.Initializer = node.Initializer |> InitializerExpressionData.FromNode
    static member FromNode(n: ImplicitStackAllocArrayCreationExpressionSyntax) = ImplicitStackAllocArrayCreationExpressionData(n)

and FromClauseData(node: FromClauseSyntax) =
    member this.Node = node
    member this.Type = node.Type |> Option.ofObj |> Option.map TypeData.FromNode
    member this.Identifier = node.Identifier
    member this.Expression = node.Expression |> ExpressionData.FromNode
    static member FromNode(n: FromClauseSyntax) = FromClauseData(n)

and LetClauseData(node: LetClauseSyntax) =
    member this.Node = node
    member this.Identifier = node.Identifier
    member this.Expression = node.Expression |> ExpressionData.FromNode
    static member FromNode(n: LetClauseSyntax) = LetClauseData(n)

and JoinIntoClauseData(node: JoinIntoClauseSyntax) =
    member this.Node = node
    member this.Identifier = node.Identifier
    static member FromNode(n: JoinIntoClauseSyntax) = JoinIntoClauseData(n)

and JoinClauseData(node: JoinClauseSyntax) =
    member this.Node = node
    member this.Type = node.Type |> Option.ofObj |> Option.map TypeData.FromNode
    member this.Identifier = node.Identifier
    member this.InExpression = node.InExpression |> ExpressionData.FromNode
    member this.LeftExpression = node.LeftExpression |> ExpressionData.FromNode
    member this.RightExpression = node.RightExpression |> ExpressionData.FromNode
    member this.Into = node.Into |> Option.ofObj |> Option.map JoinIntoClauseData.FromNode
    static member FromNode(n: JoinClauseSyntax) = JoinClauseData(n)

and WhereClauseData(node: WhereClauseSyntax) =
    member this.Node = node
    member this.Condition = node.Condition |> ExpressionData.FromNode
    static member FromNode(n: WhereClauseSyntax) = WhereClauseData(n)

and OrderingData(node: OrderingSyntax) =
    member this.Node = node
    member this.Kind = OrderingKind.FromKind(node.Kind())
    member this.Expression = node.Expression |> ExpressionData.FromNode
    member this.AscendingOrDescendingKeyword = node.AscendingOrDescendingKeyword |> optionalToken |> Option.map OrderingAscendingOrDescendingKeyword.FromToken
    static member FromNode(n: OrderingSyntax) = OrderingData(n)

and OrderByClauseData(node: OrderByClauseSyntax) =
    member this.Node = node
    member this.Orderings = node.Orderings |> Seq.map OrderingData.FromNode
    static member FromNode(n: OrderByClauseSyntax) = OrderByClauseData(n)

and [<RequireQualifiedAccess>] QueryClauseData =
    | FromClause    of FromClauseData
    | LetClause     of LetClauseData
    | JoinClause    of JoinClauseData
    | WhereClause   of WhereClauseData
    | OrderByClause of OrderByClauseData
with
    static member FromNode(n: QueryClauseSyntax) =
        match n with
        | :? FromClauseSyntax as d -> FromClause (FromClauseData.FromNode(d))
        | :? LetClauseSyntax as d -> LetClause (LetClauseData.FromNode(d))
        | :? JoinClauseSyntax as d -> JoinClause (JoinClauseData.FromNode(d))
        | :? WhereClauseSyntax as d -> WhereClause (WhereClauseData.FromNode(d))
        | :? OrderByClauseSyntax as d -> OrderByClause (OrderByClauseData.FromNode(d))
        | _ -> failwithf "Unexpected descendant class of QueryClauseSyntax"
    member this.Node =
        match this with
        | FromClause d -> d.Node :> QueryClauseSyntax
        | LetClause d -> d.Node :> QueryClauseSyntax
        | JoinClause d -> d.Node :> QueryClauseSyntax
        | WhereClause d -> d.Node :> QueryClauseSyntax
        | OrderByClause d -> d.Node :> QueryClauseSyntax

and SelectClauseData(node: SelectClauseSyntax) =
    member this.Node = node
    member this.Expression = node.Expression |> ExpressionData.FromNode
    static member FromNode(n: SelectClauseSyntax) = SelectClauseData(n)

and GroupClauseData(node: GroupClauseSyntax) =
    member this.Node = node
    member this.GroupExpression = node.GroupExpression |> ExpressionData.FromNode
    member this.ByExpression = node.ByExpression |> ExpressionData.FromNode
    static member FromNode(n: GroupClauseSyntax) = GroupClauseData(n)

and [<RequireQualifiedAccess>] SelectOrGroupClauseData =
    | SelectClause of SelectClauseData
    | GroupClause  of GroupClauseData
with
    static member FromNode(n: SelectOrGroupClauseSyntax) =
        match n with
        | :? SelectClauseSyntax as d -> SelectClause (SelectClauseData.FromNode(d))
        | :? GroupClauseSyntax as d -> GroupClause (GroupClauseData.FromNode(d))
        | _ -> failwithf "Unexpected descendant class of SelectOrGroupClauseSyntax"
    member this.Node =
        match this with
        | SelectClause d -> d.Node :> SelectOrGroupClauseSyntax
        | GroupClause d -> d.Node :> SelectOrGroupClauseSyntax

and QueryContinuationData(node: QueryContinuationSyntax) =
    member this.Node = node
    member this.Identifier = node.Identifier
    member this.Body = node.Body |> QueryBodyData.FromNode
    static member FromNode(n: QueryContinuationSyntax) = QueryContinuationData(n)

and QueryBodyData(node: QueryBodySyntax) =
    member this.Node = node
    member this.Clauses = node.Clauses |> Seq.map QueryClauseData.FromNode
    member this.SelectOrGroup = node.SelectOrGroup |> SelectOrGroupClauseData.FromNode
    member this.Continuation = node.Continuation |> Option.ofObj |> Option.map QueryContinuationData.FromNode
    static member FromNode(n: QueryBodySyntax) = QueryBodyData(n)

and QueryExpressionData(node: QueryExpressionSyntax) =
    member this.Node = node
    member this.FromClause = node.FromClause |> FromClauseData.FromNode
    member this.Body = node.Body |> QueryBodyData.FromNode
    static member FromNode(n: QueryExpressionSyntax) = QueryExpressionData(n)

and OmittedArraySizeExpressionData(node: OmittedArraySizeExpressionSyntax) =
    member this.Node = node
    static member FromNode(n: OmittedArraySizeExpressionSyntax) = OmittedArraySizeExpressionData(n)

and InterpolatedStringTextData(node: InterpolatedStringTextSyntax) =
    member this.Node = node
    static member FromNode(n: InterpolatedStringTextSyntax) = InterpolatedStringTextData(n)

and InterpolationAlignmentClauseData(node: InterpolationAlignmentClauseSyntax) =
    member this.Node = node
    member this.Value = node.Value |> ExpressionData.FromNode
    static member FromNode(n: InterpolationAlignmentClauseSyntax) = InterpolationAlignmentClauseData(n)

and InterpolationFormatClauseData(node: InterpolationFormatClauseSyntax) =
    member this.Node = node
    static member FromNode(n: InterpolationFormatClauseSyntax) = InterpolationFormatClauseData(n)

and InterpolationData(node: InterpolationSyntax) =
    member this.Node = node
    member this.Expression = node.Expression |> ExpressionData.FromNode
    member this.AlignmentClause = node.AlignmentClause |> Option.ofObj |> Option.map InterpolationAlignmentClauseData.FromNode
    member this.FormatClause = node.FormatClause |> Option.ofObj |> Option.map InterpolationFormatClauseData.FromNode
    static member FromNode(n: InterpolationSyntax) = InterpolationData(n)

and [<RequireQualifiedAccess>] InterpolatedStringContentData =
    | InterpolatedStringText of InterpolatedStringTextData
    | Interpolation          of InterpolationData
with
    static member FromNode(n: InterpolatedStringContentSyntax) =
        match n with
        | :? InterpolatedStringTextSyntax as d -> InterpolatedStringText (InterpolatedStringTextData.FromNode(d))
        | :? InterpolationSyntax as d -> Interpolation (InterpolationData.FromNode(d))
        | _ -> failwithf "Unexpected descendant class of InterpolatedStringContentSyntax"
    member this.Node =
        match this with
        | InterpolatedStringText d -> d.Node :> InterpolatedStringContentSyntax
        | Interpolation d -> d.Node :> InterpolatedStringContentSyntax

and InterpolatedStringExpressionData(node: InterpolatedStringExpressionSyntax) =
    member this.Node = node
    member this.StringStartToken = node.StringStartToken |> InterpolatedStringExpressionStringStartToken.FromToken
    member this.Contents = node.Contents |> Seq.map InterpolatedStringContentData.FromNode
    static member FromNode(n: InterpolatedStringExpressionSyntax) = InterpolatedStringExpressionData(n)

and IsPatternExpressionData(node: IsPatternExpressionSyntax) =
    member this.Node = node
    member this.Expression = node.Expression |> ExpressionData.FromNode
    member this.Pattern = node.Pattern |> PatternData.FromNode
    static member FromNode(n: IsPatternExpressionSyntax) = IsPatternExpressionData(n)

and ThrowExpressionData(node: ThrowExpressionSyntax) =
    member this.Node = node
    member this.Expression = node.Expression |> ExpressionData.FromNode
    static member FromNode(n: ThrowExpressionSyntax) = ThrowExpressionData(n)

and SwitchExpressionArmData(node: SwitchExpressionArmSyntax) =
    member this.Node = node
    member this.Pattern = node.Pattern |> PatternData.FromNode
    member this.WhenClause = node.WhenClause |> Option.ofObj |> Option.map WhenClauseData.FromNode
    member this.Expression = node.Expression |> ExpressionData.FromNode
    static member FromNode(n: SwitchExpressionArmSyntax) = SwitchExpressionArmData(n)

and SwitchExpressionData(node: SwitchExpressionSyntax) =
    member this.Node = node
    member this.GoverningExpression = node.GoverningExpression |> ExpressionData.FromNode
    member this.Arms = node.Arms |> Seq.map SwitchExpressionArmData.FromNode
    static member FromNode(n: SwitchExpressionSyntax) = SwitchExpressionData(n)

and [<RequireQualifiedAccess>] ExpressionData =
    | Type                                      of TypeData
    | InstanceExpression                        of InstanceExpressionData
    | AnonymousFunctionExpression               of AnonymousFunctionExpressionData
    | ParenthesizedExpression                   of ParenthesizedExpressionData
    | TupleExpression                           of TupleExpressionData
    | PrefixUnaryExpression                     of PrefixUnaryExpressionData
    | AwaitExpression                           of AwaitExpressionData
    | PostfixUnaryExpression                    of PostfixUnaryExpressionData
    | MemberAccessExpression                    of MemberAccessExpressionData
    | ConditionalAccessExpression               of ConditionalAccessExpressionData
    | MemberBindingExpression                   of MemberBindingExpressionData
    | ElementBindingExpression                  of ElementBindingExpressionData
    | RangeExpression                           of RangeExpressionData
    | ImplicitElementAccess                     of ImplicitElementAccessData
    | BinaryExpression                          of BinaryExpressionData
    | AssignmentExpression                      of AssignmentExpressionData
    | ConditionalExpression                     of ConditionalExpressionData
    | LiteralExpression                         of LiteralExpressionData
    | MakeRefExpression                         of MakeRefExpressionData
    | RefTypeExpression                         of RefTypeExpressionData
    | RefValueExpression                        of RefValueExpressionData
    | CheckedExpression                         of CheckedExpressionData
    | DefaultExpression                         of DefaultExpressionData
    | TypeOfExpression                          of TypeOfExpressionData
    | SizeOfExpression                          of SizeOfExpressionData
    | InvocationExpression                      of InvocationExpressionData
    | ElementAccessExpression                   of ElementAccessExpressionData
    | DeclarationExpression                     of DeclarationExpressionData
    | CastExpression                            of CastExpressionData
    | RefExpression                             of RefExpressionData
    | InitializerExpression                     of InitializerExpressionData
    | ObjectCreationExpression                  of ObjectCreationExpressionData
    | AnonymousObjectCreationExpression         of AnonymousObjectCreationExpressionData
    | ArrayCreationExpression                   of ArrayCreationExpressionData
    | ImplicitArrayCreationExpression           of ImplicitArrayCreationExpressionData
    | StackAllocArrayCreationExpression         of StackAllocArrayCreationExpressionData
    | ImplicitStackAllocArrayCreationExpression of ImplicitStackAllocArrayCreationExpressionData
    | QueryExpression                           of QueryExpressionData
    | OmittedArraySizeExpression                of OmittedArraySizeExpressionData
    | InterpolatedStringExpression              of InterpolatedStringExpressionData
    | IsPatternExpression                       of IsPatternExpressionData
    | ThrowExpression                           of ThrowExpressionData
    | SwitchExpression                          of SwitchExpressionData
with
    static member FromNode(n: ExpressionSyntax) =
        match n with
        | :? TypeSyntax as d -> Type (TypeData.FromNode(d))
        | :? InstanceExpressionSyntax as d -> InstanceExpression (InstanceExpressionData.FromNode(d))
        | :? AnonymousFunctionExpressionSyntax as d -> AnonymousFunctionExpression (AnonymousFunctionExpressionData.FromNode(d))
        | :? ParenthesizedExpressionSyntax as d -> ParenthesizedExpression (ParenthesizedExpressionData.FromNode(d))
        | :? TupleExpressionSyntax as d -> TupleExpression (TupleExpressionData.FromNode(d))
        | :? PrefixUnaryExpressionSyntax as d -> PrefixUnaryExpression (PrefixUnaryExpressionData.FromNode(d))
        | :? AwaitExpressionSyntax as d -> AwaitExpression (AwaitExpressionData.FromNode(d))
        | :? PostfixUnaryExpressionSyntax as d -> PostfixUnaryExpression (PostfixUnaryExpressionData.FromNode(d))
        | :? MemberAccessExpressionSyntax as d -> MemberAccessExpression (MemberAccessExpressionData.FromNode(d))
        | :? ConditionalAccessExpressionSyntax as d -> ConditionalAccessExpression (ConditionalAccessExpressionData.FromNode(d))
        | :? MemberBindingExpressionSyntax as d -> MemberBindingExpression (MemberBindingExpressionData.FromNode(d))
        | :? ElementBindingExpressionSyntax as d -> ElementBindingExpression (ElementBindingExpressionData.FromNode(d))
        | :? RangeExpressionSyntax as d -> RangeExpression (RangeExpressionData.FromNode(d))
        | :? ImplicitElementAccessSyntax as d -> ImplicitElementAccess (ImplicitElementAccessData.FromNode(d))
        | :? BinaryExpressionSyntax as d -> BinaryExpression (BinaryExpressionData.FromNode(d))
        | :? AssignmentExpressionSyntax as d -> AssignmentExpression (AssignmentExpressionData.FromNode(d))
        | :? ConditionalExpressionSyntax as d -> ConditionalExpression (ConditionalExpressionData.FromNode(d))
        | :? LiteralExpressionSyntax as d -> LiteralExpression (LiteralExpressionData.FromNode(d))
        | :? MakeRefExpressionSyntax as d -> MakeRefExpression (MakeRefExpressionData.FromNode(d))
        | :? RefTypeExpressionSyntax as d -> RefTypeExpression (RefTypeExpressionData.FromNode(d))
        | :? RefValueExpressionSyntax as d -> RefValueExpression (RefValueExpressionData.FromNode(d))
        | :? CheckedExpressionSyntax as d -> CheckedExpression (CheckedExpressionData.FromNode(d))
        | :? DefaultExpressionSyntax as d -> DefaultExpression (DefaultExpressionData.FromNode(d))
        | :? TypeOfExpressionSyntax as d -> TypeOfExpression (TypeOfExpressionData.FromNode(d))
        | :? SizeOfExpressionSyntax as d -> SizeOfExpression (SizeOfExpressionData.FromNode(d))
        | :? InvocationExpressionSyntax as d -> InvocationExpression (InvocationExpressionData.FromNode(d))
        | :? ElementAccessExpressionSyntax as d -> ElementAccessExpression (ElementAccessExpressionData.FromNode(d))
        | :? DeclarationExpressionSyntax as d -> DeclarationExpression (DeclarationExpressionData.FromNode(d))
        | :? CastExpressionSyntax as d -> CastExpression (CastExpressionData.FromNode(d))
        | :? RefExpressionSyntax as d -> RefExpression (RefExpressionData.FromNode(d))
        | :? InitializerExpressionSyntax as d -> InitializerExpression (InitializerExpressionData.FromNode(d))
        | :? ObjectCreationExpressionSyntax as d -> ObjectCreationExpression (ObjectCreationExpressionData.FromNode(d))
        | :? AnonymousObjectCreationExpressionSyntax as d -> AnonymousObjectCreationExpression (AnonymousObjectCreationExpressionData.FromNode(d))
        | :? ArrayCreationExpressionSyntax as d -> ArrayCreationExpression (ArrayCreationExpressionData.FromNode(d))
        | :? ImplicitArrayCreationExpressionSyntax as d -> ImplicitArrayCreationExpression (ImplicitArrayCreationExpressionData.FromNode(d))
        | :? StackAllocArrayCreationExpressionSyntax as d -> StackAllocArrayCreationExpression (StackAllocArrayCreationExpressionData.FromNode(d))
        | :? ImplicitStackAllocArrayCreationExpressionSyntax as d -> ImplicitStackAllocArrayCreationExpression (ImplicitStackAllocArrayCreationExpressionData.FromNode(d))
        | :? QueryExpressionSyntax as d -> QueryExpression (QueryExpressionData.FromNode(d))
        | :? OmittedArraySizeExpressionSyntax as d -> OmittedArraySizeExpression (OmittedArraySizeExpressionData.FromNode(d))
        | :? InterpolatedStringExpressionSyntax as d -> InterpolatedStringExpression (InterpolatedStringExpressionData.FromNode(d))
        | :? IsPatternExpressionSyntax as d -> IsPatternExpression (IsPatternExpressionData.FromNode(d))
        | :? ThrowExpressionSyntax as d -> ThrowExpression (ThrowExpressionData.FromNode(d))
        | :? SwitchExpressionSyntax as d -> SwitchExpression (SwitchExpressionData.FromNode(d))
        | _ -> failwithf "Unexpected descendant class of ExpressionSyntax"
    member this.Node =
        match this with
        | Type d -> d.Node :> ExpressionSyntax
        | InstanceExpression d -> d.Node :> ExpressionSyntax
        | AnonymousFunctionExpression d -> d.Node :> ExpressionSyntax
        | ParenthesizedExpression d -> d.Node :> ExpressionSyntax
        | TupleExpression d -> d.Node :> ExpressionSyntax
        | PrefixUnaryExpression d -> d.Node :> ExpressionSyntax
        | AwaitExpression d -> d.Node :> ExpressionSyntax
        | PostfixUnaryExpression d -> d.Node :> ExpressionSyntax
        | MemberAccessExpression d -> d.Node :> ExpressionSyntax
        | ConditionalAccessExpression d -> d.Node :> ExpressionSyntax
        | MemberBindingExpression d -> d.Node :> ExpressionSyntax
        | ElementBindingExpression d -> d.Node :> ExpressionSyntax
        | RangeExpression d -> d.Node :> ExpressionSyntax
        | ImplicitElementAccess d -> d.Node :> ExpressionSyntax
        | BinaryExpression d -> d.Node :> ExpressionSyntax
        | AssignmentExpression d -> d.Node :> ExpressionSyntax
        | ConditionalExpression d -> d.Node :> ExpressionSyntax
        | LiteralExpression d -> d.Node :> ExpressionSyntax
        | MakeRefExpression d -> d.Node :> ExpressionSyntax
        | RefTypeExpression d -> d.Node :> ExpressionSyntax
        | RefValueExpression d -> d.Node :> ExpressionSyntax
        | CheckedExpression d -> d.Node :> ExpressionSyntax
        | DefaultExpression d -> d.Node :> ExpressionSyntax
        | TypeOfExpression d -> d.Node :> ExpressionSyntax
        | SizeOfExpression d -> d.Node :> ExpressionSyntax
        | InvocationExpression d -> d.Node :> ExpressionSyntax
        | ElementAccessExpression d -> d.Node :> ExpressionSyntax
        | DeclarationExpression d -> d.Node :> ExpressionSyntax
        | CastExpression d -> d.Node :> ExpressionSyntax
        | RefExpression d -> d.Node :> ExpressionSyntax
        | InitializerExpression d -> d.Node :> ExpressionSyntax
        | ObjectCreationExpression d -> d.Node :> ExpressionSyntax
        | AnonymousObjectCreationExpression d -> d.Node :> ExpressionSyntax
        | ArrayCreationExpression d -> d.Node :> ExpressionSyntax
        | ImplicitArrayCreationExpression d -> d.Node :> ExpressionSyntax
        | StackAllocArrayCreationExpression d -> d.Node :> ExpressionSyntax
        | ImplicitStackAllocArrayCreationExpression d -> d.Node :> ExpressionSyntax
        | QueryExpression d -> d.Node :> ExpressionSyntax
        | OmittedArraySizeExpression d -> d.Node :> ExpressionSyntax
        | InterpolatedStringExpression d -> d.Node :> ExpressionSyntax
        | IsPatternExpression d -> d.Node :> ExpressionSyntax
        | ThrowExpression d -> d.Node :> ExpressionSyntax
        | SwitchExpression d -> d.Node :> ExpressionSyntax

and ArrayRankSpecifierData(node: ArrayRankSpecifierSyntax) =
    member this.Node = node
    member this.Sizes = node.Sizes |> Seq.map ExpressionData.FromNode
    static member FromNode(n: ArrayRankSpecifierSyntax) = ArrayRankSpecifierData(n)

and ArrayTypeData(node: ArrayTypeSyntax) =
    member this.Node = node
    member this.ElementType = node.ElementType |> TypeData.FromNode
    member this.RankSpecifiers = node.RankSpecifiers |> Seq.map ArrayRankSpecifierData.FromNode
    static member FromNode(n: ArrayTypeSyntax) = ArrayTypeData(n)

and PointerTypeData(node: PointerTypeSyntax) =
    member this.Node = node
    member this.ElementType = node.ElementType |> TypeData.FromNode
    static member FromNode(n: PointerTypeSyntax) = PointerTypeData(n)

and NullableTypeData(node: NullableTypeSyntax) =
    member this.Node = node
    member this.ElementType = node.ElementType |> TypeData.FromNode
    static member FromNode(n: NullableTypeSyntax) = NullableTypeData(n)

and TupleElementData(node: TupleElementSyntax) =
    member this.Node = node
    member this.Type = node.Type |> TypeData.FromNode
    member this.Identifier = node.Identifier
    static member FromNode(n: TupleElementSyntax) = TupleElementData(n)

and TupleTypeData(node: TupleTypeSyntax) =
    member this.Node = node
    member this.Elements = node.Elements |> Seq.map TupleElementData.FromNode
    static member FromNode(n: TupleTypeSyntax) = TupleTypeData(n)

and OmittedTypeArgumentData(node: OmittedTypeArgumentSyntax) =
    member this.Node = node
    static member FromNode(n: OmittedTypeArgumentSyntax) = OmittedTypeArgumentData(n)

and RefTypeData(node: RefTypeSyntax) =
    member this.Node = node
    member this.Type = node.Type |> TypeData.FromNode
    static member FromNode(n: RefTypeSyntax) = RefTypeData(n)

and [<RequireQualifiedAccess>] TypeData =
    | Name                of NameData
    | PredefinedType      of PredefinedTypeData
    | ArrayType           of ArrayTypeData
    | PointerType         of PointerTypeData
    | NullableType        of NullableTypeData
    | TupleType           of TupleTypeData
    | OmittedTypeArgument of OmittedTypeArgumentData
    | RefType             of RefTypeData
with
    static member FromNode(n: TypeSyntax) =
        match n with
        | :? NameSyntax as d -> Name (NameData.FromNode(d))
        | :? PredefinedTypeSyntax as d -> PredefinedType (PredefinedTypeData.FromNode(d))
        | :? ArrayTypeSyntax as d -> ArrayType (ArrayTypeData.FromNode(d))
        | :? PointerTypeSyntax as d -> PointerType (PointerTypeData.FromNode(d))
        | :? NullableTypeSyntax as d -> NullableType (NullableTypeData.FromNode(d))
        | :? TupleTypeSyntax as d -> TupleType (TupleTypeData.FromNode(d))
        | :? OmittedTypeArgumentSyntax as d -> OmittedTypeArgument (OmittedTypeArgumentData.FromNode(d))
        | :? RefTypeSyntax as d -> RefType (RefTypeData.FromNode(d))
        | _ -> failwithf "Unexpected descendant class of TypeSyntax"
    member this.Node =
        match this with
        | Name d -> d.Node :> TypeSyntax
        | PredefinedType d -> d.Node :> TypeSyntax
        | ArrayType d -> d.Node :> TypeSyntax
        | PointerType d -> d.Node :> TypeSyntax
        | NullableType d -> d.Node :> TypeSyntax
        | TupleType d -> d.Node :> TypeSyntax
        | OmittedTypeArgument d -> d.Node :> TypeSyntax
        | RefType d -> d.Node :> TypeSyntax

and SimpleBaseTypeData(node: SimpleBaseTypeSyntax) =
    member this.Node = node
    member this.Type = node.Type |> TypeData.FromNode
    static member FromNode(n: SimpleBaseTypeSyntax) = SimpleBaseTypeData(n)

and [<RequireQualifiedAccess>] BaseTypeData =
    | SimpleBaseType of SimpleBaseTypeData
with
    static member FromNode(n: BaseTypeSyntax) =
        match n with
        | :? SimpleBaseTypeSyntax as d -> SimpleBaseType (SimpleBaseTypeData.FromNode(d))
        | _ -> failwithf "Unexpected descendant class of BaseTypeSyntax"
    member this.Node =
        match this with
        | SimpleBaseType d -> d.Node :> BaseTypeSyntax

and BaseListData(node: BaseListSyntax) =
    member this.Node = node
    member this.Types = node.Types |> Seq.map BaseTypeData.FromNode
    static member FromNode(n: BaseListSyntax) = BaseListData(n)

and ClassDeclarationData(node: ClassDeclarationSyntax) =
    member this.Node = node
    member this.Identifier = node.Identifier
    member this.TypeParameterList = node.TypeParameterList |> Option.ofObj |> Option.map TypeParameterListData.FromNode
    member this.BaseList = node.BaseList |> Option.ofObj |> Option.map BaseListData.FromNode
    member this.Members = node.Members |> Seq.map MemberDeclarationData.FromNode
    static member FromNode(n: ClassDeclarationSyntax) = ClassDeclarationData(n)

and StructDeclarationData(node: StructDeclarationSyntax) =
    member this.Node = node
    member this.Identifier = node.Identifier
    member this.TypeParameterList = node.TypeParameterList |> Option.ofObj |> Option.map TypeParameterListData.FromNode
    member this.BaseList = node.BaseList |> Option.ofObj |> Option.map BaseListData.FromNode
    member this.Members = node.Members |> Seq.map MemberDeclarationData.FromNode
    static member FromNode(n: StructDeclarationSyntax) = StructDeclarationData(n)

and InterfaceDeclarationData(node: InterfaceDeclarationSyntax) =
    member this.Node = node
    member this.Identifier = node.Identifier
    member this.TypeParameterList = node.TypeParameterList |> Option.ofObj |> Option.map TypeParameterListData.FromNode
    member this.BaseList = node.BaseList |> Option.ofObj |> Option.map BaseListData.FromNode
    member this.Members = node.Members |> Seq.map MemberDeclarationData.FromNode
    static member FromNode(n: InterfaceDeclarationSyntax) = InterfaceDeclarationData(n)

and [<RequireQualifiedAccess>] TypeDeclarationData =
    | ClassDeclaration     of ClassDeclarationData
    | StructDeclaration    of StructDeclarationData
    | InterfaceDeclaration of InterfaceDeclarationData
with
    static member FromNode(n: TypeDeclarationSyntax) =
        match n with
        | :? ClassDeclarationSyntax as d -> ClassDeclaration (ClassDeclarationData.FromNode(d))
        | :? StructDeclarationSyntax as d -> StructDeclaration (StructDeclarationData.FromNode(d))
        | :? InterfaceDeclarationSyntax as d -> InterfaceDeclaration (InterfaceDeclarationData.FromNode(d))
        | _ -> failwithf "Unexpected descendant class of TypeDeclarationSyntax"
    member this.Node =
        match this with
        | ClassDeclaration d -> d.Node :> TypeDeclarationSyntax
        | StructDeclaration d -> d.Node :> TypeDeclarationSyntax
        | InterfaceDeclaration d -> d.Node :> TypeDeclarationSyntax

and EnumMemberDeclarationData(node: EnumMemberDeclarationSyntax) =
    member this.Node = node
    member this.Identifier = node.Identifier
    member this.EqualsValue = node.EqualsValue |> Option.ofObj |> Option.map EqualsValueClauseData.FromNode
    static member FromNode(n: EnumMemberDeclarationSyntax) = EnumMemberDeclarationData(n)

and EnumDeclarationData(node: EnumDeclarationSyntax) =
    member this.Node = node
    member this.Identifier = node.Identifier
    member this.BaseList = node.BaseList |> Option.ofObj |> Option.map BaseListData.FromNode
    member this.Members = node.Members |> Seq.map EnumMemberDeclarationData.FromNode
    static member FromNode(n: EnumDeclarationSyntax) = EnumDeclarationData(n)

and [<RequireQualifiedAccess>] BaseTypeDeclarationData =
    | TypeDeclaration of TypeDeclarationData
    | EnumDeclaration of EnumDeclarationData
with
    static member FromNode(n: BaseTypeDeclarationSyntax) =
        match n with
        | :? TypeDeclarationSyntax as d -> TypeDeclaration (TypeDeclarationData.FromNode(d))
        | :? EnumDeclarationSyntax as d -> EnumDeclaration (EnumDeclarationData.FromNode(d))
        | _ -> failwithf "Unexpected descendant class of BaseTypeDeclarationSyntax"
    member this.Node =
        match this with
        | TypeDeclaration d -> d.Node :> BaseTypeDeclarationSyntax
        | EnumDeclaration d -> d.Node :> BaseTypeDeclarationSyntax

and FieldDeclarationData(node: FieldDeclarationSyntax) =
    member this.Node = node
    member this.Declaration = node.Declaration |> VariableDeclarationData.FromNode
    static member FromNode(n: FieldDeclarationSyntax) = FieldDeclarationData(n)

and EventFieldDeclarationData(node: EventFieldDeclarationSyntax) =
    member this.Node = node
    member this.Declaration = node.Declaration |> VariableDeclarationData.FromNode
    static member FromNode(n: EventFieldDeclarationSyntax) = EventFieldDeclarationData(n)

and [<RequireQualifiedAccess>] BaseFieldDeclarationData =
    | FieldDeclaration      of FieldDeclarationData
    | EventFieldDeclaration of EventFieldDeclarationData
with
    static member FromNode(n: BaseFieldDeclarationSyntax) =
        match n with
        | :? FieldDeclarationSyntax as d -> FieldDeclaration (FieldDeclarationData.FromNode(d))
        | :? EventFieldDeclarationSyntax as d -> EventFieldDeclaration (EventFieldDeclarationData.FromNode(d))
        | _ -> failwithf "Unexpected descendant class of BaseFieldDeclarationSyntax"
    member this.Node =
        match this with
        | FieldDeclaration d -> d.Node :> BaseFieldDeclarationSyntax
        | EventFieldDeclaration d -> d.Node :> BaseFieldDeclarationSyntax

and ExplicitInterfaceSpecifierData(node: ExplicitInterfaceSpecifierSyntax) =
    member this.Node = node
    member this.Name = node.Name |> NameData.FromNode
    static member FromNode(n: ExplicitInterfaceSpecifierSyntax) = ExplicitInterfaceSpecifierData(n)

and MethodDeclarationData(node: MethodDeclarationSyntax) =
    member this.Node = node
    member this.ReturnType = node.ReturnType |> TypeData.FromNode
    member this.ExplicitInterfaceSpecifier = node.ExplicitInterfaceSpecifier |> Option.ofObj |> Option.map ExplicitInterfaceSpecifierData.FromNode
    member this.Identifier = node.Identifier
    member this.TypeParameterList = node.TypeParameterList |> Option.ofObj |> Option.map TypeParameterListData.FromNode
    member this.ParameterList = node.ParameterList |> ParameterListData.FromNode
    static member FromNode(n: MethodDeclarationSyntax) = MethodDeclarationData(n)

and OperatorDeclarationData(node: OperatorDeclarationSyntax) =
    member this.Node = node
    member this.ReturnType = node.ReturnType |> TypeData.FromNode
    member this.OperatorToken = node.OperatorToken |> OperatorDeclarationOperatorToken.FromToken
    member this.ParameterList = node.ParameterList |> ParameterListData.FromNode
    static member FromNode(n: OperatorDeclarationSyntax) = OperatorDeclarationData(n)

and ConversionOperatorDeclarationData(node: ConversionOperatorDeclarationSyntax) =
    member this.Node = node
    member this.ImplicitOrExplicitKeyword = node.ImplicitOrExplicitKeyword |> ConversionOperatorDeclarationImplicitOrExplicitKeyword.FromToken
    member this.Type = node.Type |> TypeData.FromNode
    member this.ParameterList = node.ParameterList |> ParameterListData.FromNode
    static member FromNode(n: ConversionOperatorDeclarationSyntax) = ConversionOperatorDeclarationData(n)

and ConstructorInitializerData(node: ConstructorInitializerSyntax) =
    member this.Node = node
    member this.Kind = ConstructorInitializerKind.FromKind(node.Kind())
    member this.ThisOrBaseKeyword = node.ThisOrBaseKeyword |> ConstructorInitializerThisOrBaseKeyword.FromToken
    member this.ArgumentList = node.ArgumentList |> ArgumentListData.FromNode
    static member FromNode(n: ConstructorInitializerSyntax) = ConstructorInitializerData(n)

and ConstructorDeclarationData(node: ConstructorDeclarationSyntax) =
    member this.Node = node
    member this.Identifier = node.Identifier
    member this.ParameterList = node.ParameterList |> ParameterListData.FromNode
    member this.Initializer = node.Initializer |> Option.ofObj |> Option.map ConstructorInitializerData.FromNode
    static member FromNode(n: ConstructorDeclarationSyntax) = ConstructorDeclarationData(n)

and DestructorDeclarationData(node: DestructorDeclarationSyntax) =
    member this.Node = node
    member this.Identifier = node.Identifier
    member this.ParameterList = node.ParameterList |> ParameterListData.FromNode
    static member FromNode(n: DestructorDeclarationSyntax) = DestructorDeclarationData(n)

and [<RequireQualifiedAccess>] BaseMethodDeclarationData =
    | MethodDeclaration             of MethodDeclarationData
    | OperatorDeclaration           of OperatorDeclarationData
    | ConversionOperatorDeclaration of ConversionOperatorDeclarationData
    | ConstructorDeclaration        of ConstructorDeclarationData
    | DestructorDeclaration         of DestructorDeclarationData
with
    static member FromNode(n: BaseMethodDeclarationSyntax) =
        match n with
        | :? MethodDeclarationSyntax as d -> MethodDeclaration (MethodDeclarationData.FromNode(d))
        | :? OperatorDeclarationSyntax as d -> OperatorDeclaration (OperatorDeclarationData.FromNode(d))
        | :? ConversionOperatorDeclarationSyntax as d -> ConversionOperatorDeclaration (ConversionOperatorDeclarationData.FromNode(d))
        | :? ConstructorDeclarationSyntax as d -> ConstructorDeclaration (ConstructorDeclarationData.FromNode(d))
        | :? DestructorDeclarationSyntax as d -> DestructorDeclaration (DestructorDeclarationData.FromNode(d))
        | _ -> failwithf "Unexpected descendant class of BaseMethodDeclarationSyntax"
    member this.Node =
        match this with
        | MethodDeclaration d -> d.Node :> BaseMethodDeclarationSyntax
        | OperatorDeclaration d -> d.Node :> BaseMethodDeclarationSyntax
        | ConversionOperatorDeclaration d -> d.Node :> BaseMethodDeclarationSyntax
        | ConstructorDeclaration d -> d.Node :> BaseMethodDeclarationSyntax
        | DestructorDeclaration d -> d.Node :> BaseMethodDeclarationSyntax

and PropertyDeclarationData(node: PropertyDeclarationSyntax) =
    member this.Node = node
    member this.Type = node.Type |> TypeData.FromNode
    member this.ExplicitInterfaceSpecifier = node.ExplicitInterfaceSpecifier |> Option.ofObj |> Option.map ExplicitInterfaceSpecifierData.FromNode
    member this.Identifier = node.Identifier
    static member FromNode(n: PropertyDeclarationSyntax) = PropertyDeclarationData(n)

and EventDeclarationData(node: EventDeclarationSyntax) =
    member this.Node = node
    member this.Type = node.Type |> TypeData.FromNode
    member this.ExplicitInterfaceSpecifier = node.ExplicitInterfaceSpecifier |> Option.ofObj |> Option.map ExplicitInterfaceSpecifierData.FromNode
    member this.Identifier = node.Identifier
    static member FromNode(n: EventDeclarationSyntax) = EventDeclarationData(n)

and BracketedParameterListData(node: BracketedParameterListSyntax) =
    member this.Node = node
    member this.Parameters = node.Parameters |> Seq.map ParameterData.FromNode
    static member FromNode(n: BracketedParameterListSyntax) = BracketedParameterListData(n)

and IndexerDeclarationData(node: IndexerDeclarationSyntax) =
    member this.Node = node
    member this.Type = node.Type |> TypeData.FromNode
    member this.ExplicitInterfaceSpecifier = node.ExplicitInterfaceSpecifier |> Option.ofObj |> Option.map ExplicitInterfaceSpecifierData.FromNode
    member this.ParameterList = node.ParameterList |> BracketedParameterListData.FromNode
    static member FromNode(n: IndexerDeclarationSyntax) = IndexerDeclarationData(n)

and [<RequireQualifiedAccess>] BasePropertyDeclarationData =
    | PropertyDeclaration of PropertyDeclarationData
    | EventDeclaration    of EventDeclarationData
    | IndexerDeclaration  of IndexerDeclarationData
with
    static member FromNode(n: BasePropertyDeclarationSyntax) =
        match n with
        | :? PropertyDeclarationSyntax as d -> PropertyDeclaration (PropertyDeclarationData.FromNode(d))
        | :? EventDeclarationSyntax as d -> EventDeclaration (EventDeclarationData.FromNode(d))
        | :? IndexerDeclarationSyntax as d -> IndexerDeclaration (IndexerDeclarationData.FromNode(d))
        | _ -> failwithf "Unexpected descendant class of BasePropertyDeclarationSyntax"
    member this.Node =
        match this with
        | PropertyDeclaration d -> d.Node :> BasePropertyDeclarationSyntax
        | EventDeclaration d -> d.Node :> BasePropertyDeclarationSyntax
        | IndexerDeclaration d -> d.Node :> BasePropertyDeclarationSyntax

and GlobalStatementData(node: GlobalStatementSyntax) =
    member this.Node = node
    member this.Statement = node.Statement |> StatementData.FromNode
    static member FromNode(n: GlobalStatementSyntax) = GlobalStatementData(n)

and NamespaceDeclarationData(node: NamespaceDeclarationSyntax) =
    member this.Node = node
    member this.Name = node.Name |> NameData.FromNode
    member this.Members = node.Members |> Seq.map MemberDeclarationData.FromNode
    static member FromNode(n: NamespaceDeclarationSyntax) = NamespaceDeclarationData(n)

and DelegateDeclarationData(node: DelegateDeclarationSyntax) =
    member this.Node = node
    member this.ReturnType = node.ReturnType |> TypeData.FromNode
    member this.Identifier = node.Identifier
    member this.TypeParameterList = node.TypeParameterList |> Option.ofObj |> Option.map TypeParameterListData.FromNode
    member this.ParameterList = node.ParameterList |> ParameterListData.FromNode
    static member FromNode(n: DelegateDeclarationSyntax) = DelegateDeclarationData(n)

and IncompleteMemberData(node: IncompleteMemberSyntax) =
    member this.Node = node
    member this.Type = node.Type |> Option.ofObj |> Option.map TypeData.FromNode
    static member FromNode(n: IncompleteMemberSyntax) = IncompleteMemberData(n)

and [<RequireQualifiedAccess>] MemberDeclarationData =
    | BaseTypeDeclaration     of BaseTypeDeclarationData
    | BaseFieldDeclaration    of BaseFieldDeclarationData
    | BaseMethodDeclaration   of BaseMethodDeclarationData
    | BasePropertyDeclaration of BasePropertyDeclarationData
    | GlobalStatement         of GlobalStatementData
    | NamespaceDeclaration    of NamespaceDeclarationData
    | DelegateDeclaration     of DelegateDeclarationData
    | EnumMemberDeclaration   of EnumMemberDeclarationData
    | IncompleteMember        of IncompleteMemberData
with
    static member FromNode(n: MemberDeclarationSyntax) =
        match n with
        | :? BaseTypeDeclarationSyntax as d -> BaseTypeDeclaration (BaseTypeDeclarationData.FromNode(d))
        | :? BaseFieldDeclarationSyntax as d -> BaseFieldDeclaration (BaseFieldDeclarationData.FromNode(d))
        | :? BaseMethodDeclarationSyntax as d -> BaseMethodDeclaration (BaseMethodDeclarationData.FromNode(d))
        | :? BasePropertyDeclarationSyntax as d -> BasePropertyDeclaration (BasePropertyDeclarationData.FromNode(d))
        | :? GlobalStatementSyntax as d -> GlobalStatement (GlobalStatementData.FromNode(d))
        | :? NamespaceDeclarationSyntax as d -> NamespaceDeclaration (NamespaceDeclarationData.FromNode(d))
        | :? DelegateDeclarationSyntax as d -> DelegateDeclaration (DelegateDeclarationData.FromNode(d))
        | :? EnumMemberDeclarationSyntax as d -> EnumMemberDeclaration (EnumMemberDeclarationData.FromNode(d))
        | :? IncompleteMemberSyntax as d -> IncompleteMember (IncompleteMemberData.FromNode(d))
        | _ -> failwithf "Unexpected descendant class of MemberDeclarationSyntax"
    member this.Node =
        match this with
        | BaseTypeDeclaration d -> d.Node :> MemberDeclarationSyntax
        | BaseFieldDeclaration d -> d.Node :> MemberDeclarationSyntax
        | BaseMethodDeclaration d -> d.Node :> MemberDeclarationSyntax
        | BasePropertyDeclaration d -> d.Node :> MemberDeclarationSyntax
        | GlobalStatement d -> d.Node :> MemberDeclarationSyntax
        | NamespaceDeclaration d -> d.Node :> MemberDeclarationSyntax
        | DelegateDeclaration d -> d.Node :> MemberDeclarationSyntax
        | EnumMemberDeclaration d -> d.Node :> MemberDeclarationSyntax
        | IncompleteMember d -> d.Node :> MemberDeclarationSyntax

and CompilationUnitData(node: CompilationUnitSyntax) =
    member this.Node = node
    member this.Members = node.Members |> Seq.map MemberDeclarationData.FromNode
    static member FromNode(n: CompilationUnitSyntax) = CompilationUnitData(n)

