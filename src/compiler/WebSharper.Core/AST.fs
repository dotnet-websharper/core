// $begin{copyright}
//
// This file is part of WebSharper
//
// Copyright (c) 2008-2018 IntelliFactory
//
// Licensed under the Apache License, Version 2.0 (the "License"); you
// may not use this file except in compliance with the License.  You may
// obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied.  See the License for the specific language governing
// permissions and limitations under the License.
//
// $end{copyright}

namespace WebSharper.Core.AST

type Literal =
    | Null
    | Bool    of Value:bool
    | Byte    of Value:byte
    | Char    of Value:char
    | Double  of Value:double
    | Int     of Value:int
    | Int16   of Value:int16
    | Int64   of Value:int64
    | SByte   of Value:sbyte
    | Single  of Value:single
    | String  of Value:string
    | UInt16  of Value:uint16
    | UInt32  of Value:uint32
    | UInt64  of Value:uint64
    | Decimal of Value:decimal
    | ByteArray of Value:byte[]
    | UInt16Array of Value:uint16[]
    | JSNumber of Value: string

    static member (!~) a = Value a

    member this.Value =
        match this with
        | Null      -> null
        | Bool    v -> box v
        | Byte    v -> box v
        | Char    v -> box v
        | Double  v -> box v
        | Int     v -> box v
        | Int16   v -> box v
        | Int64   v -> box v
        | SByte   v -> box v
        | Single  v -> box v
        | String  v -> box v
        | UInt16  v -> box v
        | UInt32  v -> box v
        | UInt64  v -> box v
        | Decimal v -> box v
        | ByteArray v -> box v
        | UInt16Array v -> box v

// {{ generated by genAST.fsx, do not modify
and Expression =
    /// JavaScript `undefined` value or `void` in .NET
    | Undefined
    /// The `this` value of current JavaScript function scope
    | This
    /// The `arguments` value of current JavaScript function scope
    | Arguments
    /// Gets the value of a variable
    | Var of Variable:Id
    /// Contains a literal value
    | Value of Value:Literal
    /// Function application with extra information. The `pure` field should be true only when the function called has no side effects, so the side effects of the expression is the same as evaluating `func` then the expressions in the `arguments` list. The `knownLength` field should be `Some x` only when the function is known to have `x` number of arguments and does not use the `this` value.
    | Application of Func:Expression * Arguments:list<Expression> * Pure:Purity * KnownLength:option<int>
    /// Function declaration
    | Function of Parameters:list<Id> * Body:Statement
    /// Variable set
    | VarSet of Variable:Id * Value:Expression
    /// Sequential evaluation of expressions, value is taken from the last
    | Sequential of Expressions:list<Expression>
    /// Creating a new array
    | NewArray of Items:list<Expression>
    /// Conditional operation
    | Conditional of Condition:Expression * WhenTrue:Expression * WhenFalse:Expression
    /// Indexer get without side effects
    | ItemGet of Object:Expression * Item:Expression * Pure:Purity
    /// Indexer set
    | ItemSet of Object:Expression * Item:Expression * Value:Expression
    /// Binary operation
    | Binary of Left:Expression * Operator:BinaryOperator * Right:Expression
    /// Binary operation mutating right side
    | MutatingBinary of Left:Expression * Operator:MutatingBinaryOperator * Right:Expression
    /// Unary operation
    | Unary of Operator:UnaryOperator * Expression:Expression
    /// Unary operation mutating value
    | MutatingUnary of Operator:MutatingUnaryOperator * Expression:Expression
    /// Original source location for an expression
    | ExprSourcePos of Range:SourcePos * Expression:Expression
    /// Temporary - Method of F# object expressions
    | FuncWithThis of ThisParam:Id * Parameters:list<Id> * Body:Statement
    /// Temporary - Refers to the class from a static method
    | Self
    /// Temporary - Refers to the base class from an instance method
    | Base
    /// .NET - Method call
    | Call of ThisObject:option<Expression> * TypeDefinition:Concrete<TypeDefinition> * Method:Concrete<Method> * Arguments:list<Expression>
    /// Temporary - Partial application, workaround for FCS issue #414
    | CallNeedingMoreArgs of ThisObject:option<Expression> * TypeDefinition:Concrete<TypeDefinition> * Method:Concrete<Method> * Arguments:list<Expression>
    /// Temporary - F# function application
    | CurriedApplication of Func:Expression * Arguments:list<Expression>
    /// Temporary - optimized curried or tupled F# function argument
    | OptimizedFSharpArg of FuncVar:Expression * Opt:FuncArgOptimization
    /// .NET - Constructor call
    | Ctor of TypeDefinition:Concrete<TypeDefinition> * Ctor:Constructor * Arguments:list<Expression>
    /// .NET - Base constructor call
    | BaseCtor of ThisObject:Expression * TypeDefinition:Concrete<TypeDefinition> * Ctor:Constructor * Arguments:list<Expression>
    /// .NET - Creating an object from a plain object
    | CopyCtor of TypeDefinition:TypeDefinition * Object:Expression
    /// .NET - Static constructor
    | Cctor of TypeDefinition:TypeDefinition
    /// .NET - Field getter
    | FieldGet of ThisObject:option<Expression> * TypeDefinition:Concrete<TypeDefinition> * Field:string
    /// .NET - Field setter
    | FieldSet of ThisObject:option<Expression> * TypeDefinition:Concrete<TypeDefinition> * Field:string * Value:Expression
    /// .NET - An immutable value definition used only in expression body
    | Let of Identifier:Id * Value:Expression * Body:Expression
    /// .NET - An expression-level variable declaration
    | NewVar of Variable:Id * Value:Expression
    /// .NET - Null-coalescing
    | Coalesce of Expression:Expression * Type:Type * WhenNull:Expression
    /// .NET - Type check, returns bool
    | TypeCheck of Expression:Expression * Type:Type
    /// .NET - Looks up the JavaScript name of an override/implementation, used inside F# object expressions
    | OverrideName of TypeDefinition:TypeDefinition * Method:Method
    /// .NET - Creates a new delegate
    | NewDelegate of ThisObject:option<Expression> * TypeDefinition:Concrete<TypeDefinition> * Method:Concrete<Method>
    /// .NET - Statement inside an expression. Result can be an identifier for a variable which is not explicitly defined inside the statement
    | StatementExpr of Statement:Statement * Result:option<Id>
    /// .NET - F# let rec
    | LetRec of Bindings:list<Id * Expression> * Body:Expression
    /// .NET - F# record constructor
    | NewRecord of TypeDefinition:Concrete<TypeDefinition> * Fields:list<Expression>
    /// .NET - F# union case constructor
    | NewUnionCase of TypeDefinition:Concrete<TypeDefinition> * UnionCase:string * Fields:list<Expression>
    /// .NET - F# union case test
    | UnionCaseTest of Expression:Expression * TypeDefinition:Concrete<TypeDefinition> * UnionCase:string
    /// .NET - F# union case field getter
    | UnionCaseGet of Expression:Expression * TypeDefinition:Concrete<TypeDefinition> * UnionCase:string * Field:string
    /// .NET - F# union case tag getter
    | UnionCaseTag of Expression:Expression * TypeDefinition:Concrete<TypeDefinition>
    /// .NET - F# successful match
    | MatchSuccess of Index:int * Captures:list<Expression>
    /// .NET - Method call
    | TraitCall of ThisObject:option<Expression> * ObjectType:list<Type> * Method:Concrete<Method> * Arguments:list<Expression>
    /// Temporary - C# await expression
    | Await of Expression:Expression
    /// Temporary - C# named parameter
    | NamedParameter of Ordinal:int * Expression:Expression
    /// Temporary - C# ref or out parameter
    | RefOrOutParameter of Expression:Expression
    /// Temporary - C# complex element in initializer expression
    | ComplexElement of Items:list<Expression>
    /// JavaSript object
    | Object of Properties:list<string * Expression>
    /// A global value by path, list is reversed
    | GlobalAccess of Address:Address
    /// JavaScript 'new' call
    | New of Func:Expression * Arguments:list<Expression>
    /// Temporary - A hole in an expression for inlining
    | Hole of Index:int
    with
    static member (^!==) (a, b) = Binary (a, BinaryOperator.``!==``, b)
    static member (^!=) (a, b) = Binary (a, BinaryOperator.``!=``, b)
    static member (^%) (a, b) = Binary (a, BinaryOperator.``%``, b)
    static member (^&&) (a, b) = Binary (a, BinaryOperator.``&&``, b)
    static member (^&) (a, b) = Binary (a, BinaryOperator.``&``, b)
    static member (^*) (a, b) = Binary (a, BinaryOperator.``*``, b)
    static member (^**) (a, b) = Binary (a, BinaryOperator.``**``, b)
    static member (^+) (a, b) = Binary (a, BinaryOperator.``+``, b)
    static member (^-) (a, b) = Binary (a, BinaryOperator.``-``, b)
    static member (^/) (a, b) = Binary (a, BinaryOperator.``/``, b)
    static member (^<<) (a, b) = Binary (a, BinaryOperator.``<<``, b)
    static member (^<=) (a, b) = Binary (a, BinaryOperator.``<=``, b)
    static member (^<) (a, b) = Binary (a, BinaryOperator.``<``, b)
    static member (^===) (a, b) = Binary (a, BinaryOperator.``===``, b)
    static member (^==) (a, b) = Binary (a, BinaryOperator.``==``, b)
    static member (^>=) (a, b) = Binary (a, BinaryOperator.``>=``, b)
    static member (^>>>) (a, b) = Binary (a, BinaryOperator.``>>>``, b)
    static member (^>>) (a, b) = Binary (a, BinaryOperator.``>>``, b)
    static member (^>) (a, b) = Binary (a, BinaryOperator.``>``, b)
    static member (^^) (a, b) = Binary (a, BinaryOperator.``^``, b)
    static member (^|) (a, b) = Binary (a, BinaryOperator.``|``, b)
    static member (^||) (a, b) = Binary (a, BinaryOperator.``||``, b)
    member a.Item b = ItemGet (a, b, NonPure)
    member a.Item b = Application (a, b, NonPure, None)
and Statement =
    /// Empty statement
    | Empty
    /// JavaScript break statement
    | Break of Label:option<Id>
    /// JavaScript continue statement
    | Continue of Label:option<Id>
    /// Expression as statement
    | ExprStatement of Expression:Expression
    /// Return a value
    | Return of Value:Expression
    /// Block of statements
    | Block of Statements:list<Statement>
    /// Variable declaration
    | VarDeclaration of Variable:Id * Value:Expression
    /// Function declaration
    | FuncDeclaration of FuncId:Id * Parameters:list<Id> * Body:Statement
    /// 'while' loop
    | While of Condition:Expression * Body:Statement
    /// 'do..while' loop
    | DoWhile of Body:Statement * Condition:Expression
    /// 'for' loop
    | For of Initializer:option<Expression> * Condition:option<Expression> * Step:option<Expression> * Body:Statement
    /// JavaScript 'for .. in' loop
    | ForIn of Variable:Id * Object:Expression * Body:Statement
    /// JavaScript 'switch' expression
    | Switch of Expression:Expression * Cases:list<option<Expression> * Statement>
    /// 'if' statement
    | If of Condition:Expression * ThenStatement:Statement * ElseStatement:Statement
    /// 'throw' statement
    | Throw of Expression:Expression
    /// 'try..with' statement
    | TryWith of Body:Statement * Variable:option<Id> * CatchStatement:Statement
    /// 'try..finally' statement
    | TryFinally of Body:Statement * FinallyStatement:Statement
    /// Statement with a label
    | Labeled of Label:Id * Statement:Statement
    /// Original source location for a statement
    | StatementSourcePos of Range:SourcePos * Statement:Statement
    /// Temporary - C# 'goto' statement
    | Goto of Label:Id
    /// Temporary - go to next state in state-machine for iterators, async methods, or methods containing gotos
    | Continuation of Label:Id * Expression:Expression
    /// Temporary - C# 'yield return' statement
    | Yield of Value:option<Expression>
    /// Temporary - C# 'switch' statement
    | CSharpSwitch of Expression:Expression * Cases:list<list<option<Expression>> * Statement>
    /// Temporary - C# 'goto case' statement
    | GotoCase of CaseExpression:option<Expression>
    /// .NET - F# tail call position
    | DoNotReturn
/// Base class for code transformers.
/// Provides virtual methods for transforming each AST case separately.
type Transformer() =
    /// JavaScript `undefined` value or `void` in .NET
    abstract TransformUndefined : unit -> Expression
    override this.TransformUndefined () = Undefined 
    /// The `this` value of current JavaScript function scope
    abstract TransformThis : unit -> Expression
    override this.TransformThis () = This 
    /// The `arguments` value of current JavaScript function scope
    abstract TransformArguments : unit -> Expression
    override this.TransformArguments () = Arguments 
    /// Gets the value of a variable
    abstract TransformVar : Variable:Id -> Expression
    override this.TransformVar a = Var (this.TransformId a)
    /// Contains a literal value
    abstract TransformValue : Value:Literal -> Expression
    override this.TransformValue a = Value (a)
    /// Function application with extra information. The `pure` field should be true only when the function called has no side effects, so the side effects of the expression is the same as evaluating `func` then the expressions in the `arguments` list. The `knownLength` field should be `Some x` only when the function is known to have `x` number of arguments and does not use the `this` value.
    abstract TransformApplication : Func:Expression * Arguments:list<Expression> * Pure:Purity * KnownLength:option<int> -> Expression
    override this.TransformApplication (a, b, c, d) = Application (this.TransformExpression a, List.map this.TransformExpression b, c, d)
    /// Function declaration
    abstract TransformFunction : Parameters:list<Id> * Body:Statement -> Expression
    override this.TransformFunction (a, b) = Function (List.map this.TransformId a, this.TransformStatement b)
    /// Variable set
    abstract TransformVarSet : Variable:Id * Value:Expression -> Expression
    override this.TransformVarSet (a, b) = VarSet (this.TransformId a, this.TransformExpression b)
    /// Sequential evaluation of expressions, value is taken from the last
    abstract TransformSequential : Expressions:list<Expression> -> Expression
    override this.TransformSequential a = Sequential (List.map this.TransformExpression a)
    /// Creating a new array
    abstract TransformNewArray : Items:list<Expression> -> Expression
    override this.TransformNewArray a = NewArray (List.map this.TransformExpression a)
    /// Conditional operation
    abstract TransformConditional : Condition:Expression * WhenTrue:Expression * WhenFalse:Expression -> Expression
    override this.TransformConditional (a, b, c) = Conditional (this.TransformExpression a, this.TransformExpression b, this.TransformExpression c)
    /// Indexer get without side effects
    abstract TransformItemGet : Object:Expression * Item:Expression * Pure:Purity -> Expression
    override this.TransformItemGet (a, b, c) = ItemGet (this.TransformExpression a, this.TransformExpression b, c)
    /// Indexer set
    abstract TransformItemSet : Object:Expression * Item:Expression * Value:Expression -> Expression
    override this.TransformItemSet (a, b, c) = ItemSet (this.TransformExpression a, this.TransformExpression b, this.TransformExpression c)
    /// Binary operation
    abstract TransformBinary : Left:Expression * Operator:BinaryOperator * Right:Expression -> Expression
    override this.TransformBinary (a, b, c) = Binary (this.TransformExpression a, b, this.TransformExpression c)
    /// Binary operation mutating right side
    abstract TransformMutatingBinary : Left:Expression * Operator:MutatingBinaryOperator * Right:Expression -> Expression
    override this.TransformMutatingBinary (a, b, c) = MutatingBinary (this.TransformExpression a, b, this.TransformExpression c)
    /// Unary operation
    abstract TransformUnary : Operator:UnaryOperator * Expression:Expression -> Expression
    override this.TransformUnary (a, b) = Unary (a, this.TransformExpression b)
    /// Unary operation mutating value
    abstract TransformMutatingUnary : Operator:MutatingUnaryOperator * Expression:Expression -> Expression
    override this.TransformMutatingUnary (a, b) = MutatingUnary (a, this.TransformExpression b)
    /// Original source location for an expression
    abstract TransformExprSourcePos : Range:SourcePos * Expression:Expression -> Expression
    override this.TransformExprSourcePos (a, b) =
        match this.TransformExpression b with
        | ExprSourcePos (_, bt) | bt -> ExprSourcePos (a, bt)
    /// Temporary - Method of F# object expressions
    abstract TransformFuncWithThis : ThisParam:Id * Parameters:list<Id> * Body:Statement -> Expression
    override this.TransformFuncWithThis (a, b, c) = FuncWithThis (this.TransformId a, List.map this.TransformId b, this.TransformStatement c)
    /// Temporary - Refers to the class from a static method
    abstract TransformSelf : unit -> Expression
    override this.TransformSelf () = Self 
    /// Temporary - Refers to the base class from an instance method
    abstract TransformBase : unit -> Expression
    override this.TransformBase () = Base 
    /// .NET - Method call
    abstract TransformCall : ThisObject:option<Expression> * TypeDefinition:Concrete<TypeDefinition> * Method:Concrete<Method> * Arguments:list<Expression> -> Expression
    override this.TransformCall (a, b, c, d) = Call (Option.map this.TransformExpression a, b, c, List.map this.TransformExpression d)
    /// Temporary - Partial application, workaround for FCS issue #414
    abstract TransformCallNeedingMoreArgs : ThisObject:option<Expression> * TypeDefinition:Concrete<TypeDefinition> * Method:Concrete<Method> * Arguments:list<Expression> -> Expression
    override this.TransformCallNeedingMoreArgs (a, b, c, d) = CallNeedingMoreArgs (Option.map this.TransformExpression a, b, c, List.map this.TransformExpression d)
    /// Temporary - F# function application
    abstract TransformCurriedApplication : Func:Expression * Arguments:list<Expression> -> Expression
    override this.TransformCurriedApplication (a, b) = CurriedApplication (this.TransformExpression a, List.map this.TransformExpression b)
    /// Temporary - optimized curried or tupled F# function argument
    abstract TransformOptimizedFSharpArg : FuncVar:Expression * Opt:FuncArgOptimization -> Expression
    override this.TransformOptimizedFSharpArg (a, b) = OptimizedFSharpArg (this.TransformExpression a, b)
    /// .NET - Constructor call
    abstract TransformCtor : TypeDefinition:Concrete<TypeDefinition> * Ctor:Constructor * Arguments:list<Expression> -> Expression
    override this.TransformCtor (a, b, c) = Ctor (a, b, List.map this.TransformExpression c)
    /// .NET - Base constructor call
    abstract TransformBaseCtor : ThisObject:Expression * TypeDefinition:Concrete<TypeDefinition> * Ctor:Constructor * Arguments:list<Expression> -> Expression
    override this.TransformBaseCtor (a, b, c, d) = BaseCtor (this.TransformExpression a, b, c, List.map this.TransformExpression d)
    /// .NET - Creating an object from a plain object
    abstract TransformCopyCtor : TypeDefinition:TypeDefinition * Object:Expression -> Expression
    override this.TransformCopyCtor (a, b) = CopyCtor (a, this.TransformExpression b)
    /// .NET - Static constructor
    abstract TransformCctor : TypeDefinition:TypeDefinition -> Expression
    override this.TransformCctor a = Cctor (a)
    /// .NET - Field getter
    abstract TransformFieldGet : ThisObject:option<Expression> * TypeDefinition:Concrete<TypeDefinition> * Field:string -> Expression
    override this.TransformFieldGet (a, b, c) = FieldGet (Option.map this.TransformExpression a, b, c)
    /// .NET - Field setter
    abstract TransformFieldSet : ThisObject:option<Expression> * TypeDefinition:Concrete<TypeDefinition> * Field:string * Value:Expression -> Expression
    override this.TransformFieldSet (a, b, c, d) = FieldSet (Option.map this.TransformExpression a, b, c, this.TransformExpression d)
    /// .NET - An immutable value definition used only in expression body
    abstract TransformLet : Identifier:Id * Value:Expression * Body:Expression -> Expression
    override this.TransformLet (a, b, c) = Let (this.TransformId a, this.TransformExpression b, this.TransformExpression c)
    /// .NET - An expression-level variable declaration
    abstract TransformNewVar : Variable:Id * Value:Expression -> Expression
    override this.TransformNewVar (a, b) = NewVar (this.TransformId a, this.TransformExpression b)
    /// .NET - Null-coalescing
    abstract TransformCoalesce : Expression:Expression * Type:Type * WhenNull:Expression -> Expression
    override this.TransformCoalesce (a, b, c) = Coalesce (this.TransformExpression a, b, this.TransformExpression c)
    /// .NET - Type check, returns bool
    abstract TransformTypeCheck : Expression:Expression * Type:Type -> Expression
    override this.TransformTypeCheck (a, b) = TypeCheck (this.TransformExpression a, b)
    /// .NET - Looks up the JavaScript name of an override/implementation, used inside F# object expressions
    abstract TransformOverrideName : TypeDefinition:TypeDefinition * Method:Method -> Expression
    override this.TransformOverrideName (a, b) = OverrideName (a, b)
    /// .NET - Creates a new delegate
    abstract TransformNewDelegate : ThisObject:option<Expression> * TypeDefinition:Concrete<TypeDefinition> * Method:Concrete<Method> -> Expression
    override this.TransformNewDelegate (a, b, c) = NewDelegate (Option.map this.TransformExpression a, b, c)
    /// .NET - Statement inside an expression. Result can be an identifier for a variable which is not explicitly defined inside the statement
    abstract TransformStatementExpr : Statement:Statement * Result:option<Id> -> Expression
    override this.TransformStatementExpr (a, b) = StatementExpr (this.TransformStatement a, Option.map this.TransformId b)
    /// .NET - F# let rec
    abstract TransformLetRec : Bindings:list<Id * Expression> * Body:Expression -> Expression
    override this.TransformLetRec (a, b) = LetRec (List.map (fun (a, b) -> this.TransformId a, this.TransformExpression b) a, this.TransformExpression b)
    /// .NET - F# record constructor
    abstract TransformNewRecord : TypeDefinition:Concrete<TypeDefinition> * Fields:list<Expression> -> Expression
    override this.TransformNewRecord (a, b) = NewRecord (a, List.map this.TransformExpression b)
    /// .NET - F# union case constructor
    abstract TransformNewUnionCase : TypeDefinition:Concrete<TypeDefinition> * UnionCase:string * Fields:list<Expression> -> Expression
    override this.TransformNewUnionCase (a, b, c) = NewUnionCase (a, b, List.map this.TransformExpression c)
    /// .NET - F# union case test
    abstract TransformUnionCaseTest : Expression:Expression * TypeDefinition:Concrete<TypeDefinition> * UnionCase:string -> Expression
    override this.TransformUnionCaseTest (a, b, c) = UnionCaseTest (this.TransformExpression a, b, c)
    /// .NET - F# union case field getter
    abstract TransformUnionCaseGet : Expression:Expression * TypeDefinition:Concrete<TypeDefinition> * UnionCase:string * Field:string -> Expression
    override this.TransformUnionCaseGet (a, b, c, d) = UnionCaseGet (this.TransformExpression a, b, c, d)
    /// .NET - F# union case tag getter
    abstract TransformUnionCaseTag : Expression:Expression * TypeDefinition:Concrete<TypeDefinition> -> Expression
    override this.TransformUnionCaseTag (a, b) = UnionCaseTag (this.TransformExpression a, b)
    /// .NET - F# successful match
    abstract TransformMatchSuccess : Index:int * Captures:list<Expression> -> Expression
    override this.TransformMatchSuccess (a, b) = MatchSuccess (a, List.map this.TransformExpression b)
    /// .NET - Method call
    abstract TransformTraitCall : ThisObject:option<Expression> * ObjectType:list<Type> * Method:Concrete<Method> * Arguments:list<Expression> -> Expression
    override this.TransformTraitCall (a, b, c, d) = TraitCall (Option.map this.TransformExpression a, b, c, List.map this.TransformExpression d)
    /// Temporary - C# await expression
    abstract TransformAwait : Expression:Expression -> Expression
    override this.TransformAwait a = Await (this.TransformExpression a)
    /// Temporary - C# named parameter
    abstract TransformNamedParameter : Ordinal:int * Expression:Expression -> Expression
    override this.TransformNamedParameter (a, b) = NamedParameter (a, this.TransformExpression b)
    /// Temporary - C# ref or out parameter
    abstract TransformRefOrOutParameter : Expression:Expression -> Expression
    override this.TransformRefOrOutParameter a = RefOrOutParameter (this.TransformExpression a)
    /// Temporary - C# complex element in initializer expression
    abstract TransformComplexElement : Items:list<Expression> -> Expression
    override this.TransformComplexElement a = ComplexElement (List.map this.TransformExpression a)
    /// JavaSript object
    abstract TransformObject : Properties:list<string * Expression> -> Expression
    override this.TransformObject a = Object (List.map (fun (a, b) -> a, this.TransformExpression b) a)
    /// A global value by path, list is reversed
    abstract TransformGlobalAccess : Address:Address -> Expression
    override this.TransformGlobalAccess a = GlobalAccess (a)
    /// JavaScript 'new' call
    abstract TransformNew : Func:Expression * Arguments:list<Expression> -> Expression
    override this.TransformNew (a, b) = New (this.TransformExpression a, List.map this.TransformExpression b)
    /// Temporary - A hole in an expression for inlining
    abstract TransformHole : Index:int -> Expression
    override this.TransformHole a = Hole (a)
    /// Empty statement
    abstract TransformEmpty : unit -> Statement
    override this.TransformEmpty () = Empty 
    /// JavaScript break statement
    abstract TransformBreak : Label:option<Id> -> Statement
    override this.TransformBreak a = Break (Option.map this.TransformId a)
    /// JavaScript continue statement
    abstract TransformContinue : Label:option<Id> -> Statement
    override this.TransformContinue a = Continue (Option.map this.TransformId a)
    /// Expression as statement
    abstract TransformExprStatement : Expression:Expression -> Statement
    override this.TransformExprStatement a = ExprStatement (this.TransformExpression a)
    /// Return a value
    abstract TransformReturn : Value:Expression -> Statement
    override this.TransformReturn a = Return (this.TransformExpression a)
    /// Block of statements
    abstract TransformBlock : Statements:list<Statement> -> Statement
    override this.TransformBlock a = Block (List.map this.TransformStatement a)
    /// Variable declaration
    abstract TransformVarDeclaration : Variable:Id * Value:Expression -> Statement
    override this.TransformVarDeclaration (a, b) = VarDeclaration (this.TransformId a, this.TransformExpression b)
    /// Function declaration
    abstract TransformFuncDeclaration : FuncId:Id * Parameters:list<Id> * Body:Statement -> Statement
    override this.TransformFuncDeclaration (a, b, c) = FuncDeclaration (this.TransformId a, List.map this.TransformId b, this.TransformStatement c)
    /// 'while' loop
    abstract TransformWhile : Condition:Expression * Body:Statement -> Statement
    override this.TransformWhile (a, b) = While (this.TransformExpression a, this.TransformStatement b)
    /// 'do..while' loop
    abstract TransformDoWhile : Body:Statement * Condition:Expression -> Statement
    override this.TransformDoWhile (a, b) = DoWhile (this.TransformStatement a, this.TransformExpression b)
    /// 'for' loop
    abstract TransformFor : Initializer:option<Expression> * Condition:option<Expression> * Step:option<Expression> * Body:Statement -> Statement
    override this.TransformFor (a, b, c, d) = For (Option.map this.TransformExpression a, Option.map this.TransformExpression b, Option.map this.TransformExpression c, this.TransformStatement d)
    /// JavaScript 'for .. in' loop
    abstract TransformForIn : Variable:Id * Object:Expression * Body:Statement -> Statement
    override this.TransformForIn (a, b, c) = ForIn (this.TransformId a, this.TransformExpression b, this.TransformStatement c)
    /// JavaScript 'switch' expression
    abstract TransformSwitch : Expression:Expression * Cases:list<option<Expression> * Statement> -> Statement
    override this.TransformSwitch (a, b) = Switch (this.TransformExpression a, List.map (fun (a, b) -> Option.map this.TransformExpression a, this.TransformStatement b) b)
    /// 'if' statement
    abstract TransformIf : Condition:Expression * ThenStatement:Statement * ElseStatement:Statement -> Statement
    override this.TransformIf (a, b, c) = If (this.TransformExpression a, this.TransformStatement b, this.TransformStatement c)
    /// 'throw' statement
    abstract TransformThrow : Expression:Expression -> Statement
    override this.TransformThrow a = Throw (this.TransformExpression a)
    /// 'try..with' statement
    abstract TransformTryWith : Body:Statement * Variable:option<Id> * CatchStatement:Statement -> Statement
    override this.TransformTryWith (a, b, c) = TryWith (this.TransformStatement a, Option.map this.TransformId b, this.TransformStatement c)
    /// 'try..finally' statement
    abstract TransformTryFinally : Body:Statement * FinallyStatement:Statement -> Statement
    override this.TransformTryFinally (a, b) = TryFinally (this.TransformStatement a, this.TransformStatement b)
    /// Statement with a label
    abstract TransformLabeled : Label:Id * Statement:Statement -> Statement
    override this.TransformLabeled (a, b) = Labeled (this.TransformId a, this.TransformStatement b)
    /// Original source location for a statement
    abstract TransformStatementSourcePos : Range:SourcePos * Statement:Statement -> Statement
    override this.TransformStatementSourcePos (a, b) =
        match this.TransformStatement b with
        | StatementSourcePos (_, bt) | bt -> StatementSourcePos (a, bt)
    /// Temporary - C# 'goto' statement
    abstract TransformGoto : Label:Id -> Statement
    override this.TransformGoto a = Goto (this.TransformId a)
    /// Temporary - go to next state in state-machine for iterators, async methods, or methods containing gotos
    abstract TransformContinuation : Label:Id * Expression:Expression -> Statement
    override this.TransformContinuation (a, b) = Continuation (this.TransformId a, this.TransformExpression b)
    /// Temporary - C# 'yield return' statement
    abstract TransformYield : Value:option<Expression> -> Statement
    override this.TransformYield a = Yield (Option.map this.TransformExpression a)
    /// Temporary - C# 'switch' statement
    abstract TransformCSharpSwitch : Expression:Expression * Cases:list<list<option<Expression>> * Statement> -> Statement
    override this.TransformCSharpSwitch (a, b) = CSharpSwitch (this.TransformExpression a, List.map (fun (a, b) -> List.map (Option.map this.TransformExpression) a, this.TransformStatement b) b)
    /// Temporary - C# 'goto case' statement
    abstract TransformGotoCase : CaseExpression:option<Expression> -> Statement
    override this.TransformGotoCase a = GotoCase (Option.map this.TransformExpression a)
    /// .NET - F# tail call position
    abstract TransformDoNotReturn : unit -> Statement
    override this.TransformDoNotReturn () = DoNotReturn 
    abstract TransformExpression : Expression -> Expression
    override this.TransformExpression x =
        match x with
        | Undefined  -> this.TransformUndefined ()
        | This  -> this.TransformThis ()
        | Arguments  -> this.TransformArguments ()
        | Var a -> this.TransformVar a
        | Value a -> this.TransformValue a
        | Application (a, b, c, d) -> this.TransformApplication (a, b, c, d)
        | Function (a, b) -> this.TransformFunction (a, b)
        | VarSet (a, b) -> this.TransformVarSet (a, b)
        | Sequential a -> this.TransformSequential a
        | NewArray a -> this.TransformNewArray a
        | Conditional (a, b, c) -> this.TransformConditional (a, b, c)
        | ItemGet (a, b, c) -> this.TransformItemGet (a, b, c)
        | ItemSet (a, b, c) -> this.TransformItemSet (a, b, c)
        | Binary (a, b, c) -> this.TransformBinary (a, b, c)
        | MutatingBinary (a, b, c) -> this.TransformMutatingBinary (a, b, c)
        | Unary (a, b) -> this.TransformUnary (a, b)
        | MutatingUnary (a, b) -> this.TransformMutatingUnary (a, b)
        | ExprSourcePos (a, b) -> this.TransformExprSourcePos (a, b)
        | FuncWithThis (a, b, c) -> this.TransformFuncWithThis (a, b, c)
        | Self  -> this.TransformSelf ()
        | Base  -> this.TransformBase ()
        | Call (a, b, c, d) -> this.TransformCall (a, b, c, d)
        | CallNeedingMoreArgs (a, b, c, d) -> this.TransformCallNeedingMoreArgs (a, b, c, d)
        | CurriedApplication (a, b) -> this.TransformCurriedApplication (a, b)
        | OptimizedFSharpArg (a, b) -> this.TransformOptimizedFSharpArg (a, b)
        | Ctor (a, b, c) -> this.TransformCtor (a, b, c)
        | BaseCtor (a, b, c, d) -> this.TransformBaseCtor (a, b, c, d)
        | CopyCtor (a, b) -> this.TransformCopyCtor (a, b)
        | Cctor a -> this.TransformCctor a
        | FieldGet (a, b, c) -> this.TransformFieldGet (a, b, c)
        | FieldSet (a, b, c, d) -> this.TransformFieldSet (a, b, c, d)
        | Let (a, b, c) -> this.TransformLet (a, b, c)
        | NewVar (a, b) -> this.TransformNewVar (a, b)
        | Coalesce (a, b, c) -> this.TransformCoalesce (a, b, c)
        | TypeCheck (a, b) -> this.TransformTypeCheck (a, b)
        | OverrideName (a, b) -> this.TransformOverrideName (a, b)
        | NewDelegate (a, b, c) -> this.TransformNewDelegate (a, b, c)
        | StatementExpr (a, b) -> this.TransformStatementExpr (a, b)
        | LetRec (a, b) -> this.TransformLetRec (a, b)
        | NewRecord (a, b) -> this.TransformNewRecord (a, b)
        | NewUnionCase (a, b, c) -> this.TransformNewUnionCase (a, b, c)
        | UnionCaseTest (a, b, c) -> this.TransformUnionCaseTest (a, b, c)
        | UnionCaseGet (a, b, c, d) -> this.TransformUnionCaseGet (a, b, c, d)
        | UnionCaseTag (a, b) -> this.TransformUnionCaseTag (a, b)
        | MatchSuccess (a, b) -> this.TransformMatchSuccess (a, b)
        | TraitCall (a, b, c, d) -> this.TransformTraitCall (a, b, c, d)
        | Await a -> this.TransformAwait a
        | NamedParameter (a, b) -> this.TransformNamedParameter (a, b)
        | RefOrOutParameter a -> this.TransformRefOrOutParameter a
        | ComplexElement a -> this.TransformComplexElement a
        | Object a -> this.TransformObject a
        | GlobalAccess a -> this.TransformGlobalAccess a
        | New (a, b) -> this.TransformNew (a, b)
        | Hole a -> this.TransformHole a
    abstract TransformStatement : Statement -> Statement
    override this.TransformStatement x =
        match x with
        | Empty  -> this.TransformEmpty ()
        | Break a -> this.TransformBreak a
        | Continue a -> this.TransformContinue a
        | ExprStatement a -> this.TransformExprStatement a
        | Return a -> this.TransformReturn a
        | Block a -> this.TransformBlock a
        | VarDeclaration (a, b) -> this.TransformVarDeclaration (a, b)
        | FuncDeclaration (a, b, c) -> this.TransformFuncDeclaration (a, b, c)
        | While (a, b) -> this.TransformWhile (a, b)
        | DoWhile (a, b) -> this.TransformDoWhile (a, b)
        | For (a, b, c, d) -> this.TransformFor (a, b, c, d)
        | ForIn (a, b, c) -> this.TransformForIn (a, b, c)
        | Switch (a, b) -> this.TransformSwitch (a, b)
        | If (a, b, c) -> this.TransformIf (a, b, c)
        | Throw a -> this.TransformThrow a
        | TryWith (a, b, c) -> this.TransformTryWith (a, b, c)
        | TryFinally (a, b) -> this.TransformTryFinally (a, b)
        | Labeled (a, b) -> this.TransformLabeled (a, b)
        | StatementSourcePos (a, b) -> this.TransformStatementSourcePos (a, b)
        | Goto a -> this.TransformGoto a
        | Continuation (a, b) -> this.TransformContinuation (a, b)
        | Yield a -> this.TransformYield a
        | CSharpSwitch (a, b) -> this.TransformCSharpSwitch (a, b)
        | GotoCase a -> this.TransformGotoCase a
        | DoNotReturn  -> this.TransformDoNotReturn ()
    /// Identifier for variable or label
    abstract TransformId : Id -> Id
    override this.TransformId x = x
/// Base class for code visitors.
/// Provides virtual methods for visiting each AST case separately.
type Visitor() =
    /// JavaScript `undefined` value or `void` in .NET
    abstract VisitUndefined : unit -> unit
    override this.VisitUndefined () = ()
    /// The `this` value of current JavaScript function scope
    abstract VisitThis : unit -> unit
    override this.VisitThis () = ()
    /// The `arguments` value of current JavaScript function scope
    abstract VisitArguments : unit -> unit
    override this.VisitArguments () = ()
    /// Gets the value of a variable
    abstract VisitVar : Variable:Id -> unit
    override this.VisitVar a = (this.VisitId a)
    /// Contains a literal value
    abstract VisitValue : Value:Literal -> unit
    override this.VisitValue a = (())
    /// Function application with extra information. The `pure` field should be true only when the function called has no side effects, so the side effects of the expression is the same as evaluating `func` then the expressions in the `arguments` list. The `knownLength` field should be `Some x` only when the function is known to have `x` number of arguments and does not use the `this` value.
    abstract VisitApplication : Func:Expression * Arguments:list<Expression> * Pure:Purity * KnownLength:option<int> -> unit
    override this.VisitApplication (a, b, c, d) = this.VisitExpression a; List.iter this.VisitExpression b; (); ()
    /// Function declaration
    abstract VisitFunction : Parameters:list<Id> * Body:Statement -> unit
    override this.VisitFunction (a, b) = List.iter this.VisitId a; this.VisitStatement b
    /// Variable set
    abstract VisitVarSet : Variable:Id * Value:Expression -> unit
    override this.VisitVarSet (a, b) = this.VisitId a; this.VisitExpression b
    /// Sequential evaluation of expressions, value is taken from the last
    abstract VisitSequential : Expressions:list<Expression> -> unit
    override this.VisitSequential a = (List.iter this.VisitExpression a)
    /// Creating a new array
    abstract VisitNewArray : Items:list<Expression> -> unit
    override this.VisitNewArray a = (List.iter this.VisitExpression a)
    /// Conditional operation
    abstract VisitConditional : Condition:Expression * WhenTrue:Expression * WhenFalse:Expression -> unit
    override this.VisitConditional (a, b, c) = this.VisitExpression a; this.VisitExpression b; this.VisitExpression c
    /// Indexer get without side effects
    abstract VisitItemGet : Object:Expression * Item:Expression * Pure:Purity -> unit
    override this.VisitItemGet (a, b, c) = this.VisitExpression a; this.VisitExpression b; ()
    /// Indexer set
    abstract VisitItemSet : Object:Expression * Item:Expression * Value:Expression -> unit
    override this.VisitItemSet (a, b, c) = this.VisitExpression a; this.VisitExpression b; this.VisitExpression c
    /// Binary operation
    abstract VisitBinary : Left:Expression * Operator:BinaryOperator * Right:Expression -> unit
    override this.VisitBinary (a, b, c) = this.VisitExpression a; (); this.VisitExpression c
    /// Binary operation mutating right side
    abstract VisitMutatingBinary : Left:Expression * Operator:MutatingBinaryOperator * Right:Expression -> unit
    override this.VisitMutatingBinary (a, b, c) = this.VisitExpression a; (); this.VisitExpression c
    /// Unary operation
    abstract VisitUnary : Operator:UnaryOperator * Expression:Expression -> unit
    override this.VisitUnary (a, b) = (); this.VisitExpression b
    /// Unary operation mutating value
    abstract VisitMutatingUnary : Operator:MutatingUnaryOperator * Expression:Expression -> unit
    override this.VisitMutatingUnary (a, b) = (); this.VisitExpression b
    /// Original source location for an expression
    abstract VisitExprSourcePos : Range:SourcePos * Expression:Expression -> unit
    override this.VisitExprSourcePos (a, b) = (); this.VisitExpression b
    /// Temporary - Method of F# object expressions
    abstract VisitFuncWithThis : ThisParam:Id * Parameters:list<Id> * Body:Statement -> unit
    override this.VisitFuncWithThis (a, b, c) = this.VisitId a; List.iter this.VisitId b; this.VisitStatement c
    /// Temporary - Refers to the class from a static method
    abstract VisitSelf : unit -> unit
    override this.VisitSelf () = ()
    /// Temporary - Refers to the base class from an instance method
    abstract VisitBase : unit -> unit
    override this.VisitBase () = ()
    /// .NET - Method call
    abstract VisitCall : ThisObject:option<Expression> * TypeDefinition:Concrete<TypeDefinition> * Method:Concrete<Method> * Arguments:list<Expression> -> unit
    override this.VisitCall (a, b, c, d) = Option.iter this.VisitExpression a; (); (); List.iter this.VisitExpression d
    /// Temporary - Partial application, workaround for FCS issue #414
    abstract VisitCallNeedingMoreArgs : ThisObject:option<Expression> * TypeDefinition:Concrete<TypeDefinition> * Method:Concrete<Method> * Arguments:list<Expression> -> unit
    override this.VisitCallNeedingMoreArgs (a, b, c, d) = Option.iter this.VisitExpression a; (); (); List.iter this.VisitExpression d
    /// Temporary - F# function application
    abstract VisitCurriedApplication : Func:Expression * Arguments:list<Expression> -> unit
    override this.VisitCurriedApplication (a, b) = this.VisitExpression a; List.iter this.VisitExpression b
    /// Temporary - optimized curried or tupled F# function argument
    abstract VisitOptimizedFSharpArg : FuncVar:Expression * Opt:FuncArgOptimization -> unit
    override this.VisitOptimizedFSharpArg (a, b) = this.VisitExpression a; ()
    /// .NET - Constructor call
    abstract VisitCtor : TypeDefinition:Concrete<TypeDefinition> * Ctor:Constructor * Arguments:list<Expression> -> unit
    override this.VisitCtor (a, b, c) = (); (); List.iter this.VisitExpression c
    /// .NET - Base constructor call
    abstract VisitBaseCtor : ThisObject:Expression * TypeDefinition:Concrete<TypeDefinition> * Ctor:Constructor * Arguments:list<Expression> -> unit
    override this.VisitBaseCtor (a, b, c, d) = this.VisitExpression a; (); (); List.iter this.VisitExpression d
    /// .NET - Creating an object from a plain object
    abstract VisitCopyCtor : TypeDefinition:TypeDefinition * Object:Expression -> unit
    override this.VisitCopyCtor (a, b) = (); this.VisitExpression b
    /// .NET - Static constructor
    abstract VisitCctor : TypeDefinition:TypeDefinition -> unit
    override this.VisitCctor a = (())
    /// .NET - Field getter
    abstract VisitFieldGet : ThisObject:option<Expression> * TypeDefinition:Concrete<TypeDefinition> * Field:string -> unit
    override this.VisitFieldGet (a, b, c) = Option.iter this.VisitExpression a; (); ()
    /// .NET - Field setter
    abstract VisitFieldSet : ThisObject:option<Expression> * TypeDefinition:Concrete<TypeDefinition> * Field:string * Value:Expression -> unit
    override this.VisitFieldSet (a, b, c, d) = Option.iter this.VisitExpression a; (); (); this.VisitExpression d
    /// .NET - An immutable value definition used only in expression body
    abstract VisitLet : Identifier:Id * Value:Expression * Body:Expression -> unit
    override this.VisitLet (a, b, c) = this.VisitId a; this.VisitExpression b; this.VisitExpression c
    /// .NET - An expression-level variable declaration
    abstract VisitNewVar : Variable:Id * Value:Expression -> unit
    override this.VisitNewVar (a, b) = this.VisitId a; this.VisitExpression b
    /// .NET - Null-coalescing
    abstract VisitCoalesce : Expression:Expression * Type:Type * WhenNull:Expression -> unit
    override this.VisitCoalesce (a, b, c) = this.VisitExpression a; (); this.VisitExpression c
    /// .NET - Type check, returns bool
    abstract VisitTypeCheck : Expression:Expression * Type:Type -> unit
    override this.VisitTypeCheck (a, b) = this.VisitExpression a; ()
    /// .NET - Looks up the JavaScript name of an override/implementation, used inside F# object expressions
    abstract VisitOverrideName : TypeDefinition:TypeDefinition * Method:Method -> unit
    override this.VisitOverrideName (a, b) = (); ()
    /// .NET - Creates a new delegate
    abstract VisitNewDelegate : ThisObject:option<Expression> * TypeDefinition:Concrete<TypeDefinition> * Method:Concrete<Method> -> unit
    override this.VisitNewDelegate (a, b, c) = Option.iter this.VisitExpression a; (); ()
    /// .NET - Statement inside an expression. Result can be an identifier for a variable which is not explicitly defined inside the statement
    abstract VisitStatementExpr : Statement:Statement * Result:option<Id> -> unit
    override this.VisitStatementExpr (a, b) = this.VisitStatement a; Option.iter this.VisitId b
    /// .NET - F# let rec
    abstract VisitLetRec : Bindings:list<Id * Expression> * Body:Expression -> unit
    override this.VisitLetRec (a, b) = List.iter (fun (a, b) -> this.VisitId a; this.VisitExpression b) a; this.VisitExpression b
    /// .NET - F# record constructor
    abstract VisitNewRecord : TypeDefinition:Concrete<TypeDefinition> * Fields:list<Expression> -> unit
    override this.VisitNewRecord (a, b) = (); List.iter this.VisitExpression b
    /// .NET - F# union case constructor
    abstract VisitNewUnionCase : TypeDefinition:Concrete<TypeDefinition> * UnionCase:string * Fields:list<Expression> -> unit
    override this.VisitNewUnionCase (a, b, c) = (); (); List.iter this.VisitExpression c
    /// .NET - F# union case test
    abstract VisitUnionCaseTest : Expression:Expression * TypeDefinition:Concrete<TypeDefinition> * UnionCase:string -> unit
    override this.VisitUnionCaseTest (a, b, c) = this.VisitExpression a; (); ()
    /// .NET - F# union case field getter
    abstract VisitUnionCaseGet : Expression:Expression * TypeDefinition:Concrete<TypeDefinition> * UnionCase:string * Field:string -> unit
    override this.VisitUnionCaseGet (a, b, c, d) = this.VisitExpression a; (); (); ()
    /// .NET - F# union case tag getter
    abstract VisitUnionCaseTag : Expression:Expression * TypeDefinition:Concrete<TypeDefinition> -> unit
    override this.VisitUnionCaseTag (a, b) = this.VisitExpression a; ()
    /// .NET - F# successful match
    abstract VisitMatchSuccess : Index:int * Captures:list<Expression> -> unit
    override this.VisitMatchSuccess (a, b) = (); List.iter this.VisitExpression b
    /// .NET - Method call
    abstract VisitTraitCall : ThisObject:option<Expression> * ObjectType:list<Type> * Method:Concrete<Method> * Arguments:list<Expression> -> unit
    override this.VisitTraitCall (a, b, c, d) = Option.iter this.VisitExpression a; (); (); List.iter this.VisitExpression d
    /// Temporary - C# await expression
    abstract VisitAwait : Expression:Expression -> unit
    override this.VisitAwait a = (this.VisitExpression a)
    /// Temporary - C# named parameter
    abstract VisitNamedParameter : Ordinal:int * Expression:Expression -> unit
    override this.VisitNamedParameter (a, b) = (); this.VisitExpression b
    /// Temporary - C# ref or out parameter
    abstract VisitRefOrOutParameter : Expression:Expression -> unit
    override this.VisitRefOrOutParameter a = (this.VisitExpression a)
    /// Temporary - C# complex element in initializer expression
    abstract VisitComplexElement : Items:list<Expression> -> unit
    override this.VisitComplexElement a = (List.iter this.VisitExpression a)
    /// JavaSript object
    abstract VisitObject : Properties:list<string * Expression> -> unit
    override this.VisitObject a = (List.iter (fun (a, b) -> this.VisitExpression b) a)
    /// A global value by path, list is reversed
    abstract VisitGlobalAccess : Address:Address -> unit
    override this.VisitGlobalAccess a = (())
    /// JavaScript 'new' call
    abstract VisitNew : Func:Expression * Arguments:list<Expression> -> unit
    override this.VisitNew (a, b) = this.VisitExpression a; List.iter this.VisitExpression b
    /// Temporary - A hole in an expression for inlining
    abstract VisitHole : Index:int -> unit
    override this.VisitHole a = (())
    /// Empty statement
    abstract VisitEmpty : unit -> unit
    override this.VisitEmpty () = ()
    /// JavaScript break statement
    abstract VisitBreak : Label:option<Id> -> unit
    override this.VisitBreak a = (Option.iter this.VisitId a)
    /// JavaScript continue statement
    abstract VisitContinue : Label:option<Id> -> unit
    override this.VisitContinue a = (Option.iter this.VisitId a)
    /// Expression as statement
    abstract VisitExprStatement : Expression:Expression -> unit
    override this.VisitExprStatement a = (this.VisitExpression a)
    /// Return a value
    abstract VisitReturn : Value:Expression -> unit
    override this.VisitReturn a = (this.VisitExpression a)
    /// Block of statements
    abstract VisitBlock : Statements:list<Statement> -> unit
    override this.VisitBlock a = (List.iter this.VisitStatement a)
    /// Variable declaration
    abstract VisitVarDeclaration : Variable:Id * Value:Expression -> unit
    override this.VisitVarDeclaration (a, b) = this.VisitId a; this.VisitExpression b
    /// Function declaration
    abstract VisitFuncDeclaration : FuncId:Id * Parameters:list<Id> * Body:Statement -> unit
    override this.VisitFuncDeclaration (a, b, c) = this.VisitId a; List.iter this.VisitId b; this.VisitStatement c
    /// 'while' loop
    abstract VisitWhile : Condition:Expression * Body:Statement -> unit
    override this.VisitWhile (a, b) = this.VisitExpression a; this.VisitStatement b
    /// 'do..while' loop
    abstract VisitDoWhile : Body:Statement * Condition:Expression -> unit
    override this.VisitDoWhile (a, b) = this.VisitStatement a; this.VisitExpression b
    /// 'for' loop
    abstract VisitFor : Initializer:option<Expression> * Condition:option<Expression> * Step:option<Expression> * Body:Statement -> unit
    override this.VisitFor (a, b, c, d) = Option.iter this.VisitExpression a; Option.iter this.VisitExpression b; Option.iter this.VisitExpression c; this.VisitStatement d
    /// JavaScript 'for .. in' loop
    abstract VisitForIn : Variable:Id * Object:Expression * Body:Statement -> unit
    override this.VisitForIn (a, b, c) = this.VisitId a; this.VisitExpression b; this.VisitStatement c
    /// JavaScript 'switch' expression
    abstract VisitSwitch : Expression:Expression * Cases:list<option<Expression> * Statement> -> unit
    override this.VisitSwitch (a, b) = this.VisitExpression a; List.iter (fun (a, b) -> Option.iter this.VisitExpression a; this.VisitStatement b) b
    /// 'if' statement
    abstract VisitIf : Condition:Expression * ThenStatement:Statement * ElseStatement:Statement -> unit
    override this.VisitIf (a, b, c) = this.VisitExpression a; this.VisitStatement b; this.VisitStatement c
    /// 'throw' statement
    abstract VisitThrow : Expression:Expression -> unit
    override this.VisitThrow a = (this.VisitExpression a)
    /// 'try..with' statement
    abstract VisitTryWith : Body:Statement * Variable:option<Id> * CatchStatement:Statement -> unit
    override this.VisitTryWith (a, b, c) = this.VisitStatement a; Option.iter this.VisitId b; this.VisitStatement c
    /// 'try..finally' statement
    abstract VisitTryFinally : Body:Statement * FinallyStatement:Statement -> unit
    override this.VisitTryFinally (a, b) = this.VisitStatement a; this.VisitStatement b
    /// Statement with a label
    abstract VisitLabeled : Label:Id * Statement:Statement -> unit
    override this.VisitLabeled (a, b) = this.VisitId a; this.VisitStatement b
    /// Original source location for a statement
    abstract VisitStatementSourcePos : Range:SourcePos * Statement:Statement -> unit
    override this.VisitStatementSourcePos (a, b) = (); this.VisitStatement b
    /// Temporary - C# 'goto' statement
    abstract VisitGoto : Label:Id -> unit
    override this.VisitGoto a = (this.VisitId a)
    /// Temporary - go to next state in state-machine for iterators, async methods, or methods containing gotos
    abstract VisitContinuation : Label:Id * Expression:Expression -> unit
    override this.VisitContinuation (a, b) = this.VisitId a; this.VisitExpression b
    /// Temporary - C# 'yield return' statement
    abstract VisitYield : Value:option<Expression> -> unit
    override this.VisitYield a = (Option.iter this.VisitExpression a)
    /// Temporary - C# 'switch' statement
    abstract VisitCSharpSwitch : Expression:Expression * Cases:list<list<option<Expression>> * Statement> -> unit
    override this.VisitCSharpSwitch (a, b) = this.VisitExpression a; List.iter (fun (a, b) -> List.iter (Option.iter this.VisitExpression) a; this.VisitStatement b) b
    /// Temporary - C# 'goto case' statement
    abstract VisitGotoCase : CaseExpression:option<Expression> -> unit
    override this.VisitGotoCase a = (Option.iter this.VisitExpression a)
    /// .NET - F# tail call position
    abstract VisitDoNotReturn : unit -> unit
    override this.VisitDoNotReturn () = ()
    abstract VisitExpression : Expression -> unit
    override this.VisitExpression x =
        match x with
        | Undefined  -> this.VisitUndefined ()
        | This  -> this.VisitThis ()
        | Arguments  -> this.VisitArguments ()
        | Var a -> this.VisitVar a
        | Value a -> this.VisitValue a
        | Application (a, b, c, d) -> this.VisitApplication (a, b, c, d)
        | Function (a, b) -> this.VisitFunction (a, b)
        | VarSet (a, b) -> this.VisitVarSet (a, b)
        | Sequential a -> this.VisitSequential a
        | NewArray a -> this.VisitNewArray a
        | Conditional (a, b, c) -> this.VisitConditional (a, b, c)
        | ItemGet (a, b, c) -> this.VisitItemGet (a, b, c)
        | ItemSet (a, b, c) -> this.VisitItemSet (a, b, c)
        | Binary (a, b, c) -> this.VisitBinary (a, b, c)
        | MutatingBinary (a, b, c) -> this.VisitMutatingBinary (a, b, c)
        | Unary (a, b) -> this.VisitUnary (a, b)
        | MutatingUnary (a, b) -> this.VisitMutatingUnary (a, b)
        | ExprSourcePos (a, b) -> this.VisitExprSourcePos (a, b)
        | FuncWithThis (a, b, c) -> this.VisitFuncWithThis (a, b, c)
        | Self  -> this.VisitSelf ()
        | Base  -> this.VisitBase ()
        | Call (a, b, c, d) -> this.VisitCall (a, b, c, d)
        | CallNeedingMoreArgs (a, b, c, d) -> this.VisitCallNeedingMoreArgs (a, b, c, d)
        | CurriedApplication (a, b) -> this.VisitCurriedApplication (a, b)
        | OptimizedFSharpArg (a, b) -> this.VisitOptimizedFSharpArg (a, b)
        | Ctor (a, b, c) -> this.VisitCtor (a, b, c)
        | BaseCtor (a, b, c, d) -> this.VisitBaseCtor (a, b, c, d)
        | CopyCtor (a, b) -> this.VisitCopyCtor (a, b)
        | Cctor a -> this.VisitCctor a
        | FieldGet (a, b, c) -> this.VisitFieldGet (a, b, c)
        | FieldSet (a, b, c, d) -> this.VisitFieldSet (a, b, c, d)
        | Let (a, b, c) -> this.VisitLet (a, b, c)
        | NewVar (a, b) -> this.VisitNewVar (a, b)
        | Coalesce (a, b, c) -> this.VisitCoalesce (a, b, c)
        | TypeCheck (a, b) -> this.VisitTypeCheck (a, b)
        | OverrideName (a, b) -> this.VisitOverrideName (a, b)
        | NewDelegate (a, b, c) -> this.VisitNewDelegate (a, b, c)
        | StatementExpr (a, b) -> this.VisitStatementExpr (a, b)
        | LetRec (a, b) -> this.VisitLetRec (a, b)
        | NewRecord (a, b) -> this.VisitNewRecord (a, b)
        | NewUnionCase (a, b, c) -> this.VisitNewUnionCase (a, b, c)
        | UnionCaseTest (a, b, c) -> this.VisitUnionCaseTest (a, b, c)
        | UnionCaseGet (a, b, c, d) -> this.VisitUnionCaseGet (a, b, c, d)
        | UnionCaseTag (a, b) -> this.VisitUnionCaseTag (a, b)
        | MatchSuccess (a, b) -> this.VisitMatchSuccess (a, b)
        | TraitCall (a, b, c, d) -> this.VisitTraitCall (a, b, c, d)
        | Await a -> this.VisitAwait a
        | NamedParameter (a, b) -> this.VisitNamedParameter (a, b)
        | RefOrOutParameter a -> this.VisitRefOrOutParameter a
        | ComplexElement a -> this.VisitComplexElement a
        | Object a -> this.VisitObject a
        | GlobalAccess a -> this.VisitGlobalAccess a
        | New (a, b) -> this.VisitNew (a, b)
        | Hole a -> this.VisitHole a
    abstract VisitStatement : Statement -> unit
    override this.VisitStatement x =
        match x with
        | Empty  -> this.VisitEmpty ()
        | Break a -> this.VisitBreak a
        | Continue a -> this.VisitContinue a
        | ExprStatement a -> this.VisitExprStatement a
        | Return a -> this.VisitReturn a
        | Block a -> this.VisitBlock a
        | VarDeclaration (a, b) -> this.VisitVarDeclaration (a, b)
        | FuncDeclaration (a, b, c) -> this.VisitFuncDeclaration (a, b, c)
        | While (a, b) -> this.VisitWhile (a, b)
        | DoWhile (a, b) -> this.VisitDoWhile (a, b)
        | For (a, b, c, d) -> this.VisitFor (a, b, c, d)
        | ForIn (a, b, c) -> this.VisitForIn (a, b, c)
        | Switch (a, b) -> this.VisitSwitch (a, b)
        | If (a, b, c) -> this.VisitIf (a, b, c)
        | Throw a -> this.VisitThrow a
        | TryWith (a, b, c) -> this.VisitTryWith (a, b, c)
        | TryFinally (a, b) -> this.VisitTryFinally (a, b)
        | Labeled (a, b) -> this.VisitLabeled (a, b)
        | StatementSourcePos (a, b) -> this.VisitStatementSourcePos (a, b)
        | Goto a -> this.VisitGoto a
        | Continuation (a, b) -> this.VisitContinuation (a, b)
        | Yield a -> this.VisitYield a
        | CSharpSwitch (a, b) -> this.VisitCSharpSwitch (a, b)
        | GotoCase a -> this.VisitGotoCase a
        | DoNotReturn  -> this.VisitDoNotReturn ()
    /// Identifier for variable or label
    abstract VisitId : Id -> unit
    override this.VisitId x = ()
module IgnoreSourcePos =
    let ignoreExprSourcePos expr =
        match expr with
        | ExprSourcePos (_, e) -> e
        | _ -> expr
    let (|Undefined|_|) x = match ignoreExprSourcePos x with Undefined  -> Some () | _ -> None
    let (|This|_|) x = match ignoreExprSourcePos x with This  -> Some () | _ -> None
    let (|Arguments|_|) x = match ignoreExprSourcePos x with Arguments  -> Some () | _ -> None
    let (|Var|_|) x = match ignoreExprSourcePos x with Var a -> Some a | _ -> None
    let (|Value|_|) x = match ignoreExprSourcePos x with Value a -> Some a | _ -> None
    let (|Application|_|) x = match ignoreExprSourcePos x with Application (a, b, c, d) -> Some (a, b, c, d) | _ -> None
    let (|Function|_|) x = match ignoreExprSourcePos x with Function (a, b) -> Some (a, b) | _ -> None
    let (|VarSet|_|) x = match ignoreExprSourcePos x with VarSet (a, b) -> Some (a, b) | _ -> None
    let (|Sequential|_|) x = match ignoreExprSourcePos x with Sequential a -> Some a | _ -> None
    let (|NewArray|_|) x = match ignoreExprSourcePos x with NewArray a -> Some a | _ -> None
    let (|Conditional|_|) x = match ignoreExprSourcePos x with Conditional (a, b, c) -> Some (a, b, c) | _ -> None
    let (|ItemGet|_|) x = match ignoreExprSourcePos x with ItemGet (a, b, c) -> Some (a, b, c) | _ -> None
    let (|ItemSet|_|) x = match ignoreExprSourcePos x with ItemSet (a, b, c) -> Some (a, b, c) | _ -> None
    let (|Binary|_|) x = match ignoreExprSourcePos x with Binary (a, b, c) -> Some (a, b, c) | _ -> None
    let (|MutatingBinary|_|) x = match ignoreExprSourcePos x with MutatingBinary (a, b, c) -> Some (a, b, c) | _ -> None
    let (|Unary|_|) x = match ignoreExprSourcePos x with Unary (a, b) -> Some (a, b) | _ -> None
    let (|MutatingUnary|_|) x = match ignoreExprSourcePos x with MutatingUnary (a, b) -> Some (a, b) | _ -> None
    let (|ExprSourcePos|_|) x = match ignoreExprSourcePos x with ExprSourcePos (a, b) -> Some (a, b) | _ -> None
    let (|FuncWithThis|_|) x = match ignoreExprSourcePos x with FuncWithThis (a, b, c) -> Some (a, b, c) | _ -> None
    let (|Self|_|) x = match ignoreExprSourcePos x with Self  -> Some () | _ -> None
    let (|Base|_|) x = match ignoreExprSourcePos x with Base  -> Some () | _ -> None
    let (|Call|_|) x = match ignoreExprSourcePos x with Call (a, b, c, d) -> Some (a, b, c, d) | _ -> None
    let (|CallNeedingMoreArgs|_|) x = match ignoreExprSourcePos x with CallNeedingMoreArgs (a, b, c, d) -> Some (a, b, c, d) | _ -> None
    let (|CurriedApplication|_|) x = match ignoreExprSourcePos x with CurriedApplication (a, b) -> Some (a, b) | _ -> None
    let (|OptimizedFSharpArg|_|) x = match ignoreExprSourcePos x with OptimizedFSharpArg (a, b) -> Some (a, b) | _ -> None
    let (|Ctor|_|) x = match ignoreExprSourcePos x with Ctor (a, b, c) -> Some (a, b, c) | _ -> None
    let (|BaseCtor|_|) x = match ignoreExprSourcePos x with BaseCtor (a, b, c, d) -> Some (a, b, c, d) | _ -> None
    let (|CopyCtor|_|) x = match ignoreExprSourcePos x with CopyCtor (a, b) -> Some (a, b) | _ -> None
    let (|Cctor|_|) x = match ignoreExprSourcePos x with Cctor a -> Some a | _ -> None
    let (|FieldGet|_|) x = match ignoreExprSourcePos x with FieldGet (a, b, c) -> Some (a, b, c) | _ -> None
    let (|FieldSet|_|) x = match ignoreExprSourcePos x with FieldSet (a, b, c, d) -> Some (a, b, c, d) | _ -> None
    let (|Let|_|) x = match ignoreExprSourcePos x with Let (a, b, c) -> Some (a, b, c) | _ -> None
    let (|NewVar|_|) x = match ignoreExprSourcePos x with NewVar (a, b) -> Some (a, b) | _ -> None
    let (|Coalesce|_|) x = match ignoreExprSourcePos x with Coalesce (a, b, c) -> Some (a, b, c) | _ -> None
    let (|TypeCheck|_|) x = match ignoreExprSourcePos x with TypeCheck (a, b) -> Some (a, b) | _ -> None
    let (|OverrideName|_|) x = match ignoreExprSourcePos x with OverrideName (a, b) -> Some (a, b) | _ -> None
    let (|NewDelegate|_|) x = match ignoreExprSourcePos x with NewDelegate (a, b, c) -> Some (a, b, c) | _ -> None
    let (|StatementExpr|_|) x = match ignoreExprSourcePos x with StatementExpr (a, b) -> Some (a, b) | _ -> None
    let (|LetRec|_|) x = match ignoreExprSourcePos x with LetRec (a, b) -> Some (a, b) | _ -> None
    let (|NewRecord|_|) x = match ignoreExprSourcePos x with NewRecord (a, b) -> Some (a, b) | _ -> None
    let (|NewUnionCase|_|) x = match ignoreExprSourcePos x with NewUnionCase (a, b, c) -> Some (a, b, c) | _ -> None
    let (|UnionCaseTest|_|) x = match ignoreExprSourcePos x with UnionCaseTest (a, b, c) -> Some (a, b, c) | _ -> None
    let (|UnionCaseGet|_|) x = match ignoreExprSourcePos x with UnionCaseGet (a, b, c, d) -> Some (a, b, c, d) | _ -> None
    let (|UnionCaseTag|_|) x = match ignoreExprSourcePos x with UnionCaseTag (a, b) -> Some (a, b) | _ -> None
    let (|MatchSuccess|_|) x = match ignoreExprSourcePos x with MatchSuccess (a, b) -> Some (a, b) | _ -> None
    let (|TraitCall|_|) x = match ignoreExprSourcePos x with TraitCall (a, b, c, d) -> Some (a, b, c, d) | _ -> None
    let (|Await|_|) x = match ignoreExprSourcePos x with Await a -> Some a | _ -> None
    let (|NamedParameter|_|) x = match ignoreExprSourcePos x with NamedParameter (a, b) -> Some (a, b) | _ -> None
    let (|RefOrOutParameter|_|) x = match ignoreExprSourcePos x with RefOrOutParameter a -> Some a | _ -> None
    let (|ComplexElement|_|) x = match ignoreExprSourcePos x with ComplexElement a -> Some a | _ -> None
    let (|Object|_|) x = match ignoreExprSourcePos x with Object a -> Some a | _ -> None
    let (|GlobalAccess|_|) x = match ignoreExprSourcePos x with GlobalAccess a -> Some a | _ -> None
    let (|New|_|) x = match ignoreExprSourcePos x with New (a, b) -> Some (a, b) | _ -> None
    let (|Hole|_|) x = match ignoreExprSourcePos x with Hole a -> Some a | _ -> None
    let ignoreStatementSourcePos expr =
        match expr with
        | StatementSourcePos (_, e) -> e
        | _ -> expr
    let (|Empty|_|) x = match ignoreStatementSourcePos x with Empty  -> Some () | _ -> None
    let (|Break|_|) x = match ignoreStatementSourcePos x with Break a -> Some a | _ -> None
    let (|Continue|_|) x = match ignoreStatementSourcePos x with Continue a -> Some a | _ -> None
    let (|ExprStatement|_|) x = match ignoreStatementSourcePos x with ExprStatement a -> Some a | _ -> None
    let (|Return|_|) x = match ignoreStatementSourcePos x with Return a -> Some a | _ -> None
    let (|Block|_|) x = match ignoreStatementSourcePos x with Block a -> Some a | _ -> None
    let (|VarDeclaration|_|) x = match ignoreStatementSourcePos x with VarDeclaration (a, b) -> Some (a, b) | _ -> None
    let (|FuncDeclaration|_|) x = match ignoreStatementSourcePos x with FuncDeclaration (a, b, c) -> Some (a, b, c) | _ -> None
    let (|While|_|) x = match ignoreStatementSourcePos x with While (a, b) -> Some (a, b) | _ -> None
    let (|DoWhile|_|) x = match ignoreStatementSourcePos x with DoWhile (a, b) -> Some (a, b) | _ -> None
    let (|For|_|) x = match ignoreStatementSourcePos x with For (a, b, c, d) -> Some (a, b, c, d) | _ -> None
    let (|ForIn|_|) x = match ignoreStatementSourcePos x with ForIn (a, b, c) -> Some (a, b, c) | _ -> None
    let (|Switch|_|) x = match ignoreStatementSourcePos x with Switch (a, b) -> Some (a, b) | _ -> None
    let (|If|_|) x = match ignoreStatementSourcePos x with If (a, b, c) -> Some (a, b, c) | _ -> None
    let (|Throw|_|) x = match ignoreStatementSourcePos x with Throw a -> Some a | _ -> None
    let (|TryWith|_|) x = match ignoreStatementSourcePos x with TryWith (a, b, c) -> Some (a, b, c) | _ -> None
    let (|TryFinally|_|) x = match ignoreStatementSourcePos x with TryFinally (a, b) -> Some (a, b) | _ -> None
    let (|Labeled|_|) x = match ignoreStatementSourcePos x with Labeled (a, b) -> Some (a, b) | _ -> None
    let (|StatementSourcePos|_|) x = match ignoreStatementSourcePos x with StatementSourcePos (a, b) -> Some (a, b) | _ -> None
    let (|Goto|_|) x = match ignoreStatementSourcePos x with Goto a -> Some a | _ -> None
    let (|Continuation|_|) x = match ignoreStatementSourcePos x with Continuation (a, b) -> Some (a, b) | _ -> None
    let (|Yield|_|) x = match ignoreStatementSourcePos x with Yield a -> Some a | _ -> None
    let (|CSharpSwitch|_|) x = match ignoreStatementSourcePos x with CSharpSwitch (a, b) -> Some (a, b) | _ -> None
    let (|GotoCase|_|) x = match ignoreStatementSourcePos x with GotoCase a -> Some a | _ -> None
    let (|DoNotReturn|_|) x = match ignoreStatementSourcePos x with DoNotReturn  -> Some () | _ -> None
module Debug =
    let private PrintObject x = sprintf "%A" x
    let rec PrintExpression x =
        match x with
        | Undefined  -> "Undefined" + ""
        | This  -> "This" + ""
        | Arguments  -> "Arguments" + ""
        | Var a -> "Var" + "(" + string a + ")"
        | Value a -> "Value" + "(" + PrintObject a.Value + ")"
        | Application (a, b, c, d) -> "Application" + "(" + PrintExpression a + ", " + "[" + String.concat "; " (List.map PrintExpression b) + "]" + ", " + PrintObject c + ", " + defaultArg (Option.map PrintObject d) "_" + ")"
        | Function (a, b) -> "Function" + "(" + "[" + String.concat "; " (List.map string a) + "]" + ", " + PrintStatement b + ")"
        | VarSet (a, b) -> "VarSet" + "(" + string a + ", " + PrintExpression b + ")"
        | Sequential a -> "Sequential" + "(" + "[" + String.concat "; " (List.map PrintExpression a) + "]" + ")"
        | NewArray a -> "NewArray" + "(" + "[" + String.concat "; " (List.map PrintExpression a) + "]" + ")"
        | Conditional (a, b, c) -> "Conditional" + "(" + PrintExpression a + ", " + PrintExpression b + ", " + PrintExpression c + ")"
        | ItemGet (a, b, c) -> "ItemGet" + "(" + PrintExpression a + ", " + PrintExpression b + ", " + PrintObject c + ")"
        | ItemSet (a, b, c) -> "ItemSet" + "(" + PrintExpression a + ", " + PrintExpression b + ", " + PrintExpression c + ")"
        | Binary (a, b, c) -> "Binary" + "(" + PrintExpression a + ", " + PrintObject b + ", " + PrintExpression c + ")"
        | MutatingBinary (a, b, c) -> "MutatingBinary" + "(" + PrintExpression a + ", " + PrintObject b + ", " + PrintExpression c + ")"
        | Unary (a, b) -> "Unary" + "(" + PrintObject a + ", " + PrintExpression b + ")"
        | MutatingUnary (a, b) -> "MutatingUnary" + "(" + PrintObject a + ", " + PrintExpression b + ")"
        | ExprSourcePos (_, b) -> PrintExpression b
        | FuncWithThis (a, b, c) -> "FuncWithThis" + "(" + string a + ", " + "[" + String.concat "; " (List.map string b) + "]" + ", " + PrintStatement c + ")"
        | Self  -> "Self" + ""
        | Base  -> "Base" + ""
        | Call (a, b, c, d) -> "Call" + "(" + defaultArg (Option.map PrintExpression a) "_" + ", " + b.Entity.Value.FullName + PrintGenerics b.Generics + ", " + c.Entity.Value.MethodName + PrintGenerics c.Generics + ", " + "[" + String.concat "; " (List.map PrintExpression d) + "]" + ")"
        | CallNeedingMoreArgs (a, b, c, d) -> "CallNeedingMoreArgs" + "(" + defaultArg (Option.map PrintExpression a) "_" + ", " + b.Entity.Value.FullName + PrintGenerics b.Generics + ", " + c.Entity.Value.MethodName + PrintGenerics c.Generics + ", " + "[" + String.concat "; " (List.map PrintExpression d) + "]" + ")"
        | CurriedApplication (a, b) -> "CurriedApplication" + "(" + PrintExpression a + ", " + "[" + String.concat "; " (List.map PrintExpression b) + "]" + ")"
        | OptimizedFSharpArg (a, b) -> "OptimizedFSharpArg" + "(" + PrintExpression a + ", " + PrintObject b + ")"
        | Ctor (a, b, c) -> "Ctor" + "(" + a.Entity.Value.FullName + PrintGenerics a.Generics + ", " + ".ctor" + ", " + "[" + String.concat "; " (List.map PrintExpression c) + "]" + ")"
        | BaseCtor (a, b, c, d) -> "BaseCtor" + "(" + PrintExpression a + ", " + b.Entity.Value.FullName + PrintGenerics b.Generics + ", " + ".ctor" + ", " + "[" + String.concat "; " (List.map PrintExpression d) + "]" + ")"
        | CopyCtor (a, b) -> "CopyCtor" + "(" + a.Value.FullName + ", " + PrintExpression b + ")"
        | Cctor a -> "Cctor" + "(" + a.Value.FullName + ")"
        | FieldGet (a, b, c) -> "FieldGet" + "(" + defaultArg (Option.map PrintExpression a) "_" + ", " + b.Entity.Value.FullName + PrintGenerics b.Generics + ", " + PrintObject c + ")"
        | FieldSet (a, b, c, d) -> "FieldSet" + "(" + defaultArg (Option.map PrintExpression a) "_" + ", " + b.Entity.Value.FullName + PrintGenerics b.Generics + ", " + PrintObject c + ", " + PrintExpression d + ")"
        | Let (a, b, c) -> "Let" + "(" + string a + ", " + PrintExpression b + ", " + PrintExpression c + ")"
        | NewVar (a, b) -> "NewVar" + "(" + string a + ", " + PrintExpression b + ")"
        | Coalesce (a, b, c) -> "Coalesce" + "(" + PrintExpression a + ", " + PrintObject b + ", " + PrintExpression c + ")"
        | TypeCheck (a, b) -> "TypeCheck" + "(" + PrintExpression a + ", " + PrintObject b + ")"
        | OverrideName (a, b) -> "OverrideName" + "(" + a.Value.FullName + ", " + PrintObject b + ")"
        | NewDelegate (a, b, c) -> "NewDelegate" + "(" + defaultArg (Option.map PrintExpression a) "_" + ", " + b.Entity.Value.FullName + PrintGenerics b.Generics + ", " + c.Entity.Value.MethodName + PrintGenerics c.Generics + ")"
        | StatementExpr (a, b) -> "StatementExpr" + "(" + PrintStatement a + ", " + defaultArg (Option.map string b) "_" + ")"
        | LetRec (a, b) -> "LetRec" + "(" + "[" + String.concat "; " (List.map (fun (a, b) -> string a + ", " + PrintExpression b) a) + "]" + ", " + PrintExpression b + ")"
        | NewRecord (a, b) -> "NewRecord" + "(" + a.Entity.Value.FullName + PrintGenerics a.Generics + ", " + "[" + String.concat "; " (List.map PrintExpression b) + "]" + ")"
        | NewUnionCase (a, b, c) -> "NewUnionCase" + "(" + a.Entity.Value.FullName + PrintGenerics a.Generics + ", " + PrintObject b + ", " + "[" + String.concat "; " (List.map PrintExpression c) + "]" + ")"
        | UnionCaseTest (a, b, c) -> "UnionCaseTest" + "(" + PrintExpression a + ", " + b.Entity.Value.FullName + PrintGenerics b.Generics + ", " + PrintObject c + ")"
        | UnionCaseGet (a, b, c, d) -> "UnionCaseGet" + "(" + PrintExpression a + ", " + b.Entity.Value.FullName + PrintGenerics b.Generics + ", " + PrintObject c + ", " + PrintObject d + ")"
        | UnionCaseTag (a, b) -> "UnionCaseTag" + "(" + PrintExpression a + ", " + b.Entity.Value.FullName + PrintGenerics b.Generics + ")"
        | MatchSuccess (a, b) -> "MatchSuccess" + "(" + PrintObject a + ", " + "[" + String.concat "; " (List.map PrintExpression b) + "]" + ")"
        | TraitCall (a, b, c, d) -> "TraitCall" + "(" + defaultArg (Option.map PrintExpression a) "_" + ", " + "[" + String.concat "; " (List.map PrintObject b) + "]" + ", " + c.Entity.Value.MethodName + PrintGenerics c.Generics + PrintTraitCallParams c.Entity.Value + ", " + "[" + String.concat "; " (List.map PrintExpression d) + "]" + ")"
        | Await a -> "Await" + "(" + PrintExpression a + ")"
        | NamedParameter (a, b) -> "NamedParameter" + "(" + PrintObject a + ", " + PrintExpression b + ")"
        | RefOrOutParameter a -> "RefOrOutParameter" + "(" + PrintExpression a + ")"
        | ComplexElement a -> "ComplexElement" + "(" + "[" + String.concat "; " (List.map PrintExpression a) + "]" + ")"
        | Object a -> "Object" + "(" + "[" + String.concat "; " (List.map (fun (a, b) -> PrintObject a + ", " + PrintExpression b) a) + "]" + ")"
        | GlobalAccess a -> "GlobalAccess" + "(" + PrintObject a + ")"
        | New (a, b) -> "New" + "(" + PrintExpression a + ", " + "[" + String.concat "; " (List.map PrintExpression b) + "]" + ")"
        | Hole a -> "Hole" + "(" + PrintObject a + ")"
    and PrintStatement x =
        match x with
        | Empty  -> "Empty" + ""
        | Break a -> "Break" + "(" + defaultArg (Option.map string a) "_" + ")"
        | Continue a -> "Continue" + "(" + defaultArg (Option.map string a) "_" + ")"
        | ExprStatement a -> "ExprStatement" + "(" + PrintExpression a + ")"
        | Return a -> "Return" + "(" + PrintExpression a + ")"
        | Block a -> "Block" + "(" + "[" + String.concat "; " (List.map PrintStatement a) + "]" + ")"
        | VarDeclaration (a, b) -> "VarDeclaration" + "(" + string a + ", " + PrintExpression b + ")"
        | FuncDeclaration (a, b, c) -> "FuncDeclaration" + "(" + string a + ", " + "[" + String.concat "; " (List.map string b) + "]" + ", " + PrintStatement c + ")"
        | While (a, b) -> "While" + "(" + PrintExpression a + ", " + PrintStatement b + ")"
        | DoWhile (a, b) -> "DoWhile" + "(" + PrintStatement a + ", " + PrintExpression b + ")"
        | For (a, b, c, d) -> "For" + "(" + defaultArg (Option.map PrintExpression a) "_" + ", " + defaultArg (Option.map PrintExpression b) "_" + ", " + defaultArg (Option.map PrintExpression c) "_" + ", " + PrintStatement d + ")"
        | ForIn (a, b, c) -> "ForIn" + "(" + string a + ", " + PrintExpression b + ", " + PrintStatement c + ")"
        | Switch (a, b) -> "Switch" + "(" + PrintExpression a + ", " + "[" + String.concat "; " (List.map (fun (a, b) -> defaultArg (Option.map PrintExpression a) "_" + ", " + PrintStatement b) b) + "]" + ")"
        | If (a, b, c) -> "If" + "(" + PrintExpression a + ", " + PrintStatement b + ", " + PrintStatement c + ")"
        | Throw a -> "Throw" + "(" + PrintExpression a + ")"
        | TryWith (a, b, c) -> "TryWith" + "(" + PrintStatement a + ", " + defaultArg (Option.map string b) "_" + ", " + PrintStatement c + ")"
        | TryFinally (a, b) -> "TryFinally" + "(" + PrintStatement a + ", " + PrintStatement b + ")"
        | Labeled (a, b) -> "Labeled" + "(" + string a + ", " + PrintStatement b + ")"
        | StatementSourcePos (_, b) -> PrintStatement b
        | Goto a -> "Goto" + "(" + string a + ")"
        | Continuation (a, b) -> "Continuation" + "(" + string a + ", " + PrintExpression b + ")"
        | Yield a -> "Yield" + "(" + defaultArg (Option.map PrintExpression a) "_" + ")"
        | CSharpSwitch (a, b) -> "CSharpSwitch" + "(" + PrintExpression a + ", " + "[" + String.concat "; " (List.map (fun (a, b) -> "[" + String.concat "; " (List.map (fun aa -> defaultArg (Option.map PrintExpression aa) "_") a) + "], " + PrintStatement b) b) + "]" + ")"
        | GotoCase a -> "GotoCase" + "(" + defaultArg (Option.map PrintExpression a) "_" + ")"
        | DoNotReturn  -> "DoNotReturn" + ""
// }}
    and PrintGenerics (ts: Type list) =
       match ts with [] -> "" | _ -> "<" + (ts |> Seq.map string |> String.concat ",") + ">"
    and PrintTraitCallParams (m: MethodInfo) =
       "(sig: " + (m.Parameters |> Seq.map string |> String.concat "*") + "->" + string m.ReturnType + ")"


    let PrintExpressionWithPos x =
        match x with
        | ExprSourcePos (a, b) -> 
            sprintf "%s @ (%d:%d-%d:%d)" (PrintExpression b) (fst a.Start) (snd a.Start) (fst a.End) (snd a.End)
        | _ -> PrintExpression x

/// A transformer base class that skips expression forms
type StatementTransformer() =
    inherit Transformer()

    override this.TransformExpression(a) = a

/// A visitor base class that skips expression forms
type StatementVisitor() =
    inherit Visitor()

    override this.VisitExpression(_) = ()

[<AutoOpen>]
module ExtraForms =
    module I = IgnoreSourcePos

    let Lambda (a, b) = Function (a, Return b)
    let (|Lambda|_|) expr =
        match expr with
        | Function (a, I.Return b) -> Some (a, b)
        | Function (a, I.ExprStatement b) -> Some (a, Sequential [ b; Value Null ])
        | _ -> None

    let CurriedLambda (a, b) = List.foldBack (fun a b -> Function ([a], Return b)) a b
    
    let IgnoredStatementExpr(a) = StatementExpr(a, None)
    
    let WithVars(a, b) = 
        Sequential [ 
            for v in a -> NewVar (v, Undefined)
            yield b 
        ]
    
    let VarSetStatement(a, b) = ExprStatement (VarSet(a, b))
    
    let Void(a) = Unary(UnaryOperator.``void``, a)
