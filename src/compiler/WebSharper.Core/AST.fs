// $begin{copyright}
//
// This file is part of WebSharper
//
// Copyright (c) 2008-2018 IntelliFactory
//
// Licensed under the Apache License, Version 2.0 (the "License"); you
// may not use this file except in compliance with the License.  You may
// obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied.  See the License for the specific language governing
// permissions and limitations under the License.
//
// $end{copyright}

namespace WebSharper.Core.AST

type Literal =
    | Null
    | Bool    of Value:bool
    | Byte    of Value:byte
    | Char    of Value:char
    | Double  of Value:double
    | Int     of Value:int
    | Int16   of Value:int16
    | Int64   of Value:int64
    | SByte   of Value:sbyte
    | Single  of Value:single
    | String  of Value:string
    | UInt16  of Value:uint16
    | UInt32  of Value:uint32
    | UInt64  of Value:uint64
    | Decimal of Value:decimal
    | ByteArray of Value:byte[]
    | UInt16Array of Value:uint16[]

    static member (!~) a = Value a

    member this.Value =
        match this with
        | Null      -> null
        | Bool    v -> box v
        | Byte    v -> box v
        | Char    v -> box v
        | Double  v -> box v
        | Int     v -> box v
        | Int16   v -> box v
        | Int64   v -> box v
        | SByte   v -> box v
        | Single  v -> box v
        | String  v -> box v
        | UInt16  v -> box v
        | UInt32  v -> box v
        | UInt64  v -> box v
        | Decimal v -> box v
        | ByteArray v -> box v
        | UInt16Array v -> box v


    member this.TSType =
        match this with
        | Null      -> "null"
        | Bool    v -> if v then "true" else "false"
        | Byte    v -> string v
        | Char    v -> "'" + string v + "'"
        | Double  v -> string v
        | Int     v -> string v
        | Int16   v -> string v
        | Int64   v -> string v
        | SByte   v -> string v
        | Single  v -> string v
        | String  v -> "'" + string v + "'"
        | UInt16  v -> string v
        | UInt32  v -> string v
        | UInt64  v -> string v
        | Decimal v -> string v     
        | ByteArray v -> "Uint8Array"
        | UInt16Array v -> "Uint16Array"

and [<RequireQualifiedAccess>] VarKind =
    | Var
    | Const
    | Let

and [<RequireQualifiedAccess>] MemberKind =
    | Simple
    | Getter
    | Setter

and ClassMethodInfo =
    {
        IsStatic : bool
        IsPrivate : bool
        Kind : MemberKind
    }

and ClassPropertyInfo =
    {
        IsStatic : bool
        IsPrivate : bool
        IsOptional : bool
    }

and ApplicationInfo =
    {
        Purity : Purity
        KnownLength : option<int>
        Params: list<TSType>
    }
    override this.ToString() =
        sprintf "%A%s" this.Purity (match this.KnownLength with Some l -> "L" + string l | _ -> "")

    static member None =
        {
            Purity = NonPure
            KnownLength = None
            Params = []
        }
 
and NewInfo =
    {
        Purity : Purity
        Params: list<TSType>
    }
    override this.ToString() =
        sprintf "%A" this.Purity

    static member None =
        {
            Purity = NonPure
            Params = []
        }

// {{ generated by genAST.fsx, do not modify
and Expression =
    /// JavaScript `undefined` value or `void` in .NET
    | Undefined
    /// Gets the value of a variable
    | Var of Variable:Id
    /// Contains a literal value
    | Value of Value:Literal
    /// Function application with extra information. The `Purity` field should be true only when the function called has no side effects, so the side effects of the expression is the same as evaluating `func` then the expressions in the `arguments` list. The `KnownLength` field should be `Some x` only when the function is known to have `x` number of arguments and does not use the `this` value.
    | Application of Func:Expression * Arguments:list<Expression> * Info:ApplicationInfo
    /// Function declaration
    | Function of Parameters:list<Id> * ThisVar:option<Id> * Return:option<Type> * Body:Statement
    /// Variable set
    | VarSet of Variable:Id * Value:Expression
    /// Sequential evaluation of expressions, value is taken from the last
    | Sequential of Expressions:list<Expression>
    /// Creating a new array
    | NewTuple of Items:list<Expression> * TupleType:list<Type>
    /// Conditional operation
    | Conditional of Condition:Expression * WhenTrue:Expression * WhenFalse:Expression
    /// Indexer get without side effects
    | ItemGet of Object:Expression * Item:Expression * Pure:Purity
    /// Indexer set
    | ItemSet of Object:Expression * Item:Expression * Value:Expression
    /// Binary operation
    | Binary of Left:Expression * Operator:BinaryOperator * Right:Expression
    /// Binary operation mutating right side
    | MutatingBinary of Left:Expression * Operator:MutatingBinaryOperator * Right:Expression
    /// Unary operation
    | Unary of Operator:UnaryOperator * Expression:Expression
    /// Unary operation mutating value
    | MutatingUnary of Operator:MutatingUnaryOperator * Expression:Expression
    /// Original source location for an expression
    | ExprSourcePos of Range:SourcePos * Expression:Expression
    /// JavaScript - the this value
    | JSThis
    /// Refers to the base class from an instance method, `super` in JavaScript
    | Base
    /// .NET - Method call
    | Call of ThisObject:option<Expression> * TypeDefinition:Concrete<TypeDefinition> * Method:Concrete<Method> * Arguments:list<Expression>
    /// Temporary - Partial application, workaround for FCS issue #414
    | CallNeedingMoreArgs of ThisObject:option<Expression> * TypeDefinition:Concrete<TypeDefinition> * Method:Concrete<Method> * Arguments:list<Expression>
    /// Temporary - F# function application, bool indicates if the argument has type unit
    | CurriedApplication of Func:Expression * Arguments:list<bool * Expression>
    /// Temporary - optimized curried or tupled F# function argument
    | OptimizedFSharpArg of FuncVar:Expression * Opt:FuncArgOptimization
    /// .NET - Constructor call
    | Ctor of TypeDefinition:Concrete<TypeDefinition> * Ctor:Constructor * Arguments:list<Expression>
    /// .NET - Chained or base constructor call
    | ChainedCtor of IsBase:bool * TypeDefinition:Concrete<TypeDefinition> * Ctor:Constructor * Arguments:list<Expression>
    /// .NET - Creating an object from a plain object
    | CopyCtor of TypeDefinition:TypeDefinition * Object:Expression
    /// .NET - Field getter
    | FieldGet of ThisObject:option<Expression> * TypeDefinition:Concrete<TypeDefinition> * Field:string
    /// .NET - Field setter
    | FieldSet of ThisObject:option<Expression> * TypeDefinition:Concrete<TypeDefinition> * Field:string * Value:Expression
    /// .NET - An immutable value definition used only in expression body
    | Let of Identifier:Id * Value:Expression * Body:Expression
    /// .NET - An expression-level variable declaration
    | NewVar of Variable:Id * Value:Expression
    /// .NET - Null-coalescing
    | Coalesce of Expression:Expression * Type:Type * WhenNull:Expression
    /// .NET - Type check, returns bool
    | TypeCheck of Expression:Expression * Type:Type
    /// .NET - Type coercion
    | Coerce of Expression:Expression * FromType:Type * ToType:Type
    /// .NET - Creates a new delegate
    | NewDelegate of ThisObject:option<Expression> * TypeDefinition:Concrete<TypeDefinition> * Method:Concrete<Method>
    /// .NET - Statement inside an expression. Result can be an identifier for a variable which is not explicitly defined inside the statement
    | StatementExpr of Statement:Statement * Result:option<Id>
    /// .NET - F# let rec
    | LetRec of Bindings:list<Id * Expression> * Body:Expression
    /// .NET - F# record constructor
    | NewRecord of TypeDefinition:Concrete<TypeDefinition> * Fields:list<Expression>
    /// .NET - F# union case constructor
    | NewUnionCase of TypeDefinition:Concrete<TypeDefinition> * UnionCase:string * Fields:list<Expression>
    /// .NET - F# union case test
    | UnionCaseTest of Expression:Expression * TypeDefinition:Concrete<TypeDefinition> * UnionCase:string
    /// .NET - F# union case field getter
    | UnionCaseGet of Expression:Expression * TypeDefinition:Concrete<TypeDefinition> * UnionCase:string * Field:string
    /// .NET - F# union case tag getter
    | UnionCaseTag of Expression:Expression * TypeDefinition:Concrete<TypeDefinition>
    /// .NET - F# successful match
    | MatchSuccess of Index:int * Captures:list<Expression>
    /// .NET - Method call
    | TraitCall of ThisObject:option<Expression> * ObjectType:list<Type> * Method:Concrete<Method> * Arguments:list<Expression>
    /// Temporary - C# await expression
    | Await of Expression:Expression
    /// Temporary - C# named parameter
    | NamedParameter of Ordinal:int * Expression:Expression
    /// Temporary - C# ref or out parameter
    | RefOrOutParameter of Expression:Expression
    /// Temporary - C# complex element in initializer expression
    | ComplexElement of Items:list<Expression>
    /// JavaSript object
    | Object of Properties:list<string * MemberKind * Expression>
    /// A global or imported value
    | GlobalAccess of Address:Address
    /// A global or imported value setter
    | GlobalAccessSet of Address:Address * Value:Expression
    /// JavaScript 'new' call
    | New of Func:Expression * Param:list<TSType> * Arguments:list<Expression>
    /// Temporary - A hole in an expression for inlining
    | Hole of Index:int
    /// TypeScript - type cast <...>...
    | Cast of TargetType:TSType * Expression:Expression
    /// JavaScript - class { ... }
    | ClassExpr of ClassId:option<Id> * BaseClass:option<Expression> * Members:list<Statement>
    /// .NET - F# object expression
    | ObjectExpr of ObjectType:Type * Constructor:option<Expression> * Overrides:list<TypeDefinition * Method * Expression>
    with
    static member (^!==) (a, b) = Binary (a, BinaryOperator.``!==``, b)
    static member (^!=) (a, b) = Binary (a, BinaryOperator.``!=``, b)
    static member (^%) (a, b) = Binary (a, BinaryOperator.``%``, b)
    static member (^&&) (a, b) = Binary (a, BinaryOperator.``&&``, b)
    static member (^&) (a, b) = Binary (a, BinaryOperator.``&``, b)
    static member (^*) (a, b) = Binary (a, BinaryOperator.``*``, b)
    static member (^+) (a, b) = Binary (a, BinaryOperator.``+``, b)
    static member (^-) (a, b) = Binary (a, BinaryOperator.``-``, b)
    static member (^/) (a, b) = Binary (a, BinaryOperator.``/``, b)
    static member (^<<) (a, b) = Binary (a, BinaryOperator.``<<``, b)
    static member (^<=) (a, b) = Binary (a, BinaryOperator.``<=``, b)
    static member (^<) (a, b) = Binary (a, BinaryOperator.``<``, b)
    static member (^===) (a, b) = Binary (a, BinaryOperator.``===``, b)
    static member (^==) (a, b) = Binary (a, BinaryOperator.``==``, b)
    static member (^>=) (a, b) = Binary (a, BinaryOperator.``>=``, b)
    static member (^>>>) (a, b) = Binary (a, BinaryOperator.``>>>``, b)
    static member (^>>) (a, b) = Binary (a, BinaryOperator.``>>``, b)
    static member (^>) (a, b) = Binary (a, BinaryOperator.``>``, b)
    static member (^^) (a, b) = Binary (a, BinaryOperator.``^``, b)
    static member (^|) (a, b) = Binary (a, BinaryOperator.``|``, b)
    static member (^||) (a, b) = Binary (a, BinaryOperator.``||``, b)
    [<System.Obsolete>] member a.Item b = ItemGet (a, b, Pure)
    [<System.Obsolete>] member a.Item b = Application (a, b, ApplicationInfo.None)
and Statement =
    /// Empty statement
    | Empty
    /// JavaScript break statement
    | Break of Label:option<Id>
    /// JavaScript continue statement
    | Continue of Label:option<Id>
    /// Expression as statement
    | ExprStatement of Expression:Expression
    /// Return a value
    | Return of Value:Expression
    /// Block of statements
    | Block of Statements:list<Statement>
    /// Variable declaration
    | VarDeclaration of Variable:Id * Value:Expression
    /// Function declaration
    | FuncDeclaration of FuncId:Id * Parameters:list<Id> * ThisVar:option<Id> * Body:Statement * Generics:list<TSType>
    /// 'while' loop
    | While of Condition:Expression * Body:Statement
    /// 'do..while' loop
    | DoWhile of Body:Statement * Condition:Expression
    /// 'for' loop
    | For of Initializer:option<Expression> * Condition:option<Expression> * Step:option<Expression> * Body:Statement
    /// JavaScript 'for .. in' loop
    | ForIn of Variable:Id * Object:Expression * Body:Statement
    /// JavaScript 'switch' expression
    | Switch of Expression:Expression * Cases:list<option<Expression> * Statement>
    /// 'if' statement
    | If of Condition:Expression * ThenStatement:Statement * ElseStatement:Statement
    /// 'throw' statement
    | Throw of Expression:Expression
    /// 'try..with' statement
    | TryWith of Body:Statement * Variable:option<Id> * CatchStatement:Statement
    /// 'try..finally' statement
    | TryFinally of Body:Statement * FinallyStatement:Statement
    /// Statement with a label
    | Labeled of Label:Id * Statement:Statement
    /// Original source location for a statement
    | StatementSourcePos of Range:SourcePos * Statement:Statement
    /// Temporary - C# 'goto' statement
    | Goto of Label:Id
    /// Temporary - go to next state in state-machine for iterators, async methods, or methods containing gotos
    | Continuation of Label:Id * Expression:Expression
    /// Temporary - C# 'yield return' statement
    | Yield of Value:option<Expression>
    /// Temporary - C# 'switch' statement
    | CSharpSwitch of Expression:Expression * Cases:list<list<option<Expression>> * Statement>
    /// Temporary - C# 'goto case' statement
    | GotoCase of CaseExpression:option<Expression>
    /// .NET - F# tail call position
    | DoNotReturn
    /// JavaScript - import * as ... from ...
    | Import of DefaultImport:option<Id> * FullImport:option<Id> * NamedImports:list<string * Id> * ModuleName:string
    /// JavaScript - export
    | ExportDecl of IsDefault:bool * Statement:Statement
    /// TypeScript - declare ...
    | Declare of Statement:Statement
    /// TypeScript - namespace { ... }
    | Namespace of Name:string * Statements:list<Statement>
    /// JavaScript - class { ... }
    | Class of ClassId:Id * BaseClass:option<Expression> * Implementations:list<TSType> * Members:list<Statement> * Generics:list<TSType>
    /// JavaScript - class method
    | ClassMethod of Info:ClassMethodInfo * Name:string * Parameters:list<Id> * ThisVar:option<Id> * Body:option<Statement> * Signature:TSType
    /// JavaScript - class method
    | ClassConstructor of Parameters:list<Id * Modifiers> * ThisVar:option<Id> * Body:option<Statement> * Signature:TSType
    /// JavaScript - class plain property
    | ClassProperty of Info:ClassPropertyInfo * Name:string * PropertyType:TSType * Value:option<Expression>
    /// JavaScript - class static block
    | ClassStatic of Optional:Statement
    /// TypeScript - interface { ... }
    | Interface of Name:string * Extending:list<TSType> * Members:list<Statement> * Generics:list<TSType>
    /// TypeScript - type or import alias
    | Alias of Alias:TSType * OrigType:TSType
    /// TypeScript - triple-slash directive
    | XmlComment of Xml:string
/// Base class for code transformers.
/// Provides virtual methods for transforming each AST case separately.
type Transformer() =
    /// JavaScript `undefined` value or `void` in .NET
    abstract TransformUndefined : unit -> Expression
    override this.TransformUndefined () = Undefined 
    /// Gets the value of a variable
    abstract TransformVar : Variable:Id -> Expression
    override this.TransformVar a = Var (this.TransformId a)
    /// Contains a literal value
    abstract TransformValue : Value:Literal -> Expression
    override this.TransformValue a = Value (a)
    /// Function application with extra information. The `Purity` field should be true only when the function called has no side effects, so the side effects of the expression is the same as evaluating `func` then the expressions in the `arguments` list. The `KnownLength` field should be `Some x` only when the function is known to have `x` number of arguments and does not use the `this` value.
    abstract TransformApplication : Func:Expression * Arguments:list<Expression> * Info:ApplicationInfo -> Expression
    override this.TransformApplication (a, b, c) = Application (this.TransformExpression a, List.map this.TransformExpression b, c)
    /// Function declaration
    abstract TransformFunction : Parameters:list<Id> * ThisVar:option<Id> * Return:option<Type> * Body:Statement -> Expression
    override this.TransformFunction (a, b, c, d) = Function (List.map this.TransformId a, Option.map this.TransformId b, c, this.TransformStatement d)
    /// Variable set
    abstract TransformVarSet : Variable:Id * Value:Expression -> Expression
    override this.TransformVarSet (a, b) = VarSet (this.TransformId a, this.TransformExpression b)
    /// Sequential evaluation of expressions, value is taken from the last
    abstract TransformSequential : Expressions:list<Expression> -> Expression
    override this.TransformSequential a = Sequential (List.map this.TransformExpression a)
    /// Creating a new array
    abstract TransformNewTuple : Items:list<Expression> * TupleType:list<Type> -> Expression
    override this.TransformNewTuple (a, b) = NewTuple (List.map this.TransformExpression a, b)
    /// Conditional operation
    abstract TransformConditional : Condition:Expression * WhenTrue:Expression * WhenFalse:Expression -> Expression
    override this.TransformConditional (a, b, c) = Conditional (this.TransformExpression a, this.TransformExpression b, this.TransformExpression c)
    /// Indexer get without side effects
    abstract TransformItemGet : Object:Expression * Item:Expression * Pure:Purity -> Expression
    override this.TransformItemGet (a, b, c) = ItemGet (this.TransformExpression a, this.TransformExpression b, c)
    /// Indexer set
    abstract TransformItemSet : Object:Expression * Item:Expression * Value:Expression -> Expression
    override this.TransformItemSet (a, b, c) = ItemSet (this.TransformExpression a, this.TransformExpression b, this.TransformExpression c)
    /// Binary operation
    abstract TransformBinary : Left:Expression * Operator:BinaryOperator * Right:Expression -> Expression
    override this.TransformBinary (a, b, c) = Binary (this.TransformExpression a, b, this.TransformExpression c)
    /// Binary operation mutating right side
    abstract TransformMutatingBinary : Left:Expression * Operator:MutatingBinaryOperator * Right:Expression -> Expression
    override this.TransformMutatingBinary (a, b, c) = MutatingBinary (this.TransformExpression a, b, this.TransformExpression c)
    /// Unary operation
    abstract TransformUnary : Operator:UnaryOperator * Expression:Expression -> Expression
    override this.TransformUnary (a, b) = Unary (a, this.TransformExpression b)
    /// Unary operation mutating value
    abstract TransformMutatingUnary : Operator:MutatingUnaryOperator * Expression:Expression -> Expression
    override this.TransformMutatingUnary (a, b) = MutatingUnary (a, this.TransformExpression b)
    /// Original source location for an expression
    abstract TransformExprSourcePos : Range:SourcePos * Expression:Expression -> Expression
    override this.TransformExprSourcePos (a, b) =
        match this.TransformExpression b with
        | ExprSourcePos (_, bt) | bt -> ExprSourcePos (a, bt)
    /// JavaScript - the this value
    abstract TransformJSThis : unit -> Expression
    override this.TransformJSThis () = JSThis 
    /// Refers to the base class from an instance method, `super` in JavaScript
    abstract TransformBase : unit -> Expression
    override this.TransformBase () = Base 
    /// .NET - Method call
    abstract TransformCall : ThisObject:option<Expression> * TypeDefinition:Concrete<TypeDefinition> * Method:Concrete<Method> * Arguments:list<Expression> -> Expression
    override this.TransformCall (a, b, c, d) = Call (Option.map this.TransformExpression a, b, c, List.map this.TransformExpression d)
    /// Temporary - Partial application, workaround for FCS issue #414
    abstract TransformCallNeedingMoreArgs : ThisObject:option<Expression> * TypeDefinition:Concrete<TypeDefinition> * Method:Concrete<Method> * Arguments:list<Expression> -> Expression
    override this.TransformCallNeedingMoreArgs (a, b, c, d) = CallNeedingMoreArgs (Option.map this.TransformExpression a, b, c, List.map this.TransformExpression d)
    /// Temporary - F# function application, bool indicates if the argument has type unit
    abstract TransformCurriedApplication : Func:Expression * Arguments:list<bool * Expression> -> Expression
    override this.TransformCurriedApplication (a, b) = CurriedApplication (this.TransformExpression a, List.map (fun (a, b) -> a, this.TransformExpression b) b)
    /// Temporary - optimized curried or tupled F# function argument
    abstract TransformOptimizedFSharpArg : FuncVar:Expression * Opt:FuncArgOptimization -> Expression
    override this.TransformOptimizedFSharpArg (a, b) = OptimizedFSharpArg (this.TransformExpression a, b)
    /// .NET - Constructor call
    abstract TransformCtor : TypeDefinition:Concrete<TypeDefinition> * Ctor:Constructor * Arguments:list<Expression> -> Expression
    override this.TransformCtor (a, b, c) = Ctor (a, b, List.map this.TransformExpression c)
    /// .NET - Chained or base constructor call
    abstract TransformChainedCtor : IsBase:bool * TypeDefinition:Concrete<TypeDefinition> * Ctor:Constructor * Arguments:list<Expression> -> Expression
    override this.TransformChainedCtor (a, b, c, d) = ChainedCtor (a, b, c, List.map this.TransformExpression d)
    /// .NET - Creating an object from a plain object
    abstract TransformCopyCtor : TypeDefinition:TypeDefinition * Object:Expression -> Expression
    override this.TransformCopyCtor (a, b) = CopyCtor (a, this.TransformExpression b)
    /// .NET - Field getter
    abstract TransformFieldGet : ThisObject:option<Expression> * TypeDefinition:Concrete<TypeDefinition> * Field:string -> Expression
    override this.TransformFieldGet (a, b, c) = FieldGet (Option.map this.TransformExpression a, b, c)
    /// .NET - Field setter
    abstract TransformFieldSet : ThisObject:option<Expression> * TypeDefinition:Concrete<TypeDefinition> * Field:string * Value:Expression -> Expression
    override this.TransformFieldSet (a, b, c, d) = FieldSet (Option.map this.TransformExpression a, b, c, this.TransformExpression d)
    /// .NET - An immutable value definition used only in expression body
    abstract TransformLet : Identifier:Id * Value:Expression * Body:Expression -> Expression
    override this.TransformLet (a, b, c) = Let (this.TransformId a, this.TransformExpression b, this.TransformExpression c)
    /// .NET - An expression-level variable declaration
    abstract TransformNewVar : Variable:Id * Value:Expression -> Expression
    override this.TransformNewVar (a, b) = NewVar (this.TransformId a, this.TransformExpression b)
    /// .NET - Null-coalescing
    abstract TransformCoalesce : Expression:Expression * Type:Type * WhenNull:Expression -> Expression
    override this.TransformCoalesce (a, b, c) = Coalesce (this.TransformExpression a, b, this.TransformExpression c)
    /// .NET - Type check, returns bool
    abstract TransformTypeCheck : Expression:Expression * Type:Type -> Expression
    override this.TransformTypeCheck (a, b) = TypeCheck (this.TransformExpression a, b)
    /// .NET - Type coercion
    abstract TransformCoerce : Expression:Expression * FromType:Type * ToType:Type -> Expression
    override this.TransformCoerce (a, b, c) = Coerce (this.TransformExpression a, b, c)
    /// .NET - Creates a new delegate
    abstract TransformNewDelegate : ThisObject:option<Expression> * TypeDefinition:Concrete<TypeDefinition> * Method:Concrete<Method> -> Expression
    override this.TransformNewDelegate (a, b, c) = NewDelegate (Option.map this.TransformExpression a, b, c)
    /// .NET - Statement inside an expression. Result can be an identifier for a variable which is not explicitly defined inside the statement
    abstract TransformStatementExpr : Statement:Statement * Result:option<Id> -> Expression
    override this.TransformStatementExpr (a, b) = StatementExpr (this.TransformStatement a, Option.map this.TransformId b)
    /// .NET - F# let rec
    abstract TransformLetRec : Bindings:list<Id * Expression> * Body:Expression -> Expression
    override this.TransformLetRec (a, b) = LetRec (List.map (fun (a, b) -> this.TransformId a, this.TransformExpression b) a, this.TransformExpression b)
    /// .NET - F# record constructor
    abstract TransformNewRecord : TypeDefinition:Concrete<TypeDefinition> * Fields:list<Expression> -> Expression
    override this.TransformNewRecord (a, b) = NewRecord (a, List.map this.TransformExpression b)
    /// .NET - F# union case constructor
    abstract TransformNewUnionCase : TypeDefinition:Concrete<TypeDefinition> * UnionCase:string * Fields:list<Expression> -> Expression
    override this.TransformNewUnionCase (a, b, c) = NewUnionCase (a, b, List.map this.TransformExpression c)
    /// .NET - F# union case test
    abstract TransformUnionCaseTest : Expression:Expression * TypeDefinition:Concrete<TypeDefinition> * UnionCase:string -> Expression
    override this.TransformUnionCaseTest (a, b, c) = UnionCaseTest (this.TransformExpression a, b, c)
    /// .NET - F# union case field getter
    abstract TransformUnionCaseGet : Expression:Expression * TypeDefinition:Concrete<TypeDefinition> * UnionCase:string * Field:string -> Expression
    override this.TransformUnionCaseGet (a, b, c, d) = UnionCaseGet (this.TransformExpression a, b, c, d)
    /// .NET - F# union case tag getter
    abstract TransformUnionCaseTag : Expression:Expression * TypeDefinition:Concrete<TypeDefinition> -> Expression
    override this.TransformUnionCaseTag (a, b) = UnionCaseTag (this.TransformExpression a, b)
    /// .NET - F# successful match
    abstract TransformMatchSuccess : Index:int * Captures:list<Expression> -> Expression
    override this.TransformMatchSuccess (a, b) = MatchSuccess (a, List.map this.TransformExpression b)
    /// .NET - Method call
    abstract TransformTraitCall : ThisObject:option<Expression> * ObjectType:list<Type> * Method:Concrete<Method> * Arguments:list<Expression> -> Expression
    override this.TransformTraitCall (a, b, c, d) = TraitCall (Option.map this.TransformExpression a, b, c, List.map this.TransformExpression d)
    /// Temporary - C# await expression
    abstract TransformAwait : Expression:Expression -> Expression
    override this.TransformAwait a = Await (this.TransformExpression a)
    /// Temporary - C# named parameter
    abstract TransformNamedParameter : Ordinal:int * Expression:Expression -> Expression
    override this.TransformNamedParameter (a, b) = NamedParameter (a, this.TransformExpression b)
    /// Temporary - C# ref or out parameter
    abstract TransformRefOrOutParameter : Expression:Expression -> Expression
    override this.TransformRefOrOutParameter a = RefOrOutParameter (this.TransformExpression a)
    /// Temporary - C# complex element in initializer expression
    abstract TransformComplexElement : Items:list<Expression> -> Expression
    override this.TransformComplexElement a = ComplexElement (List.map this.TransformExpression a)
    /// JavaSript object
    abstract TransformObject : Properties:list<string * MemberKind * Expression> -> Expression
    override this.TransformObject a = Object (List.map (fun (a, b, c) -> a, b, this.TransformExpression c) a)
    /// A global or imported value
    abstract TransformGlobalAccess : Address:Address -> Expression
    override this.TransformGlobalAccess a = GlobalAccess (a)
    /// A global or imported value setter
    abstract TransformGlobalAccessSet : Address:Address * Value:Expression -> Expression
    override this.TransformGlobalAccessSet (a, b) = GlobalAccessSet (a, this.TransformExpression b)
    /// JavaScript 'new' call
    abstract TransformNew : Func:Expression * Param:list<TSType> * Arguments:list<Expression> -> Expression
    override this.TransformNew (a, b, c) = New (this.TransformExpression a, b, List.map this.TransformExpression c)
    /// Temporary - A hole in an expression for inlining
    abstract TransformHole : Index:int -> Expression
    override this.TransformHole a = Hole (a)
    /// TypeScript - type cast <...>...
    abstract TransformCast : TargetType:TSType * Expression:Expression -> Expression
    override this.TransformCast (a, b) = Cast (a, this.TransformExpression b)
    /// JavaScript - class { ... }
    abstract TransformClassExpr : ClassId:option<Id> * BaseClass:option<Expression> * Members:list<Statement> -> Expression
    override this.TransformClassExpr (a, b, c) = ClassExpr (Option.map this.TransformId a, Option.map this.TransformExpression b, List.map this.TransformStatement c)
    /// .NET - F# object expression
    abstract TransformObjectExpr : ObjectType:Type * Constructor:option<Expression> * Overrides:list<TypeDefinition * Method * Expression> -> Expression
    override this.TransformObjectExpr (a, b, c) = ObjectExpr (a, Option.map this.TransformExpression b, List.map (fun (a, b, c) -> a, b, this.TransformExpression c) c)
    /// Empty statement
    abstract TransformEmpty : unit -> Statement
    override this.TransformEmpty () = Empty 
    /// JavaScript break statement
    abstract TransformBreak : Label:option<Id> -> Statement
    override this.TransformBreak a = Break (Option.map this.TransformId a)
    /// JavaScript continue statement
    abstract TransformContinue : Label:option<Id> -> Statement
    override this.TransformContinue a = Continue (Option.map this.TransformId a)
    /// Expression as statement
    abstract TransformExprStatement : Expression:Expression -> Statement
    override this.TransformExprStatement a = ExprStatement (this.TransformExpression a)
    /// Return a value
    abstract TransformReturn : Value:Expression -> Statement
    override this.TransformReturn a = Return (this.TransformExpression a)
    /// Block of statements
    abstract TransformBlock : Statements:list<Statement> -> Statement
    override this.TransformBlock a = Block (List.map this.TransformStatement a)
    /// Variable declaration
    abstract TransformVarDeclaration : Variable:Id * Value:Expression -> Statement
    override this.TransformVarDeclaration (a, b) = VarDeclaration (this.TransformId a, this.TransformExpression b)
    /// Function declaration
    abstract TransformFuncDeclaration : FuncId:Id * Parameters:list<Id> * ThisVar:option<Id> * Body:Statement * Generics:list<TSType> -> Statement
    override this.TransformFuncDeclaration (a, b, c, d, e) = FuncDeclaration (this.TransformId a, List.map this.TransformId b, Option.map this.TransformId c, this.TransformStatement d, e)
    /// 'while' loop
    abstract TransformWhile : Condition:Expression * Body:Statement -> Statement
    override this.TransformWhile (a, b) = While (this.TransformExpression a, this.TransformStatement b)
    /// 'do..while' loop
    abstract TransformDoWhile : Body:Statement * Condition:Expression -> Statement
    override this.TransformDoWhile (a, b) = DoWhile (this.TransformStatement a, this.TransformExpression b)
    /// 'for' loop
    abstract TransformFor : Initializer:option<Expression> * Condition:option<Expression> * Step:option<Expression> * Body:Statement -> Statement
    override this.TransformFor (a, b, c, d) = For (Option.map this.TransformExpression a, Option.map this.TransformExpression b, Option.map this.TransformExpression c, this.TransformStatement d)
    /// JavaScript 'for .. in' loop
    abstract TransformForIn : Variable:Id * Object:Expression * Body:Statement -> Statement
    override this.TransformForIn (a, b, c) = ForIn (this.TransformId a, this.TransformExpression b, this.TransformStatement c)
    /// JavaScript 'switch' expression
    abstract TransformSwitch : Expression:Expression * Cases:list<option<Expression> * Statement> -> Statement
    override this.TransformSwitch (a, b) = Switch (this.TransformExpression a, List.map (fun (a, b) -> Option.map this.TransformExpression a, this.TransformStatement b) b)
    /// 'if' statement
    abstract TransformIf : Condition:Expression * ThenStatement:Statement * ElseStatement:Statement -> Statement
    override this.TransformIf (a, b, c) = If (this.TransformExpression a, this.TransformStatement b, this.TransformStatement c)
    /// 'throw' statement
    abstract TransformThrow : Expression:Expression -> Statement
    override this.TransformThrow a = Throw (this.TransformExpression a)
    /// 'try..with' statement
    abstract TransformTryWith : Body:Statement * Variable:option<Id> * CatchStatement:Statement -> Statement
    override this.TransformTryWith (a, b, c) = TryWith (this.TransformStatement a, Option.map this.TransformId b, this.TransformStatement c)
    /// 'try..finally' statement
    abstract TransformTryFinally : Body:Statement * FinallyStatement:Statement -> Statement
    override this.TransformTryFinally (a, b) = TryFinally (this.TransformStatement a, this.TransformStatement b)
    /// Statement with a label
    abstract TransformLabeled : Label:Id * Statement:Statement -> Statement
    override this.TransformLabeled (a, b) = Labeled (this.TransformId a, this.TransformStatement b)
    /// Original source location for a statement
    abstract TransformStatementSourcePos : Range:SourcePos * Statement:Statement -> Statement
    override this.TransformStatementSourcePos (a, b) =
        match this.TransformStatement b with
        | StatementSourcePos (_, bt) | bt -> StatementSourcePos (a, bt)
    /// Temporary - C# 'goto' statement
    abstract TransformGoto : Label:Id -> Statement
    override this.TransformGoto a = Goto (this.TransformId a)
    /// Temporary - go to next state in state-machine for iterators, async methods, or methods containing gotos
    abstract TransformContinuation : Label:Id * Expression:Expression -> Statement
    override this.TransformContinuation (a, b) = Continuation (this.TransformId a, this.TransformExpression b)
    /// Temporary - C# 'yield return' statement
    abstract TransformYield : Value:option<Expression> -> Statement
    override this.TransformYield a = Yield (Option.map this.TransformExpression a)
    /// Temporary - C# 'switch' statement
    abstract TransformCSharpSwitch : Expression:Expression * Cases:list<list<option<Expression>> * Statement> -> Statement
    override this.TransformCSharpSwitch (a, b) = CSharpSwitch (this.TransformExpression a, List.map (fun (a, b) -> List.map (Option.map this.TransformExpression) a, this.TransformStatement b) b)
    /// Temporary - C# 'goto case' statement
    abstract TransformGotoCase : CaseExpression:option<Expression> -> Statement
    override this.TransformGotoCase a = GotoCase (Option.map this.TransformExpression a)
    /// .NET - F# tail call position
    abstract TransformDoNotReturn : unit -> Statement
    override this.TransformDoNotReturn () = DoNotReturn 
    /// JavaScript - import * as ... from ...
    abstract TransformImport : DefaultImport:option<Id> * FullImport:option<Id> * NamedImports:list<string * Id> * ModuleName:string -> Statement
    override this.TransformImport (a, b, c, d) = Import (Option.map this.TransformId a, Option.map this.TransformId b, List.map (fun (a, b) -> a, this.TransformId b) c, d)
    /// JavaScript - export
    abstract TransformExportDecl : IsDefault:bool * Statement:Statement -> Statement
    override this.TransformExportDecl (a, b) = ExportDecl (a, this.TransformStatement b)
    /// TypeScript - declare ...
    abstract TransformDeclare : Statement:Statement -> Statement
    override this.TransformDeclare a = Declare (this.TransformStatement a)
    /// TypeScript - namespace { ... }
    abstract TransformNamespace : Name:string * Statements:list<Statement> -> Statement
    override this.TransformNamespace (a, b) = Namespace (a, List.map this.TransformStatement b)
    /// JavaScript - class { ... }
    abstract TransformClass : ClassId:Id * BaseClass:option<Expression> * Implementations:list<TSType> * Members:list<Statement> * Generics:list<TSType> -> Statement
    override this.TransformClass (a, b, c, d, e) = Class (this.TransformId a, Option.map this.TransformExpression b, c, List.map this.TransformStatement d, e)
    /// JavaScript - class method
    abstract TransformClassMethod : Info:ClassMethodInfo * Name:string * Parameters:list<Id> * ThisVar:option<Id> * Body:option<Statement> * Signature:TSType -> Statement
    override this.TransformClassMethod (a, b, c, d, e, f) = ClassMethod (a, b, List.map this.TransformId c, Option.map this.TransformId d, Option.map this.TransformStatement e, f)
    /// JavaScript - class method
    abstract TransformClassConstructor : Parameters:list<Id * Modifiers> * ThisVar:option<Id> * Body:option<Statement> * Signature:TSType -> Statement
    override this.TransformClassConstructor (a, b, c, d) = ClassConstructor (List.map (fun (a, b) -> this.TransformId a, b) a, Option.map this.TransformId b, Option.map this.TransformStatement c, d)
    /// JavaScript - class plain property
    abstract TransformClassProperty : Info:ClassPropertyInfo * Name:string * PropertyType:TSType * Value:option<Expression> -> Statement
    override this.TransformClassProperty (a, b, c, d) = ClassProperty (a, b, c, Option.map this.TransformExpression d)
    /// JavaScript - class static block
    abstract TransformClassStatic : Optional:Statement -> Statement
    override this.TransformClassStatic a = ClassStatic (this.TransformStatement a)
    /// TypeScript - interface { ... }
    abstract TransformInterface : Name:string * Extending:list<TSType> * Members:list<Statement> * Generics:list<TSType> -> Statement
    override this.TransformInterface (a, b, c, d) = Interface (a, b, List.map this.TransformStatement c, d)
    /// TypeScript - type or import alias
    abstract TransformAlias : Alias:TSType * OrigType:TSType -> Statement
    override this.TransformAlias (a, b) = Alias (a, b)
    /// TypeScript - triple-slash directive
    abstract TransformXmlComment : Xml:string -> Statement
    override this.TransformXmlComment a = XmlComment (a)
    abstract TransformExpression : Expression -> Expression
    override this.TransformExpression x =
        match x with
        | Undefined  -> this.TransformUndefined ()
        | Var a -> this.TransformVar a
        | Value a -> this.TransformValue a
        | Application (a, b, c) -> this.TransformApplication (a, b, c)
        | Function (a, b, c, d) -> this.TransformFunction (a, b, c, d)
        | VarSet (a, b) -> this.TransformVarSet (a, b)
        | Sequential a -> this.TransformSequential a
        | NewTuple (a, b) -> this.TransformNewTuple (a, b)
        | Conditional (a, b, c) -> this.TransformConditional (a, b, c)
        | ItemGet (a, b, c) -> this.TransformItemGet (a, b, c)
        | ItemSet (a, b, c) -> this.TransformItemSet (a, b, c)
        | Binary (a, b, c) -> this.TransformBinary (a, b, c)
        | MutatingBinary (a, b, c) -> this.TransformMutatingBinary (a, b, c)
        | Unary (a, b) -> this.TransformUnary (a, b)
        | MutatingUnary (a, b) -> this.TransformMutatingUnary (a, b)
        | ExprSourcePos (a, b) -> this.TransformExprSourcePos (a, b)
        | JSThis  -> this.TransformJSThis ()
        | Base  -> this.TransformBase ()
        | Call (a, b, c, d) -> this.TransformCall (a, b, c, d)
        | CallNeedingMoreArgs (a, b, c, d) -> this.TransformCallNeedingMoreArgs (a, b, c, d)
        | CurriedApplication (a, b) -> this.TransformCurriedApplication (a, b)
        | OptimizedFSharpArg (a, b) -> this.TransformOptimizedFSharpArg (a, b)
        | Ctor (a, b, c) -> this.TransformCtor (a, b, c)
        | ChainedCtor (a, b, c, d) -> this.TransformChainedCtor (a, b, c, d)
        | CopyCtor (a, b) -> this.TransformCopyCtor (a, b)
        | FieldGet (a, b, c) -> this.TransformFieldGet (a, b, c)
        | FieldSet (a, b, c, d) -> this.TransformFieldSet (a, b, c, d)
        | Let (a, b, c) -> this.TransformLet (a, b, c)
        | NewVar (a, b) -> this.TransformNewVar (a, b)
        | Coalesce (a, b, c) -> this.TransformCoalesce (a, b, c)
        | TypeCheck (a, b) -> this.TransformTypeCheck (a, b)
        | Coerce (a, b, c) -> this.TransformCoerce (a, b, c)
        | NewDelegate (a, b, c) -> this.TransformNewDelegate (a, b, c)
        | StatementExpr (a, b) -> this.TransformStatementExpr (a, b)
        | LetRec (a, b) -> this.TransformLetRec (a, b)
        | NewRecord (a, b) -> this.TransformNewRecord (a, b)
        | NewUnionCase (a, b, c) -> this.TransformNewUnionCase (a, b, c)
        | UnionCaseTest (a, b, c) -> this.TransformUnionCaseTest (a, b, c)
        | UnionCaseGet (a, b, c, d) -> this.TransformUnionCaseGet (a, b, c, d)
        | UnionCaseTag (a, b) -> this.TransformUnionCaseTag (a, b)
        | MatchSuccess (a, b) -> this.TransformMatchSuccess (a, b)
        | TraitCall (a, b, c, d) -> this.TransformTraitCall (a, b, c, d)
        | Await a -> this.TransformAwait a
        | NamedParameter (a, b) -> this.TransformNamedParameter (a, b)
        | RefOrOutParameter a -> this.TransformRefOrOutParameter a
        | ComplexElement a -> this.TransformComplexElement a
        | Object a -> this.TransformObject a
        | GlobalAccess a -> this.TransformGlobalAccess a
        | GlobalAccessSet (a, b) -> this.TransformGlobalAccessSet (a, b)
        | New (a, b, c) -> this.TransformNew (a, b, c)
        | Hole a -> this.TransformHole a
        | Cast (a, b) -> this.TransformCast (a, b)
        | ClassExpr (a, b, c) -> this.TransformClassExpr (a, b, c)
        | ObjectExpr (a, b, c) -> this.TransformObjectExpr (a, b, c)
    abstract TransformStatement : Statement -> Statement
    override this.TransformStatement x =
        match x with
        | Empty  -> this.TransformEmpty ()
        | Break a -> this.TransformBreak a
        | Continue a -> this.TransformContinue a
        | ExprStatement a -> this.TransformExprStatement a
        | Return a -> this.TransformReturn a
        | Block a -> this.TransformBlock a
        | VarDeclaration (a, b) -> this.TransformVarDeclaration (a, b)
        | FuncDeclaration (a, b, c, d, e) -> this.TransformFuncDeclaration (a, b, c, d, e)
        | While (a, b) -> this.TransformWhile (a, b)
        | DoWhile (a, b) -> this.TransformDoWhile (a, b)
        | For (a, b, c, d) -> this.TransformFor (a, b, c, d)
        | ForIn (a, b, c) -> this.TransformForIn (a, b, c)
        | Switch (a, b) -> this.TransformSwitch (a, b)
        | If (a, b, c) -> this.TransformIf (a, b, c)
        | Throw a -> this.TransformThrow a
        | TryWith (a, b, c) -> this.TransformTryWith (a, b, c)
        | TryFinally (a, b) -> this.TransformTryFinally (a, b)
        | Labeled (a, b) -> this.TransformLabeled (a, b)
        | StatementSourcePos (a, b) -> this.TransformStatementSourcePos (a, b)
        | Goto a -> this.TransformGoto a
        | Continuation (a, b) -> this.TransformContinuation (a, b)
        | Yield a -> this.TransformYield a
        | CSharpSwitch (a, b) -> this.TransformCSharpSwitch (a, b)
        | GotoCase a -> this.TransformGotoCase a
        | DoNotReturn  -> this.TransformDoNotReturn ()
        | Import (a, b, c, d) -> this.TransformImport (a, b, c, d)
        | ExportDecl (a, b) -> this.TransformExportDecl (a, b)
        | Declare a -> this.TransformDeclare a
        | Namespace (a, b) -> this.TransformNamespace (a, b)
        | Class (a, b, c, d, e) -> this.TransformClass (a, b, c, d, e)
        | ClassMethod (a, b, c, d, e, f) -> this.TransformClassMethod (a, b, c, d, e, f)
        | ClassConstructor (a, b, c, d) -> this.TransformClassConstructor (a, b, c, d)
        | ClassProperty (a, b, c, d) -> this.TransformClassProperty (a, b, c, d)
        | ClassStatic a -> this.TransformClassStatic a
        | Interface (a, b, c, d) -> this.TransformInterface (a, b, c, d)
        | Alias (a, b) -> this.TransformAlias (a, b)
        | XmlComment a -> this.TransformXmlComment a
    /// Identifier for variable or label
    abstract TransformId : Id -> Id
    override this.TransformId x = x
/// Base class for code visitors.
/// Provides virtual methods for visiting each AST case separately.
type Visitor() =
    /// JavaScript `undefined` value or `void` in .NET
    abstract VisitUndefined : unit -> unit
    override this.VisitUndefined () = ()
    /// Gets the value of a variable
    abstract VisitVar : Variable:Id -> unit
    override this.VisitVar a = (this.VisitId a)
    /// Contains a literal value
    abstract VisitValue : Value:Literal -> unit
    override this.VisitValue a = (())
    /// Function application with extra information. The `Purity` field should be true only when the function called has no side effects, so the side effects of the expression is the same as evaluating `func` then the expressions in the `arguments` list. The `KnownLength` field should be `Some x` only when the function is known to have `x` number of arguments and does not use the `this` value.
    abstract VisitApplication : Func:Expression * Arguments:list<Expression> * Info:ApplicationInfo -> unit
    override this.VisitApplication (a, b, c) = this.VisitExpression a; List.iter this.VisitExpression b; ()
    /// Function declaration
    abstract VisitFunction : Parameters:list<Id> * ThisVar:option<Id> * Return:option<Type> * Body:Statement -> unit
    override this.VisitFunction (a, b, c, d) = List.iter this.VisitId a; Option.iter this.VisitId b; (); this.VisitStatement d
    /// Variable set
    abstract VisitVarSet : Variable:Id * Value:Expression -> unit
    override this.VisitVarSet (a, b) = this.VisitId a; this.VisitExpression b
    /// Sequential evaluation of expressions, value is taken from the last
    abstract VisitSequential : Expressions:list<Expression> -> unit
    override this.VisitSequential a = (List.iter this.VisitExpression a)
    /// Creating a new array
    abstract VisitNewTuple : Items:list<Expression> * TupleType:list<Type> -> unit
    override this.VisitNewTuple (a, b) = List.iter this.VisitExpression a; ()
    /// Conditional operation
    abstract VisitConditional : Condition:Expression * WhenTrue:Expression * WhenFalse:Expression -> unit
    override this.VisitConditional (a, b, c) = this.VisitExpression a; this.VisitExpression b; this.VisitExpression c
    /// Indexer get without side effects
    abstract VisitItemGet : Object:Expression * Item:Expression * Pure:Purity -> unit
    override this.VisitItemGet (a, b, c) = this.VisitExpression a; this.VisitExpression b; ()
    /// Indexer set
    abstract VisitItemSet : Object:Expression * Item:Expression * Value:Expression -> unit
    override this.VisitItemSet (a, b, c) = this.VisitExpression a; this.VisitExpression b; this.VisitExpression c
    /// Binary operation
    abstract VisitBinary : Left:Expression * Operator:BinaryOperator * Right:Expression -> unit
    override this.VisitBinary (a, b, c) = this.VisitExpression a; (); this.VisitExpression c
    /// Binary operation mutating right side
    abstract VisitMutatingBinary : Left:Expression * Operator:MutatingBinaryOperator * Right:Expression -> unit
    override this.VisitMutatingBinary (a, b, c) = this.VisitExpression a; (); this.VisitExpression c
    /// Unary operation
    abstract VisitUnary : Operator:UnaryOperator * Expression:Expression -> unit
    override this.VisitUnary (a, b) = (); this.VisitExpression b
    /// Unary operation mutating value
    abstract VisitMutatingUnary : Operator:MutatingUnaryOperator * Expression:Expression -> unit
    override this.VisitMutatingUnary (a, b) = (); this.VisitExpression b
    /// Original source location for an expression
    abstract VisitExprSourcePos : Range:SourcePos * Expression:Expression -> unit
    override this.VisitExprSourcePos (a, b) = (); this.VisitExpression b
    /// JavaScript - the this value
    abstract VisitJSThis : unit -> unit
    override this.VisitJSThis () = ()
    /// Refers to the base class from an instance method, `super` in JavaScript
    abstract VisitBase : unit -> unit
    override this.VisitBase () = ()
    /// .NET - Method call
    abstract VisitCall : ThisObject:option<Expression> * TypeDefinition:Concrete<TypeDefinition> * Method:Concrete<Method> * Arguments:list<Expression> -> unit
    override this.VisitCall (a, b, c, d) = Option.iter this.VisitExpression a; (); (); List.iter this.VisitExpression d
    /// Temporary - Partial application, workaround for FCS issue #414
    abstract VisitCallNeedingMoreArgs : ThisObject:option<Expression> * TypeDefinition:Concrete<TypeDefinition> * Method:Concrete<Method> * Arguments:list<Expression> -> unit
    override this.VisitCallNeedingMoreArgs (a, b, c, d) = Option.iter this.VisitExpression a; (); (); List.iter this.VisitExpression d
    /// Temporary - F# function application, bool indicates if the argument has type unit
    abstract VisitCurriedApplication : Func:Expression * Arguments:list<bool * Expression> -> unit
    override this.VisitCurriedApplication (a, b) = this.VisitExpression a; List.iter (fun (a, b) -> this.VisitExpression b) b
    /// Temporary - optimized curried or tupled F# function argument
    abstract VisitOptimizedFSharpArg : FuncVar:Expression * Opt:FuncArgOptimization -> unit
    override this.VisitOptimizedFSharpArg (a, b) = this.VisitExpression a; ()
    /// .NET - Constructor call
    abstract VisitCtor : TypeDefinition:Concrete<TypeDefinition> * Ctor:Constructor * Arguments:list<Expression> -> unit
    override this.VisitCtor (a, b, c) = (); (); List.iter this.VisitExpression c
    /// .NET - Chained or base constructor call
    abstract VisitChainedCtor : IsBase:bool * TypeDefinition:Concrete<TypeDefinition> * Ctor:Constructor * Arguments:list<Expression> -> unit
    override this.VisitChainedCtor (a, b, c, d) = (); (); (); List.iter this.VisitExpression d
    /// .NET - Creating an object from a plain object
    abstract VisitCopyCtor : TypeDefinition:TypeDefinition * Object:Expression -> unit
    override this.VisitCopyCtor (a, b) = (); this.VisitExpression b
    /// .NET - Field getter
    abstract VisitFieldGet : ThisObject:option<Expression> * TypeDefinition:Concrete<TypeDefinition> * Field:string -> unit
    override this.VisitFieldGet (a, b, c) = Option.iter this.VisitExpression a; (); ()
    /// .NET - Field setter
    abstract VisitFieldSet : ThisObject:option<Expression> * TypeDefinition:Concrete<TypeDefinition> * Field:string * Value:Expression -> unit
    override this.VisitFieldSet (a, b, c, d) = Option.iter this.VisitExpression a; (); (); this.VisitExpression d
    /// .NET - An immutable value definition used only in expression body
    abstract VisitLet : Identifier:Id * Value:Expression * Body:Expression -> unit
    override this.VisitLet (a, b, c) = this.VisitId a; this.VisitExpression b; this.VisitExpression c
    /// .NET - An expression-level variable declaration
    abstract VisitNewVar : Variable:Id * Value:Expression -> unit
    override this.VisitNewVar (a, b) = this.VisitId a; this.VisitExpression b
    /// .NET - Null-coalescing
    abstract VisitCoalesce : Expression:Expression * Type:Type * WhenNull:Expression -> unit
    override this.VisitCoalesce (a, b, c) = this.VisitExpression a; (); this.VisitExpression c
    /// .NET - Type check, returns bool
    abstract VisitTypeCheck : Expression:Expression * Type:Type -> unit
    override this.VisitTypeCheck (a, b) = this.VisitExpression a; ()
    /// .NET - Type coercion
    abstract VisitCoerce : Expression:Expression * FromType:Type * ToType:Type -> unit
    override this.VisitCoerce (a, b, c) = this.VisitExpression a; (); ()
    /// .NET - Creates a new delegate
    abstract VisitNewDelegate : ThisObject:option<Expression> * TypeDefinition:Concrete<TypeDefinition> * Method:Concrete<Method> -> unit
    override this.VisitNewDelegate (a, b, c) = Option.iter this.VisitExpression a; (); ()
    /// .NET - Statement inside an expression. Result can be an identifier for a variable which is not explicitly defined inside the statement
    abstract VisitStatementExpr : Statement:Statement * Result:option<Id> -> unit
    override this.VisitStatementExpr (a, b) = this.VisitStatement a; Option.iter this.VisitId b
    /// .NET - F# let rec
    abstract VisitLetRec : Bindings:list<Id * Expression> * Body:Expression -> unit
    override this.VisitLetRec (a, b) = List.iter (fun (a, b) -> this.VisitId a; this.VisitExpression b) a; this.VisitExpression b
    /// .NET - F# record constructor
    abstract VisitNewRecord : TypeDefinition:Concrete<TypeDefinition> * Fields:list<Expression> -> unit
    override this.VisitNewRecord (a, b) = (); List.iter this.VisitExpression b
    /// .NET - F# union case constructor
    abstract VisitNewUnionCase : TypeDefinition:Concrete<TypeDefinition> * UnionCase:string * Fields:list<Expression> -> unit
    override this.VisitNewUnionCase (a, b, c) = (); (); List.iter this.VisitExpression c
    /// .NET - F# union case test
    abstract VisitUnionCaseTest : Expression:Expression * TypeDefinition:Concrete<TypeDefinition> * UnionCase:string -> unit
    override this.VisitUnionCaseTest (a, b, c) = this.VisitExpression a; (); ()
    /// .NET - F# union case field getter
    abstract VisitUnionCaseGet : Expression:Expression * TypeDefinition:Concrete<TypeDefinition> * UnionCase:string * Field:string -> unit
    override this.VisitUnionCaseGet (a, b, c, d) = this.VisitExpression a; (); (); ()
    /// .NET - F# union case tag getter
    abstract VisitUnionCaseTag : Expression:Expression * TypeDefinition:Concrete<TypeDefinition> -> unit
    override this.VisitUnionCaseTag (a, b) = this.VisitExpression a; ()
    /// .NET - F# successful match
    abstract VisitMatchSuccess : Index:int * Captures:list<Expression> -> unit
    override this.VisitMatchSuccess (a, b) = (); List.iter this.VisitExpression b
    /// .NET - Method call
    abstract VisitTraitCall : ThisObject:option<Expression> * ObjectType:list<Type> * Method:Concrete<Method> * Arguments:list<Expression> -> unit
    override this.VisitTraitCall (a, b, c, d) = Option.iter this.VisitExpression a; (); (); List.iter this.VisitExpression d
    /// Temporary - C# await expression
    abstract VisitAwait : Expression:Expression -> unit
    override this.VisitAwait a = (this.VisitExpression a)
    /// Temporary - C# named parameter
    abstract VisitNamedParameter : Ordinal:int * Expression:Expression -> unit
    override this.VisitNamedParameter (a, b) = (); this.VisitExpression b
    /// Temporary - C# ref or out parameter
    abstract VisitRefOrOutParameter : Expression:Expression -> unit
    override this.VisitRefOrOutParameter a = (this.VisitExpression a)
    /// Temporary - C# complex element in initializer expression
    abstract VisitComplexElement : Items:list<Expression> -> unit
    override this.VisitComplexElement a = (List.iter this.VisitExpression a)
    /// JavaSript object
    abstract VisitObject : Properties:list<string * MemberKind * Expression> -> unit
    override this.VisitObject a = (List.iter (fun (a, b, c) -> this.VisitExpression c) a)
    /// A global or imported value
    abstract VisitGlobalAccess : Address:Address -> unit
    override this.VisitGlobalAccess a = (())
    /// A global or imported value setter
    abstract VisitGlobalAccessSet : Address:Address * Value:Expression -> unit
    override this.VisitGlobalAccessSet (a, b) = (); this.VisitExpression b
    /// JavaScript 'new' call
    abstract VisitNew : Func:Expression * Param:list<TSType> * Arguments:list<Expression> -> unit
    override this.VisitNew (a, b, c) = this.VisitExpression a; (); List.iter this.VisitExpression c
    /// Temporary - A hole in an expression for inlining
    abstract VisitHole : Index:int -> unit
    override this.VisitHole a = (())
    /// TypeScript - type cast <...>...
    abstract VisitCast : TargetType:TSType * Expression:Expression -> unit
    override this.VisitCast (a, b) = (); this.VisitExpression b
    /// JavaScript - class { ... }
    abstract VisitClassExpr : ClassId:option<Id> * BaseClass:option<Expression> * Members:list<Statement> -> unit
    override this.VisitClassExpr (a, b, c) = Option.iter this.VisitId a; Option.iter this.VisitExpression b; List.iter this.VisitStatement c
    /// .NET - F# object expression
    abstract VisitObjectExpr : ObjectType:Type * Constructor:option<Expression> * Overrides:list<TypeDefinition * Method * Expression> -> unit
    override this.VisitObjectExpr (a, b, c) = (); Option.iter this.VisitExpression b; List.iter (fun (a, b, c) -> this.VisitExpression c) c
    /// Empty statement
    abstract VisitEmpty : unit -> unit
    override this.VisitEmpty () = ()
    /// JavaScript break statement
    abstract VisitBreak : Label:option<Id> -> unit
    override this.VisitBreak a = (Option.iter this.VisitId a)
    /// JavaScript continue statement
    abstract VisitContinue : Label:option<Id> -> unit
    override this.VisitContinue a = (Option.iter this.VisitId a)
    /// Expression as statement
    abstract VisitExprStatement : Expression:Expression -> unit
    override this.VisitExprStatement a = (this.VisitExpression a)
    /// Return a value
    abstract VisitReturn : Value:Expression -> unit
    override this.VisitReturn a = (this.VisitExpression a)
    /// Block of statements
    abstract VisitBlock : Statements:list<Statement> -> unit
    override this.VisitBlock a = (List.iter this.VisitStatement a)
    /// Variable declaration
    abstract VisitVarDeclaration : Variable:Id * Value:Expression -> unit
    override this.VisitVarDeclaration (a, b) = this.VisitId a; this.VisitExpression b
    /// Function declaration
    abstract VisitFuncDeclaration : FuncId:Id * Parameters:list<Id> * ThisVar:option<Id> * Body:Statement * Generics:list<TSType> -> unit
    override this.VisitFuncDeclaration (a, b, c, d, e) = this.VisitId a; List.iter this.VisitId b; Option.iter this.VisitId c; this.VisitStatement d; ()
    /// 'while' loop
    abstract VisitWhile : Condition:Expression * Body:Statement -> unit
    override this.VisitWhile (a, b) = this.VisitExpression a; this.VisitStatement b
    /// 'do..while' loop
    abstract VisitDoWhile : Body:Statement * Condition:Expression -> unit
    override this.VisitDoWhile (a, b) = this.VisitStatement a; this.VisitExpression b
    /// 'for' loop
    abstract VisitFor : Initializer:option<Expression> * Condition:option<Expression> * Step:option<Expression> * Body:Statement -> unit
    override this.VisitFor (a, b, c, d) = Option.iter this.VisitExpression a; Option.iter this.VisitExpression b; Option.iter this.VisitExpression c; this.VisitStatement d
    /// JavaScript 'for .. in' loop
    abstract VisitForIn : Variable:Id * Object:Expression * Body:Statement -> unit
    override this.VisitForIn (a, b, c) = this.VisitId a; this.VisitExpression b; this.VisitStatement c
    /// JavaScript 'switch' expression
    abstract VisitSwitch : Expression:Expression * Cases:list<option<Expression> * Statement> -> unit
    override this.VisitSwitch (a, b) = this.VisitExpression a; List.iter (fun (a, b) -> Option.iter this.VisitExpression a; this.VisitStatement b) b
    /// 'if' statement
    abstract VisitIf : Condition:Expression * ThenStatement:Statement * ElseStatement:Statement -> unit
    override this.VisitIf (a, b, c) = this.VisitExpression a; this.VisitStatement b; this.VisitStatement c
    /// 'throw' statement
    abstract VisitThrow : Expression:Expression -> unit
    override this.VisitThrow a = (this.VisitExpression a)
    /// 'try..with' statement
    abstract VisitTryWith : Body:Statement * Variable:option<Id> * CatchStatement:Statement -> unit
    override this.VisitTryWith (a, b, c) = this.VisitStatement a; Option.iter this.VisitId b; this.VisitStatement c
    /// 'try..finally' statement
    abstract VisitTryFinally : Body:Statement * FinallyStatement:Statement -> unit
    override this.VisitTryFinally (a, b) = this.VisitStatement a; this.VisitStatement b
    /// Statement with a label
    abstract VisitLabeled : Label:Id * Statement:Statement -> unit
    override this.VisitLabeled (a, b) = this.VisitId a; this.VisitStatement b
    /// Original source location for a statement
    abstract VisitStatementSourcePos : Range:SourcePos * Statement:Statement -> unit
    override this.VisitStatementSourcePos (a, b) = (); this.VisitStatement b
    /// Temporary - C# 'goto' statement
    abstract VisitGoto : Label:Id -> unit
    override this.VisitGoto a = (this.VisitId a)
    /// Temporary - go to next state in state-machine for iterators, async methods, or methods containing gotos
    abstract VisitContinuation : Label:Id * Expression:Expression -> unit
    override this.VisitContinuation (a, b) = this.VisitId a; this.VisitExpression b
    /// Temporary - C# 'yield return' statement
    abstract VisitYield : Value:option<Expression> -> unit
    override this.VisitYield a = (Option.iter this.VisitExpression a)
    /// Temporary - C# 'switch' statement
    abstract VisitCSharpSwitch : Expression:Expression * Cases:list<list<option<Expression>> * Statement> -> unit
    override this.VisitCSharpSwitch (a, b) = this.VisitExpression a; List.iter (fun (a, b) -> List.iter (Option.iter this.VisitExpression) a; this.VisitStatement b) b
    /// Temporary - C# 'goto case' statement
    abstract VisitGotoCase : CaseExpression:option<Expression> -> unit
    override this.VisitGotoCase a = (Option.iter this.VisitExpression a)
    /// .NET - F# tail call position
    abstract VisitDoNotReturn : unit -> unit
    override this.VisitDoNotReturn () = ()
    /// JavaScript - import * as ... from ...
    abstract VisitImport : DefaultImport:option<Id> * FullImport:option<Id> * NamedImports:list<string * Id> * ModuleName:string -> unit
    override this.VisitImport (a, b, c, d) = Option.iter this.VisitId a; Option.iter this.VisitId b; List.iter (fun (a, b) -> this.VisitId b) c; ()
    /// JavaScript - export
    abstract VisitExportDecl : IsDefault:bool * Statement:Statement -> unit
    override this.VisitExportDecl (a, b) = (); this.VisitStatement b
    /// TypeScript - declare ...
    abstract VisitDeclare : Statement:Statement -> unit
    override this.VisitDeclare a = (this.VisitStatement a)
    /// TypeScript - namespace { ... }
    abstract VisitNamespace : Name:string * Statements:list<Statement> -> unit
    override this.VisitNamespace (a, b) = (); List.iter this.VisitStatement b
    /// JavaScript - class { ... }
    abstract VisitClass : ClassId:Id * BaseClass:option<Expression> * Implementations:list<TSType> * Members:list<Statement> * Generics:list<TSType> -> unit
    override this.VisitClass (a, b, c, d, e) = this.VisitId a; Option.iter this.VisitExpression b; (); List.iter this.VisitStatement d; ()
    /// JavaScript - class method
    abstract VisitClassMethod : Info:ClassMethodInfo * Name:string * Parameters:list<Id> * ThisVar:option<Id> * Body:option<Statement> * Signature:TSType -> unit
    override this.VisitClassMethod (a, b, c, d, e, f) = (); (); List.iter this.VisitId c; Option.iter this.VisitId d; Option.iter this.VisitStatement e; ()
    /// JavaScript - class method
    abstract VisitClassConstructor : Parameters:list<Id * Modifiers> * ThisVar:option<Id> * Body:option<Statement> * Signature:TSType -> unit
    override this.VisitClassConstructor (a, b, c, d) = List.iter (fst >> this.VisitId) a; Option.iter this.VisitId b; Option.iter this.VisitStatement c; ()
    /// JavaScript - class plain property
    abstract VisitClassProperty : Info:ClassPropertyInfo * Name:string * PropertyType:TSType * Value:option<Expression> -> unit
    override this.VisitClassProperty (a, b, c, d) = (); (); (); Option.iter this.VisitExpression d
    /// JavaScript - class static block
    abstract VisitClassStatic : Optional:Statement -> unit
    override this.VisitClassStatic a = (this.VisitStatement a)
    /// TypeScript - interface { ... }
    abstract VisitInterface : Name:string * Extending:list<TSType> * Members:list<Statement> * Generics:list<TSType> -> unit
    override this.VisitInterface (a, b, c, d) = (); (); List.iter this.VisitStatement c; ()
    /// TypeScript - type or import alias
    abstract VisitAlias : Alias:TSType * OrigType:TSType -> unit
    override this.VisitAlias (a, b) = (); ()
    /// TypeScript - triple-slash directive
    abstract VisitXmlComment : Xml:string -> unit
    override this.VisitXmlComment a = (())
    abstract VisitExpression : Expression -> unit
    override this.VisitExpression x =
        match x with
        | Undefined  -> this.VisitUndefined ()
        | Var a -> this.VisitVar a
        | Value a -> this.VisitValue a
        | Application (a, b, c) -> this.VisitApplication (a, b, c)
        | Function (a, b, c, d) -> this.VisitFunction (a, b, c, d)
        | VarSet (a, b) -> this.VisitVarSet (a, b)
        | Sequential a -> this.VisitSequential a
        | NewTuple (a, b) -> this.VisitNewTuple (a, b)
        | Conditional (a, b, c) -> this.VisitConditional (a, b, c)
        | ItemGet (a, b, c) -> this.VisitItemGet (a, b, c)
        | ItemSet (a, b, c) -> this.VisitItemSet (a, b, c)
        | Binary (a, b, c) -> this.VisitBinary (a, b, c)
        | MutatingBinary (a, b, c) -> this.VisitMutatingBinary (a, b, c)
        | Unary (a, b) -> this.VisitUnary (a, b)
        | MutatingUnary (a, b) -> this.VisitMutatingUnary (a, b)
        | ExprSourcePos (a, b) -> this.VisitExprSourcePos (a, b)
        | JSThis  -> this.VisitJSThis ()
        | Base  -> this.VisitBase ()
        | Call (a, b, c, d) -> this.VisitCall (a, b, c, d)
        | CallNeedingMoreArgs (a, b, c, d) -> this.VisitCallNeedingMoreArgs (a, b, c, d)
        | CurriedApplication (a, b) -> this.VisitCurriedApplication (a, b)
        | OptimizedFSharpArg (a, b) -> this.VisitOptimizedFSharpArg (a, b)
        | Ctor (a, b, c) -> this.VisitCtor (a, b, c)
        | ChainedCtor (a, b, c, d) -> this.VisitChainedCtor (a, b, c, d)
        | CopyCtor (a, b) -> this.VisitCopyCtor (a, b)
        | FieldGet (a, b, c) -> this.VisitFieldGet (a, b, c)
        | FieldSet (a, b, c, d) -> this.VisitFieldSet (a, b, c, d)
        | Let (a, b, c) -> this.VisitLet (a, b, c)
        | NewVar (a, b) -> this.VisitNewVar (a, b)
        | Coalesce (a, b, c) -> this.VisitCoalesce (a, b, c)
        | TypeCheck (a, b) -> this.VisitTypeCheck (a, b)
        | Coerce (a, b, c) -> this.VisitCoerce (a, b, c)
        | NewDelegate (a, b, c) -> this.VisitNewDelegate (a, b, c)
        | StatementExpr (a, b) -> this.VisitStatementExpr (a, b)
        | LetRec (a, b) -> this.VisitLetRec (a, b)
        | NewRecord (a, b) -> this.VisitNewRecord (a, b)
        | NewUnionCase (a, b, c) -> this.VisitNewUnionCase (a, b, c)
        | UnionCaseTest (a, b, c) -> this.VisitUnionCaseTest (a, b, c)
        | UnionCaseGet (a, b, c, d) -> this.VisitUnionCaseGet (a, b, c, d)
        | UnionCaseTag (a, b) -> this.VisitUnionCaseTag (a, b)
        | MatchSuccess (a, b) -> this.VisitMatchSuccess (a, b)
        | TraitCall (a, b, c, d) -> this.VisitTraitCall (a, b, c, d)
        | Await a -> this.VisitAwait a
        | NamedParameter (a, b) -> this.VisitNamedParameter (a, b)
        | RefOrOutParameter a -> this.VisitRefOrOutParameter a
        | ComplexElement a -> this.VisitComplexElement a
        | Object a -> this.VisitObject a
        | GlobalAccess a -> this.VisitGlobalAccess a
        | GlobalAccessSet (a, b) -> this.VisitGlobalAccessSet (a, b)
        | New (a, b, c) -> this.VisitNew (a, b, c)
        | Hole a -> this.VisitHole a
        | Cast (a, b) -> this.VisitCast (a, b)
        | ClassExpr (a, b, c) -> this.VisitClassExpr (a, b, c)
        | ObjectExpr (a, b, c) -> this.VisitObjectExpr (a, b, c)
    abstract VisitStatement : Statement -> unit
    override this.VisitStatement x =
        match x with
        | Empty  -> this.VisitEmpty ()
        | Break a -> this.VisitBreak a
        | Continue a -> this.VisitContinue a
        | ExprStatement a -> this.VisitExprStatement a
        | Return a -> this.VisitReturn a
        | Block a -> this.VisitBlock a
        | VarDeclaration (a, b) -> this.VisitVarDeclaration (a, b)
        | FuncDeclaration (a, b, c, d, e) -> this.VisitFuncDeclaration (a, b, c, d, e)
        | While (a, b) -> this.VisitWhile (a, b)
        | DoWhile (a, b) -> this.VisitDoWhile (a, b)
        | For (a, b, c, d) -> this.VisitFor (a, b, c, d)
        | ForIn (a, b, c) -> this.VisitForIn (a, b, c)
        | Switch (a, b) -> this.VisitSwitch (a, b)
        | If (a, b, c) -> this.VisitIf (a, b, c)
        | Throw a -> this.VisitThrow a
        | TryWith (a, b, c) -> this.VisitTryWith (a, b, c)
        | TryFinally (a, b) -> this.VisitTryFinally (a, b)
        | Labeled (a, b) -> this.VisitLabeled (a, b)
        | StatementSourcePos (a, b) -> this.VisitStatementSourcePos (a, b)
        | Goto a -> this.VisitGoto a
        | Continuation (a, b) -> this.VisitContinuation (a, b)
        | Yield a -> this.VisitYield a
        | CSharpSwitch (a, b) -> this.VisitCSharpSwitch (a, b)
        | GotoCase a -> this.VisitGotoCase a
        | DoNotReturn  -> this.VisitDoNotReturn ()
        | Import (a, b, c, d) -> this.VisitImport (a, b, c, d)
        | ExportDecl (a, b) -> this.VisitExportDecl (a, b)
        | Declare a -> this.VisitDeclare a
        | Namespace (a, b) -> this.VisitNamespace (a, b)
        | Class (a, b, c, d, e) -> this.VisitClass (a, b, c, d, e)
        | ClassMethod (a, b, c, d, e, f) -> this.VisitClassMethod (a, b, c, d, e, f)
        | ClassConstructor (a, b, c, d) -> this.VisitClassConstructor (a, b, c, d)
        | ClassProperty (a, b, c, d) -> this.VisitClassProperty (a, b, c, d)
        | ClassStatic a -> this.VisitClassStatic a
        | Interface (a, b, c, d) -> this.VisitInterface (a, b, c, d)
        | Alias (a, b) -> this.VisitAlias (a, b)
        | XmlComment a -> this.VisitXmlComment a
    /// Identifier for variable or label
    abstract VisitId : Id -> unit
    override this.VisitId x = ()
module IgnoreSourcePos =
    let ignoreExprSourcePos expr =
        match expr with
        | ExprSourcePos (_, e) -> e
        | _ -> expr
    let (|Undefined|_|) x = match ignoreExprSourcePos x with Undefined  -> Some () | _ -> None
    let (|Var|_|) x = match ignoreExprSourcePos x with Var a -> Some a | _ -> None
    let (|Value|_|) x = match ignoreExprSourcePos x with Value a -> Some a | _ -> None
    let (|Application|_|) x = match ignoreExprSourcePos x with Application (a, b, c) -> Some (a, b, c) | _ -> None
    let (|Function|_|) x = match ignoreExprSourcePos x with Function (a, b, c, d) -> Some (a, b, c, d) | _ -> None
    let (|VarSet|_|) x = match ignoreExprSourcePos x with VarSet (a, b) -> Some (a, b) | _ -> None
    let (|Sequential|_|) x = match ignoreExprSourcePos x with Sequential a -> Some a | _ -> None
    let (|NewTuple|_|) x = match ignoreExprSourcePos x with NewTuple (a, b) -> Some (a, b) | _ -> None
    let (|Conditional|_|) x = match ignoreExprSourcePos x with Conditional (a, b, c) -> Some (a, b, c) | _ -> None
    let (|ItemGet|_|) x = match ignoreExprSourcePos x with ItemGet (a, b, c) -> Some (a, b, c) | _ -> None
    let (|ItemSet|_|) x = match ignoreExprSourcePos x with ItemSet (a, b, c) -> Some (a, b, c) | _ -> None
    let (|Binary|_|) x = match ignoreExprSourcePos x with Binary (a, b, c) -> Some (a, b, c) | _ -> None
    let (|MutatingBinary|_|) x = match ignoreExprSourcePos x with MutatingBinary (a, b, c) -> Some (a, b, c) | _ -> None
    let (|Unary|_|) x = match ignoreExprSourcePos x with Unary (a, b) -> Some (a, b) | _ -> None
    let (|MutatingUnary|_|) x = match ignoreExprSourcePos x with MutatingUnary (a, b) -> Some (a, b) | _ -> None
    let (|ExprSourcePos|_|) x = match ignoreExprSourcePos x with ExprSourcePos (a, b) -> Some (a, b) | _ -> None
    let (|JSThis|_|) x = match ignoreExprSourcePos x with JSThis  -> Some () | _ -> None
    let (|Base|_|) x = match ignoreExprSourcePos x with Base  -> Some () | _ -> None
    let (|Call|_|) x = match ignoreExprSourcePos x with Call (a, b, c, d) -> Some (a, b, c, d) | _ -> None
    let (|CallNeedingMoreArgs|_|) x = match ignoreExprSourcePos x with CallNeedingMoreArgs (a, b, c, d) -> Some (a, b, c, d) | _ -> None
    let (|CurriedApplication|_|) x = match ignoreExprSourcePos x with CurriedApplication (a, b) -> Some (a, b) | _ -> None
    let (|OptimizedFSharpArg|_|) x = match ignoreExprSourcePos x with OptimizedFSharpArg (a, b) -> Some (a, b) | _ -> None
    let (|Ctor|_|) x = match ignoreExprSourcePos x with Ctor (a, b, c) -> Some (a, b, c) | _ -> None
    let (|ChainedCtor|_|) x = match ignoreExprSourcePos x with ChainedCtor (a, b, c, d) -> Some (a, b, c, d) | _ -> None
    let (|CopyCtor|_|) x = match ignoreExprSourcePos x with CopyCtor (a, b) -> Some (a, b) | _ -> None
    let (|FieldGet|_|) x = match ignoreExprSourcePos x with FieldGet (a, b, c) -> Some (a, b, c) | _ -> None
    let (|FieldSet|_|) x = match ignoreExprSourcePos x with FieldSet (a, b, c, d) -> Some (a, b, c, d) | _ -> None
    let (|Let|_|) x = match ignoreExprSourcePos x with Let (a, b, c) -> Some (a, b, c) | _ -> None
    let (|NewVar|_|) x = match ignoreExprSourcePos x with NewVar (a, b) -> Some (a, b) | _ -> None
    let (|Coalesce|_|) x = match ignoreExprSourcePos x with Coalesce (a, b, c) -> Some (a, b, c) | _ -> None
    let (|TypeCheck|_|) x = match ignoreExprSourcePos x with TypeCheck (a, b) -> Some (a, b) | _ -> None
    let (|Coerce|_|) x = match ignoreExprSourcePos x with Coerce (a, b, c) -> Some (a, b, c) | _ -> None
    let (|NewDelegate|_|) x = match ignoreExprSourcePos x with NewDelegate (a, b, c) -> Some (a, b, c) | _ -> None
    let (|StatementExpr|_|) x = match ignoreExprSourcePos x with StatementExpr (a, b) -> Some (a, b) | _ -> None
    let (|LetRec|_|) x = match ignoreExprSourcePos x with LetRec (a, b) -> Some (a, b) | _ -> None
    let (|NewRecord|_|) x = match ignoreExprSourcePos x with NewRecord (a, b) -> Some (a, b) | _ -> None
    let (|NewUnionCase|_|) x = match ignoreExprSourcePos x with NewUnionCase (a, b, c) -> Some (a, b, c) | _ -> None
    let (|UnionCaseTest|_|) x = match ignoreExprSourcePos x with UnionCaseTest (a, b, c) -> Some (a, b, c) | _ -> None
    let (|UnionCaseGet|_|) x = match ignoreExprSourcePos x with UnionCaseGet (a, b, c, d) -> Some (a, b, c, d) | _ -> None
    let (|UnionCaseTag|_|) x = match ignoreExprSourcePos x with UnionCaseTag (a, b) -> Some (a, b) | _ -> None
    let (|MatchSuccess|_|) x = match ignoreExprSourcePos x with MatchSuccess (a, b) -> Some (a, b) | _ -> None
    let (|TraitCall|_|) x = match ignoreExprSourcePos x with TraitCall (a, b, c, d) -> Some (a, b, c, d) | _ -> None
    let (|Await|_|) x = match ignoreExprSourcePos x with Await a -> Some a | _ -> None
    let (|NamedParameter|_|) x = match ignoreExprSourcePos x with NamedParameter (a, b) -> Some (a, b) | _ -> None
    let (|RefOrOutParameter|_|) x = match ignoreExprSourcePos x with RefOrOutParameter a -> Some a | _ -> None
    let (|ComplexElement|_|) x = match ignoreExprSourcePos x with ComplexElement a -> Some a | _ -> None
    let (|Object|_|) x = match ignoreExprSourcePos x with Object a -> Some a | _ -> None
    let (|GlobalAccess|_|) x = match ignoreExprSourcePos x with GlobalAccess a -> Some a | _ -> None
    let (|GlobalAccessSet|_|) x = match ignoreExprSourcePos x with GlobalAccessSet (a, b) -> Some (a, b) | _ -> None
    let (|New|_|) x = match ignoreExprSourcePos x with New (a, b, c) -> Some (a, b, c) | _ -> None
    let (|Hole|_|) x = match ignoreExprSourcePos x with Hole a -> Some a | _ -> None
    let (|Cast|_|) x = match ignoreExprSourcePos x with Cast (a, b) -> Some (a, b) | _ -> None
    let (|ClassExpr|_|) x = match ignoreExprSourcePos x with ClassExpr (a, b, c) -> Some (a, b, c) | _ -> None
    let (|ObjectExpr|_|) x = match ignoreExprSourcePos x with ObjectExpr (a, b, c) -> Some (a, b, c) | _ -> None
    let ignoreStatementSourcePos expr =
        match expr with
        | StatementSourcePos (_, e) -> e
        | _ -> expr
    let (|Empty|_|) x = match ignoreStatementSourcePos x with Empty  -> Some () | _ -> None
    let (|Break|_|) x = match ignoreStatementSourcePos x with Break a -> Some a | _ -> None
    let (|Continue|_|) x = match ignoreStatementSourcePos x with Continue a -> Some a | _ -> None
    let (|ExprStatement|_|) x = match ignoreStatementSourcePos x with ExprStatement a -> Some a | _ -> None
    let (|Return|_|) x = match ignoreStatementSourcePos x with Return a -> Some a | _ -> None
    let (|Block|_|) x = match ignoreStatementSourcePos x with Block a -> Some a | _ -> None
    let (|VarDeclaration|_|) x = match ignoreStatementSourcePos x with VarDeclaration (a, b) -> Some (a, b) | _ -> None
    let (|FuncDeclaration|_|) x = match ignoreStatementSourcePos x with FuncDeclaration (a, b, c, d, e) -> Some (a, b, c, d, e) | _ -> None
    let (|While|_|) x = match ignoreStatementSourcePos x with While (a, b) -> Some (a, b) | _ -> None
    let (|DoWhile|_|) x = match ignoreStatementSourcePos x with DoWhile (a, b) -> Some (a, b) | _ -> None
    let (|For|_|) x = match ignoreStatementSourcePos x with For (a, b, c, d) -> Some (a, b, c, d) | _ -> None
    let (|ForIn|_|) x = match ignoreStatementSourcePos x with ForIn (a, b, c) -> Some (a, b, c) | _ -> None
    let (|Switch|_|) x = match ignoreStatementSourcePos x with Switch (a, b) -> Some (a, b) | _ -> None
    let (|If|_|) x = match ignoreStatementSourcePos x with If (a, b, c) -> Some (a, b, c) | _ -> None
    let (|Throw|_|) x = match ignoreStatementSourcePos x with Throw a -> Some a | _ -> None
    let (|TryWith|_|) x = match ignoreStatementSourcePos x with TryWith (a, b, c) -> Some (a, b, c) | _ -> None
    let (|TryFinally|_|) x = match ignoreStatementSourcePos x with TryFinally (a, b) -> Some (a, b) | _ -> None
    let (|Labeled|_|) x = match ignoreStatementSourcePos x with Labeled (a, b) -> Some (a, b) | _ -> None
    let (|StatementSourcePos|_|) x = match ignoreStatementSourcePos x with StatementSourcePos (a, b) -> Some (a, b) | _ -> None
    let (|Goto|_|) x = match ignoreStatementSourcePos x with Goto a -> Some a | _ -> None
    let (|Continuation|_|) x = match ignoreStatementSourcePos x with Continuation (a, b) -> Some (a, b) | _ -> None
    let (|Yield|_|) x = match ignoreStatementSourcePos x with Yield a -> Some a | _ -> None
    let (|CSharpSwitch|_|) x = match ignoreStatementSourcePos x with CSharpSwitch (a, b) -> Some (a, b) | _ -> None
    let (|GotoCase|_|) x = match ignoreStatementSourcePos x with GotoCase a -> Some a | _ -> None
    let (|DoNotReturn|_|) x = match ignoreStatementSourcePos x with DoNotReturn  -> Some () | _ -> None
    let (|Import|_|) x = match ignoreStatementSourcePos x with Import (a, b, c, d) -> Some (a, b, c, d) | _ -> None
    let (|ExportDecl|_|) x = match ignoreStatementSourcePos x with ExportDecl (a, b) -> Some (a, b) | _ -> None
    let (|Declare|_|) x = match ignoreStatementSourcePos x with Declare a -> Some a | _ -> None
    let (|Namespace|_|) x = match ignoreStatementSourcePos x with Namespace (a, b) -> Some (a, b) | _ -> None
    let (|Class|_|) x = match ignoreStatementSourcePos x with Class (a, b, c, d, e) -> Some (a, b, c, d, e) | _ -> None
    let (|ClassMethod|_|) x = match ignoreStatementSourcePos x with ClassMethod (a, b, c, d, e, f) -> Some (a, b, c, d, e, f) | _ -> None
    let (|ClassConstructor|_|) x = match ignoreStatementSourcePos x with ClassConstructor (a, b, c, d) -> Some (a, b, c, d) | _ -> None
    let (|ClassProperty|_|) x = match ignoreStatementSourcePos x with ClassProperty (a, b, c, d) -> Some (a, b, c, d) | _ -> None
    let (|ClassStatic|_|) x = match ignoreStatementSourcePos x with ClassStatic a -> Some a | _ -> None
    let (|Interface|_|) x = match ignoreStatementSourcePos x with Interface (a, b, c, d) -> Some (a, b, c, d) | _ -> None
    let (|Alias|_|) x = match ignoreStatementSourcePos x with Alias (a, b) -> Some (a, b) | _ -> None
    let (|XmlComment|_|) x = match ignoreStatementSourcePos x with XmlComment a -> Some a | _ -> None
module Debug =
    let private PrintTypeDefinition (x:Concrete<TypeDefinition>) = x.Entity.Value.FullName + match x.Generics with [] -> "" | g -> (g |> List.map string |> String.concat ", ")
    let private PrintMethod (x:Concrete<Method>) = x.Entity.Value.MethodName + match x.Generics with [] -> "" | g -> (g |> List.map string |> String.concat ", ")
    let rec PrintExpression x =
        match x with
        | Undefined  -> "Undefined" + ""
        | Var a -> "Var" + "(" + string a + ")"
        | Value a -> "Value" + "(" + string a.Value + ")"
        | Application (a, b, c) -> "Application" + "(" + PrintExpression a + ", " + "[" + String.concat "; " (List.map PrintExpression b) + "]" + ", " + string c + ")"
        | Function (a, b, c, d) -> "Function" + "(" + "[" + String.concat "; " (List.map string a) + "]" + ", " + defaultArg (Option.map string b) "_" + ", " + defaultArg (Option.map string c) "_" + ", " + PrintStatement d + ")"
        | VarSet (a, b) -> "VarSet" + "(" + string a + ", " + PrintExpression b + ")"
        | Sequential a -> "Sequential" + "(" + "[" + String.concat "; " (List.map PrintExpression a) + "]" + ")"
        | NewTuple (a, b) -> "NewTuple" + "(" + "[" + String.concat "; " (List.map PrintExpression a) + "]" + ", " + "[" + String.concat "; " (List.map string b) + "]" + ")"
        | Conditional (a, b, c) -> "Conditional" + "(" + PrintExpression a + ", " + PrintExpression b + ", " + PrintExpression c + ")"
        | ItemGet (a, b, c) -> "ItemGet" + "(" + PrintExpression a + ", " + PrintExpression b + ", " + string c + ")"
        | ItemSet (a, b, c) -> "ItemSet" + "(" + PrintExpression a + ", " + PrintExpression b + ", " + PrintExpression c + ")"
        | Binary (a, b, c) -> "Binary" + "(" + PrintExpression a + ", " + string b + ", " + PrintExpression c + ")"
        | MutatingBinary (a, b, c) -> "MutatingBinary" + "(" + PrintExpression a + ", " + string b + ", " + PrintExpression c + ")"
        | Unary (a, b) -> "Unary" + "(" + string a + ", " + PrintExpression b + ")"
        | MutatingUnary (a, b) -> "MutatingUnary" + "(" + string a + ", " + PrintExpression b + ")"
        | ExprSourcePos (_, b) -> PrintExpression b
        | JSThis  -> "JSThis" + ""
        | Base  -> "Base" + ""
        | Call (a, b, c, d) -> "Call" + "(" + defaultArg (Option.map PrintExpression a) "_" + ", " + PrintTypeDefinition b + ", " + PrintMethod c + ", " + "[" + String.concat "; " (List.map PrintExpression d) + "]" + ")"
        | CallNeedingMoreArgs (a, b, c, d) -> "CallNeedingMoreArgs" + "(" + defaultArg (Option.map PrintExpression a) "_" + ", " + PrintTypeDefinition b + ", " + PrintMethod c + ", " + "[" + String.concat "; " (List.map PrintExpression d) + "]" + ")"
        | CurriedApplication (a, b) -> "CurriedApplication" + "(" + PrintExpression a + ", " + "[" + String.concat "; " (List.map (fun (a, b) -> string a + ", " + PrintExpression b) b) + "]" + ")"
        | OptimizedFSharpArg (a, b) -> "OptimizedFSharpArg" + "(" + PrintExpression a + ", " + string b + ")"
        | Ctor (a, b, c) -> "Ctor" + "(" + PrintTypeDefinition a + ", " + ".ctor" + ", " + "[" + String.concat "; " (List.map PrintExpression c) + "]" + ")"
        | ChainedCtor (a, b, c, d) -> "ChainedCtor" + "(" + string a + ", " + PrintTypeDefinition b + ", " + ".ctor" + ", " + "[" + String.concat "; " (List.map PrintExpression d) + "]" + ")"
        | CopyCtor (a, b) -> "CopyCtor" + "(" + a.Value.FullName + ", " + PrintExpression b + ")"
        | FieldGet (a, b, c) -> "FieldGet" + "(" + defaultArg (Option.map PrintExpression a) "_" + ", " + PrintTypeDefinition b + ", " + string c + ")"
        | FieldSet (a, b, c, d) -> "FieldSet" + "(" + defaultArg (Option.map PrintExpression a) "_" + ", " + PrintTypeDefinition b + ", " + string c + ", " + PrintExpression d + ")"
        | Let (a, b, c) -> "Let" + "(" + string a + ", " + PrintExpression b + ", " + PrintExpression c + ")"
        | NewVar (a, b) -> "NewVar" + "(" + string a + ", " + PrintExpression b + ")"
        | Coalesce (a, b, c) -> "Coalesce" + "(" + PrintExpression a + ", " + string b + ", " + PrintExpression c + ")"
        | TypeCheck (a, b) -> "TypeCheck" + "(" + PrintExpression a + ", " + string b + ")"
        | Coerce (a, b, c) -> "Coerce" + "(" + PrintExpression a + ", " + string b + ", " + string c + ")"
        | NewDelegate (a, b, c) -> "NewDelegate" + "(" + defaultArg (Option.map PrintExpression a) "_" + ", " + PrintTypeDefinition b + ", " + PrintMethod c + ")"
        | StatementExpr (a, b) -> "StatementExpr" + "(" + PrintStatement a + ", " + defaultArg (Option.map string b) "_" + ")"
        | LetRec (a, b) -> "LetRec" + "(" + "[" + String.concat "; " (List.map (fun (a, b) -> string a + ", " + PrintExpression b) a) + "]" + ", " + PrintExpression b + ")"
        | NewRecord (a, b) -> "NewRecord" + "(" + PrintTypeDefinition a + ", " + "[" + String.concat "; " (List.map PrintExpression b) + "]" + ")"
        | NewUnionCase (a, b, c) -> "NewUnionCase" + "(" + PrintTypeDefinition a + ", " + string b + ", " + "[" + String.concat "; " (List.map PrintExpression c) + "]" + ")"
        | UnionCaseTest (a, b, c) -> "UnionCaseTest" + "(" + PrintExpression a + ", " + PrintTypeDefinition b + ", " + string c + ")"
        | UnionCaseGet (a, b, c, d) -> "UnionCaseGet" + "(" + PrintExpression a + ", " + PrintTypeDefinition b + ", " + string c + ", " + string d + ")"
        | UnionCaseTag (a, b) -> "UnionCaseTag" + "(" + PrintExpression a + ", " + PrintTypeDefinition b + ")"
        | MatchSuccess (a, b) -> "MatchSuccess" + "(" + string a + ", " + "[" + String.concat "; " (List.map PrintExpression b) + "]" + ")"
        | TraitCall (a, b, c, d) -> "TraitCall" + "(" + defaultArg (Option.map PrintExpression a) "_" + ", " + "[" + String.concat "; " (List.map string b) + "]" + ", " + PrintMethod c + ", " + "[" + String.concat "; " (List.map PrintExpression d) + "]" + ")"
        | Await a -> "Await" + "(" + PrintExpression a + ")"
        | NamedParameter (a, b) -> "NamedParameter" + "(" + string a + ", " + PrintExpression b + ")"
        | RefOrOutParameter a -> "RefOrOutParameter" + "(" + PrintExpression a + ")"
        | ComplexElement a -> "ComplexElement" + "(" + "[" + String.concat "; " (List.map PrintExpression a) + "]" + ")"
        | Object a -> "Object" + "(" + "[" + String.concat "; " (List.map (fun (a, b, c) -> string a + ", " + string b + ", " + PrintExpression c) a) + "]" + ")"
        | GlobalAccess a -> "GlobalAccess" + "(" + string a + ")"
        | GlobalAccessSet (a, b) -> "GlobalAccessSet" + "(" + string a + ", " + PrintExpression b + ")"
        | New (a, b, c) -> "New" + "(" + PrintExpression a + ", " + "[" + String.concat "; " (List.map string b) + "]" + ", " + "[" + String.concat "; " (List.map PrintExpression c) + "]" + ")"
        | Hole a -> "Hole" + "(" + string a + ")"
        | Cast (a, b) -> "Cast" + "(" + string a + ", " + PrintExpression b + ")"
        | ClassExpr (a, b, c) -> "ClassExpr" + "(" + defaultArg (Option.map string a) "_" + ", " + defaultArg (Option.map PrintExpression b) "_" + ", " + "[" + String.concat "; " (List.map PrintStatement c) + "]" + ")"
        | ObjectExpr (a, b, c) -> "ObjectExpr" + "(" + string a + ", " + defaultArg (Option.map PrintExpression b) "_" + ", " + "[" + String.concat "; " (List.map (fun (a, b, c) -> string a + ", " + string b + ", " + PrintExpression c) c) + "]" + ")"
    and PrintStatement x =
        match x with
        | Empty  -> "Empty" + ""
        | Break a -> "Break" + "(" + defaultArg (Option.map string a) "_" + ")"
        | Continue a -> "Continue" + "(" + defaultArg (Option.map string a) "_" + ")"
        | ExprStatement a -> "ExprStatement" + "(" + PrintExpression a + ")"
        | Return a -> "Return" + "(" + PrintExpression a + ")"
        | Block a -> "Block" + "(" + "[" + String.concat "; " (List.map PrintStatement a) + "]" + ")"
        | VarDeclaration (a, b) -> "VarDeclaration" + "(" + string a + ", " + PrintExpression b + ")"
        | FuncDeclaration (a, b, c, d, e) -> "FuncDeclaration" + "(" + string a + ", " + "[" + String.concat "; " (List.map string b) + "]" + ", " + defaultArg (Option.map string c) "_" + ", " + PrintStatement d + ", " + "[" + String.concat "; " (List.map string e) + "]" + ")"
        | While (a, b) -> "While" + "(" + PrintExpression a + ", " + PrintStatement b + ")"
        | DoWhile (a, b) -> "DoWhile" + "(" + PrintStatement a + ", " + PrintExpression b + ")"
        | For (a, b, c, d) -> "For" + "(" + defaultArg (Option.map PrintExpression a) "_" + ", " + defaultArg (Option.map PrintExpression b) "_" + ", " + defaultArg (Option.map PrintExpression c) "_" + ", " + PrintStatement d + ")"
        | ForIn (a, b, c) -> "ForIn" + "(" + string a + ", " + PrintExpression b + ", " + PrintStatement c + ")"
        | Switch (a, b) -> "Switch" + "(" + PrintExpression a + ", " + "[" + String.concat "; " (List.map (fun (a, b) -> defaultArg (Option.map PrintExpression a) "_" + ", " + PrintStatement b) b) + "]" + ")"
        | If (a, b, c) -> "If" + "(" + PrintExpression a + ", " + PrintStatement b + ", " + PrintStatement c + ")"
        | Throw a -> "Throw" + "(" + PrintExpression a + ")"
        | TryWith (a, b, c) -> "TryWith" + "(" + PrintStatement a + ", " + defaultArg (Option.map string b) "_" + ", " + PrintStatement c + ")"
        | TryFinally (a, b) -> "TryFinally" + "(" + PrintStatement a + ", " + PrintStatement b + ")"
        | Labeled (a, b) -> "Labeled" + "(" + string a + ", " + PrintStatement b + ")"
        | StatementSourcePos (_, b) -> PrintStatement b
        | Goto a -> "Goto" + "(" + string a + ")"
        | Continuation (a, b) -> "Continuation" + "(" + string a + ", " + PrintExpression b + ")"
        | Yield a -> "Yield" + "(" + defaultArg (Option.map PrintExpression a) "_" + ")"
        | CSharpSwitch (a, b) -> "CSharpSwitch" + "(" + PrintExpression a + ", " + "[" + String.concat "; " (List.map (fun (a, b) -> "[" + String.concat "; " (List.map (fun aa -> defaultArg (Option.map PrintExpression aa) "_") a) + "], " + PrintStatement b) b) + "]" + ")"
        | GotoCase a -> "GotoCase" + "(" + defaultArg (Option.map PrintExpression a) "_" + ")"
        | DoNotReturn  -> "DoNotReturn" + ""
        | Import (a, b, c, d) -> "Import" + "(" + defaultArg (Option.map string a) "_" + ", " + defaultArg (Option.map string b) "_" + ", " + "[" + String.concat "; " (List.map (fun (a, b) -> string a + ", " + string b) c) + "]" + ", " + string d + ")"
        | ExportDecl (a, b) -> "ExportDecl" + "(" + string a + ", " + PrintStatement b + ")"
        | Declare a -> "Declare" + "(" + PrintStatement a + ")"
        | Namespace (a, b) -> "Namespace" + "(" + string a + ", " + "[" + String.concat "; " (List.map PrintStatement b) + "]" + ")"
        | Class (a, b, c, d, e) -> "Class" + "(" + string a + ", " + defaultArg (Option.map PrintExpression b) "_" + ", " + "[" + String.concat "; " (List.map string c) + "]" + ", " + "[" + String.concat "; " (List.map PrintStatement d) + "]" + ", " + "[" + String.concat "; " (List.map string e) + "]" + ")"
        | ClassMethod (a, b, c, d, e, f) -> "ClassMethod" + "(" + string a + ", " + string b + ", " + "[" + String.concat "; " (List.map string c) + "]" + ", " + defaultArg (Option.map string d) "_" + ", " + defaultArg (Option.map PrintStatement e) "" + ", " + string f + ")"
        | ClassConstructor (a, b, c, d) -> "ClassConstructor" + "(" + "[" + String.concat "; " (a |> List.map (fun (i, m) -> i.ToString m)) + "]" + ", " + defaultArg (Option.map string b) "_" + ", " + defaultArg (Option.map PrintStatement c) "" + ", " + string d + ")"
        | ClassProperty (a, b, c, d) -> "ClassProperty" + "(" + string a + ", " + string b + ", " + string c + ", " + defaultArg (Option.map PrintExpression d) "_" + ")"
        | ClassStatic a -> "ClassStatic" + "(" + PrintStatement a + ")"
        | Interface (a, b, c, d) -> "Interface" + "(" + string a + ", " + "[" + String.concat "; " (List.map string b) + "]" + ", " + "[" + String.concat "; " (List.map PrintStatement c) + "]" + ", " + "[" + String.concat "; " (List.map string d) + "]" + ")"
        | Alias (a, b) -> "Alias" + "(" + string a + ", " + string b + ")"
        | XmlComment a -> "XmlComment" + "(" + string a + ")"
// }}

    let PrintExpressionWithPos x =
        match x with
        | ExprSourcePos (a, b) -> 
            sprintf "%s @ (%d:%d-%d:%d)" (PrintExpression b) (fst a.Start) (snd a.Start) (fst a.End) (snd a.End)
        | _ -> PrintExpression x

/// A transformer base class that skips expression forms
type StatementTransformer() =
    inherit Transformer()

    override this.TransformExpression(a) = a

/// A visitor base class that skips expression forms
type StatementVisitor() =
    inherit Visitor()

    override this.VisitExpression(_) = ()

module ClassMethodInfo =
    let SimpleStatic =
        {
            IsStatic = true
            IsPrivate = false
            Kind = MemberKind.Simple
        }

    let SimpleInstance = 
        {
            IsStatic = false
            IsPrivate = false
            Kind = MemberKind.Simple
        }

[<AutoOpen>]
module ExtraForms =
    module I = IgnoreSourcePos

    let Lambda (a, ret, b) = Function (a, None, ret, Return b)
    let (|Lambda|_|) expr =
        match expr with
        | Function (a, None, ret, I.Return b) -> Some (a, ret, b)
        | Function (a, None, ret, I.ExprStatement b) -> Some (a, ret, Sequential [ b; Value Null ])
        | _ -> None

    let CurriedLambda (a, ret, b) = List.foldBack (fun a b -> Function ([a], None, ret, Return b)) a b
    
    let IgnoredStatementExpr(a) = StatementExpr(a, None)
    
    let WithVars(a, b) = 
        Sequential [ 
            for v in a -> NewVar (v, Undefined)
            yield b 
        ]
    
    let VarSetStatement(a, b) = ExprStatement (VarSet(a, b))
    
    let Void(a) = Unary(UnaryOperator.``void``, a)

    let NewArray(a) = NewTuple(a, [])

    let (|NewArray|_|) expr = 
        match expr with 
        | NewTuple(a, _) -> Some a
        | _ -> None

    module IgnoreSourcePos =

        let (|NewArray|_|) expr = 
            match expr with 
            | I.NewTuple(a, _) -> Some a
            | _ -> None

    let Appl (a, b, c, d) = Application(a, b, { Purity = c; KnownLength = d; Params = [] })
    let ApplAny (a, b) = Application(a, b, ApplicationInfo.None)
    let ApplTyped (a, b, c, d, e) = Application(a, b, { Purity = c; KnownLength = d; Params = e })

module JSRuntime =
    let private runtimeFunc f p args = Appl(GlobalAccess (Address.Runtime f), args, p, Some (List.length args))
    let private runtimeFuncI f p i args = Appl(GlobalAccess (Address.Runtime f), args, p, Some i)
    let Create obj props = runtimeFunc "Create" Pure [obj; props]
    let Ctor ctor typeFunction = runtimeFunc "Ctor" Pure [ctor; typeFunction]
    let Base obj baseFunc args = runtimeFunc "Base" NonPure (obj :: baseFunc :: args)
    let Clone obj = runtimeFunc "Clone" Pure [obj]
    let Force obj = runtimeFunc "Force" NonPure [obj]
    let Lazy (factory: (Expression -> Expression) -> Expression) =  
        let i = Id.New("_i")
        let setInstance x = Appl(Var i, [x], NonPure, Some 1)
        runtimeFunc "Lazy" Pure [Lambda([i], None, factory setInstance)]
    let PrintObject obj = runtimeFunc "PrintObject" Pure [obj]
    let GetOptional value = runtimeFunc "GetOptional" Pure [value]
    let SetOptional obj field value = runtimeFunc "SetOptional" NonPure [obj; field; value]
    let DeleteEmptyFields obj fields = runtimeFunc "DeleteEmptyFields" NonPure [obj; NewArray fields] 
    let CombineDelegates dels = runtimeFunc "CombineDelegates" Pure [dels]  
    let BindDelegate func obj = runtimeFunc "BindDelegate" Pure [func; obj]    
    let DelegateEqual d1 d2 = runtimeFunc "DelegateEqual" Pure [d1; d2]
    //let Curried f n = runtimeFuncI "Curried" Pure 3 [f; Value (Int n)]
    //let Curried2 f = runtimeFuncI "Curried2" Pure 1 [f]
    //let Curried3 f = runtimeFuncI "Curried3" Pure 1 [f]
    //let CurriedA f n arr = runtimeFuncI "Curried" Pure 3 [f; Value (Int n); arr]
    let Apply f obj args = runtimeFunc "Apply" Pure [f; obj; NewArray args]
    let OnLoad f = runtimeFunc "OnLoad" NonPure [f]

    let GetterOf o n = runtimeFunc "GetterOf" Pure [o; Value (String n)]
    let SetterOf o n = runtimeFunc "SetterOf" Pure [o; Value (String n)]

    let ObjectAssign toObj fromObj = Appl(GlobalAccess (Address.Lib ["Object"; "assign"]), [toObj; fromObj], NonPure, Some 2)
